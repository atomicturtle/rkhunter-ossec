#!/bin/sh

#
# rkhunter -- Scan the system for rootkits and other known security issues.
#
# Copyright (c) 2003-2009, Michael Boelen ( michael AT rootkit DOT nl )
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
#


#
# Unfortunately we must do some O/S checks at the very beginning,
# otherwise SunOS will complain about some of the ksh/bash syntax.
# By default the SunOS root account uses a simple Bourne shell,
# which does not work with RKH. So we exec to use the Bash shell
# if it is present, or the Korn shell which is usually installed
# by default on Solaris systems.
#

OPERATING_SYSTEM=`uname 2>/dev/null`

if [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	# Simple SunOS test of RANDOM to see if we are now running bash or ksh.
	if [ -z "$RANDOM" ]; then
		# If the 'which' output contains a space, then it is probably an error.
		if [ -n "`which bash 2>/dev/null | grep -v ' '`" ]; then
			exec bash $0 $*
		elif [ -n "`which ksh 2>/dev/null | grep -v ' '`" ]; then
			exec ksh $0 $*
		else
			echo "Unable to find the bash or ksh shell to run rkhunter."
			exit 1
		fi

		exit 0
	fi
fi


#
# Check to see if we are using the '--debug' option. If so, then
# we exec to log everything to the debug file.
#

if [ -n "`echo \"$*\" | grep '\-\-debug'`" ]; then
	RKHDEBUGBASE="/tmp/rkhunter-debug"

	#
	# Ensure we create a random file name.
	#

	if [ -n "`which mktemp 2>/dev/null | grep -v ' '`" ]; then
		RKHDEBUGFILE=`mktemp ${RKHDEBUGBASE}.XXXXXXXXXX`
	elif [ -n "$RANDOM" ]; then
		RKHDEBUGFILE="${RKHDEBUGBASE}.$RANDOM"
	elif [ -n "`date +%N%s 2>/dev/null | grep '^[0-9][0-9]*$'`" ]; then
		RKHDEBUGFILE="${RKHDEBUGBASE}.`date +%N%s%N`"
	else
		RKHDEBUGFILE="${RKHDEBUGBASE}.`date +%Y%m%d%H%M%S`"
	fi

	if [ -e "${RKHDEBUGFILE}" ]; then
		if [ -f "${RKHDEBUGFILE}" -a ! -h "${RKHDEBUGFILE}" ]; then
			rm -f ${RKHDEBUGFILE} >/dev/null 2>&1
		else
			echo "Cannot use '--debug' option. \"${RKHDEBUGFILE}\" already exists, but it is not a file."
			exit 1
		fi
	fi

	DEBUG_OPT=1

	exec 1>${RKHDEBUGFILE} 2>&1
	chmod 600 ${RKHDEBUGFILE} >/dev/null 2>&1
	set -x
else
	DEBUG_OPT=0
fi


#
# Now we must determine if we are using the Korn shell or not. If so,
# then we alias the 'echo' command and set ECHOOPT. For other shells,
# we try and determine the real shell being used, and test to see if
# the 'echo -e' command is valid or not. We set ECHOOPT accordingly.
#

if [ "`print "rkh-ksh-string-test" 2>/dev/null`" = "rkh-ksh-string-test" ]; then
	alias echo='print'
	ECHOOPT="--"
	MYSHELL=ksh
elif [ "${OPERATING_SYSTEM}" = "SunOS" ]; then
	# For Solaris, if we are not running ksh, then it must be bash.
	MYSHELL=bash
	ECHOOPT="-e"
else
	#
	# We want to get the actual shell used by this program, and
	# so we need to test /bin/sh.
	#

	MYSHELL=/bin/sh
	test -h ${MYSHELL} && MYSHELL=`readlink ${MYSHELL} 2>/dev/null`
	MYSHELL=`basename ${MYSHELL} 2>/dev/null`

	# Assume 'bash' if we have problems finding the real shell.
	test -z "${MYSHELL}" && MYSHELL=bash

	#
	# Now test the 'echo -e' command.
	#

	if [ "`echo -e \"rkh-ksh-string-test\" 2>/dev/null`" = "rkh-ksh-string-test" ]; then
		ECHOOPT="-e"
	else
		ECHOOPT=""
	fi
fi


#
# We now perform a similar test to see if 'echo -n' is valid
# or not. We set ECHON accordingly.
#

if [ "`echo -n \"rkh-ksh-string-test\" 2>/dev/null`" = "rkh-ksh-string-test" ]; then
	ECHON="-n"
else
	ECHON=""
fi


######################################################################
#
# Global function definitions
#
######################################################################


display() {

	#
	# This function is used to display text messages on to the
	# users screen, as well as in to the log file. The same
	# message is written to both. However, the screen may have
	# a coloured result (green for good, red for bad, etc), and
	# the log file will have the time prefixed to the message and,
	# optionally, additional information messages after the main
	# message. All the messages are indexed in the language file.
	#
	# Syntax: display --to <destination> --type <type>
	#		  [--screen-indent <n>] [--log-indent <n>]
	#		  [--nl [<n>]] [--nl-after] [--log-nl] [--nonl]
	#		  [--result <result> --color <colour>]
	#		  <message index> [optional message arguments]
	#
	# where the destination can be one of SCREEN, LOG or SCREEN+LOG.
	# The type can be one of PLAIN, INFO or WARNING.
	# The language file will have all the current values.
	#
	# The --screen-indent and --log-indent options are used to
	# forcibly indent a message.
	# The --nl option causes a blank-line to be output before the
	# message both on the screen and in the log file. A following
	# number can be used to indicate how many blank lines should
	# be displayed on the screen.
	# The --log-nl option outputs a blank line only in the log file.
	# The --nl-after option outputs a blank line on the screen after
	# the message.
	# The --nonl option is only to be used in special cases where we
	# want the output of more than one message to appear on the same
	# line. This is currently only used when trying to obtain the
	# lock file. It only applies to PLAIN messages, and may not be
	# supported on all systems (depending on whether 'echo -n' works
	# or not).
	#


	#
	# We first initialize some variables and then
	# process the switches used.
	#

	WARN_MSG=0; NL=0; NLAFTER=0; LOGINDENT=0; SCREENINDENT=0
	LOGNL=0
	WRITETO=''; TYPE=''; RESULT=''; COLOR=''; MSG=''
	LINE1=''; LOGLINE1=''; SPACES=''; NONL=''

	DISPLAY_LINE="display $*"

	if [ $# -le 0 ]; then
		echo "Error: Invalid display call - no arguments given"
		return
	fi

	while [ $# -ge 1 ]; do
		case "$1" in
		--to)
			case "$2" in
			SCREEN|LOG|SCREEN+LOG)
				WRITETO=$2
				;;
			*)
				echo "Error: Invalid display destination: $2   Display line: ${DISPLAY_LINE}"
				return
				;;
			esac

			shift
			;;
		--type)
			TYPE=`eval echo "\\$MSG_TYPE_$2"`

			if [ -z "${TYPE}" -a "$2" != "PLAIN" ]; then
				if [ $RKHLANGUPDT -eq 0 ]; then
					echo "Error: Invalid display type: $2   Display line: ${DISPLAY_LINE}"
					return
				fi
			fi

			test "$2" = "WARNING" && WARN_MSG=1

			shift
			;;
		--result)
			RESULT=`eval echo "\\$MSG_RESULT_$2"`

			if [ -z "${RESULT}" ]; then
				if [ $RKHLANGUPDT -eq 0 ]; then
					echo "Error: Invalid display result: $2   Display line: ${DISPLAY_LINE}"
					return
				fi
			fi

			shift
			;;
		--color)
			if [ $COLORS -eq 1 ]; then
				test -n "$2" && COLOR=`eval "echo \\${$2}"`

				if [ -z "${COLOR}" ]; then
					echo "Error: Invalid display color: $2   Display line: ${DISPLAY_LINE}"
					return
				fi
			fi

			shift
			;;
		--log-indent)
			LOGINDENT=$2

			if [ -z "${LOGINDENT}" ]; then
				echo "Error: No --log-indent value given.   Display line: ${DISPLAY_LINE}"
				return
			elif [ -z "`echo ${LOGINDENT} | grep '^[0-9]*$'`" ]; then
				echo "Error: Invalid '--log-indent' value given: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			shift
			;;
		--screen-indent)
			SCREENINDENT=$2

			if [ -z "${SCREENINDENT}" ]; then
				echo "Error: No --screen-indent value given.   Display line: ${DISPLAY_LINE}"
				return
			elif [ -z "`echo ${SCREENINDENT} | grep '^[0-9]*$'`" ]; then
				echo "Error: Invalid '--screen-indent' value given: $2   Display line: ${DISPLAY_LINE}"
				return
			fi

			shift
			;;
		--nl)
			NL=1

			case "$2" in
			[0-9])
				NL=$2
				shift
				;;
			esac
			;;
		--log-nl)
			LOGNL=1
			;;
		--nl-after)
			NLAFTER=1
			;;
		--nonl)
			NONL=$ECHON
			;;
		-*)
			echo "Error: Invalid display option given: $1   Display line: ${DISPLAY_LINE}"
			return
			;;
		*)
			MSG=$1
			shift
			break
			;;
		esac

		shift
	done


	#
	# Before anything we must record if this is a warning message.
	#

	test $WARN_MSG -eq 1 && WARNING_COUNT=`expr ${WARNING_COUNT} + 1`


	#
	# For simplicity we now set variables as to whether the output
	# goes to the screen and/or the log file. In some cases we do
	# not need to output anything, and so can just return.
	#

	if [ $NOLOG -eq 1 ]; then
		test "${WRITETO}" = "LOG" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="SCREEN"
	fi

	if [ $NOTTY -eq 1 ]; then
		test "${WRITETO}" = "SCREEN" && return

		test "${WRITETO}" = "SCREEN+LOG" && WRITETO="LOG"
	fi


	test "${WRITETO}" = "SCREEN" -o "${WRITETO}" = "SCREEN+LOG" && WRITETOTTY=1 || WRITETOTTY=0

	test "${WRITETO}" = "LOG" -o "${WRITETO}" = "SCREEN+LOG" && WRITETOLOG=1 || WRITETOLOG=0


	#
	# Now check that the options we have been given make sense.
	#

	if [ $WRITETOTTY -eq 0 -a $WRITETOLOG -eq 0 ]; then
		echo "Error: Invalid display destination: Display line: ${DISPLAY_LINE}"
		return
	elif [ $WRITETOTTY -eq 1 -a $COLORS -eq 1 -a -n "${RESULT}" -a -z "${COLOR}" ]; then
		echo "Error: Invalid display - no color given: Display line: ${DISPLAY_LINE}"
		return
	fi

	#
	# We only allow no newline for PLAIN messages.
	#

	test -n "${TYPE}" && NONL=""


	#
	# If we want whitelisted results to be shown as white, or
	# black for colour set two users, then change the colour now.
	#

	if [ $WLIST_IS_WHITE -eq 1 -a $WRITETOTTY -eq 1 -a $COLORS -eq 1 -a "${RESULT}" = "${MSG_RESULT_WHITELISTED}" ]; then
		COLOR=$WHITE
	fi


	#
	# We set the variable LINE1 to contain the first line of the message.
	# For the log file we use the variable LOGLINE1. We also set
	# where the language file is located. If a message cannot be found
	# in the file, then we look in the English file. This will allow RKH
	# to still work even when the language files change.
	#

	LANG_FILE="${DB_PATH}/i18n/${LANGUAGE}"

	if [ -n "${MSG}" ]; then
		LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`

		if [ -z "${LINE1}" ]; then
			LANG_FILE="${DB_PATH}/i18n/en"
			LINE1=`grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | head -n 1 | cut -d: -f2-`

			if [ -z "${LINE1}" ]; then
				echo "Error: Invalid display - language keyword cannot be found: Display line: ${DISPLAY_LINE}"
				return
			fi
		else
			LINE1=`echo "${LINE1}" | sed -e 's/\`/\\\\\`/g'`
		fi

		test -n "${LINE1}" && LINE1=`eval "echo \"${LINE1}\" | sed -e 's/;/\\;/g'"`
	fi


	#
	# At this point LINE1 is the text of the message. We have to
	# see if the message is to be indented, and must prefix the
	# time to log file messages. We must do the log file first
	# because it uses LINE1.
	#

	if [ $WRITETOLOG -eq 1 ]; then
		LOGLINE1=`date '+[%H:%M:%S]'`

		test $NL -gt 0 -o $LOGNL -eq 1 && echo "${LOGLINE1}" >>${RKHLOGFILE}

		if [ -n "${TYPE}" ]; then
			LOGLINE1="${LOGLINE1} ${TYPE}: ${LINE1}"
		else
			test $LOGINDENT -gt 0 && SPACES=`echo "${BLANK_LINE}" | cut -c1-$LOGINDENT`

			LOGLINE1="${LOGLINE1} ${SPACES}${LINE1}"
		fi
	fi

	if [ $WRITETOTTY -eq 1 -a $SCREENINDENT -gt 0 ]; then
		SPACES=`echo "${BLANK_LINE}" | cut -c1-$SCREENINDENT`
		LINE1="${SPACES}${LINE1}"
	fi


	#
	# We now check to see if a result is to be output. If it is,
	# then we need to space-out the line and color the result.
	#
	if [ -n "${RESULT}" ]; then
		if [ $WRITETOTTY -eq 1 ]; then
			LINE1_NUM=`echo "${LINE1}" | wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LINE1_NUM}`
			test $NUM_SPACES -lt 1 && NUM_SPACES=1

			if [ $COLORS -eq 0 ]; then
				SPACES=`echo "${BLANK_LINE}" | cut -c1-$NUM_SPACES`
				LINE1="${LINE1}${SPACES}[ ${RESULT} ]"
			else
				LINE1="${LINE1}\033[${NUM_SPACES}C[ ${COLOR}${RESULT}${NORMAL} ]"
			fi
		fi

		if [ $WRITETOLOG -eq 1 ]; then
			LOGLINE1_NUM=`echo "${LOGLINE1}" | wc -c | tr -d ' '`
			NUM_SPACES=`expr 62 - ${LOGLINE1_NUM}`
			test $NUM_SPACES -lt 1 && NUM_SPACES=1
			SPACES=`echo "${BLANK_LINE}" | cut -c1-$NUM_SPACES`

			LOGLINE1="${LOGLINE1}${SPACES}[ ${RESULT} ]"
		fi
	elif [ $WRITETOTTY -eq 1 -a -n "${COLOR}" ]; then
		LINE1="${COLOR}${LINE1}${NORMAL}"
	fi


	#
	# We can now output the message. We start with any required blank
	# lines, and then the first line. If this is a warning message we
	# write to the log file any additional lines.
	#

	if [ $WRITETOTTY -eq 1 ]; then
		NLLOOP=$NL
		while test $NLLOOP -gt 0; do
			echo ""
			NLLOOP=`expr ${NLLOOP} - 1`
		done

		echo $NONL $ECHOOPT "${LINE1}"
	fi

	if [ $WRITETOLOG -eq 1 ]; then
		echo $ECHOOPT "${LOGLINE1}" >>${RKHLOGFILE}

		if [ $WARN_MSG -eq 1 ]; then
			test $SHOWWARNINGSONLY -eq 1 && echo $ECHOOPT "${LOGLINE1}" | cut -d' ' -f2-

			LINE1=1
			OLDIFS="${IFS}"
			IFS=$IFSNL

			for LOGLINE1 in `grep "^${MSG}:" ${LANG_FILE} 2>/dev/null | cut -d: -f2-`; do
				if [ $LINE1 -eq 1 ]; then
					LINE1=0
					continue
				else
					test $SHOWWARNINGSONLY -eq 1 && echo $ECHOOPT "         ${LOGLINE1}"
					echo $ECHOOPT "           ${LOGLINE1}" >>${RKHLOGFILE}
				fi
			done

			IFS="${OLDIFS}"
		elif [ $SHOWWARNINGSONLY -eq 1 -a -n "`echo \"${LOGLINE1}\" | grep '^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\]         '`" ]; then
			echo $ECHOOPT "${LOGLINE1}" | cut -d' ' -f2-
		fi
	fi

	#
	# Output a final blank line if requested to do so.
	#

	test $WRITETOTTY -eq 1 -a $NLAFTER -eq 1 && echo ""

	return
}


keypresspause() {

	#
	# This function will display a prompt message to the user.
	#

	if [ $SKIP_KEY_PRESS -eq 0 -a $QUIET -eq 0 ]; then
		display --to SCREEN --type PLAIN --nl PRESSENTER
		read RKHTMPVAR

		test "${RKHTMPVAR}" = "s" -o "${RKHTMPVAR}" = "S" && SKIP_KEY_PRESS=1
	fi

	return
}


get_option() {

	#
	# This function is used to process configuration file options.
	#
	# Syntax: get_option <option type> [single | multi] <option name>
	#
	# Since different options require different needs, the first
	# argument is the 'type' of option we are processing. The second
	# argument is the word 'single' or 'multi'. This indicates if
	# the option can occur on one or more lines in the configuration
	# file. The third argument is the option name.
	#
	# There are currently two types defined:
	#
	# Type 1: A number, single word or pathname.
	# Type 2: A space-separated word list.
	#
	# Typically, single and double-quotes, spaces and tabs will be
	# removed. For type 2 options, tabs are converted to spaces, and
	# all spaces are squeezed into one. Leading and trailing spaces
	# are removed. All other types of options are processed separately.
	#
	# The function will output the final modified option.
	#
	# NOTE: This function is currently implemented such that if it returns
	# a non-zero code, then RKH will exit at the relevant point with a
	# return code of 1. However, the function does not currently return a
	# non-zero code at any time.
	#

	OPTTYPE="$1"
	OPTMULTI="$2"
	OPTV="$3"


	#
	# First see if the option is in the configuration file, and if
	# it is then process it according to the multi-line argument.
	#

	if [ -z "`grep -h \"^${OPTV}=\" ${CONFIGFILE} ${LOCALCONFIGFILE}`" ]; then
		echo ""
		return 0
	else
		case "${OPTMULTI}" in
		single)
			OPTVAR=`grep -h "^${OPTV}=" ${CONFIGFILE} ${LOCALCONFIGFILE} | tail -1 | sed -e "s/${OPTV}=//"`
			;;
		multi)
			OPTVAR=`grep -h "^${OPTV}=" ${CONFIGFILE} ${LOCALCONFIGFILE} | sed -e "s/${OPTV}=//"`
			;;
		*)
			echo "Error: Invalid multi-line argument in get_option function: $*" >&2

			# Treat this as a single-line option.
			OPTVAR=`grep -h "^${OPTV}=" ${CONFIGFILE} ${LOCALCONFIGFILE} | tail -1 | sed -e "s/${OPTV}=//"`
			;;
		esac
	fi


	#
	# Now process the option.
	#

	case "$OPTTYPE" in
	1)
		OPTVAR=`echo "${OPTVAR}" | tr -d '" 	' | tr -d "'"`
		;;
	2)
		OPTVAR=`echo "${OPTVAR}" | tr ',' ' ' | tr '	' ' ' | tr -s '	'`

		#
		# We must handle the MAIL_CMD option specially because it may
		# contain quote characters, and we do not want to remove these.
		#

		if [ "${OPTV}" != "MAIL_CMD" ]; then
			OPTVAR=`echo "${OPTVAR}" | sed -e 's/^ *"* *//; s/ *"* *$//' | sed -e "s/^ *'* *//; s/ *'* *$//"`
		fi

		OPTVAR=`echo ${OPTVAR}`
		;;
	*)
		echo "Error: Invalid option type in get_option function: $*" >&2
		;;
	esac


	echo "${OPTVAR}"

	return 0
}


get_temp_file() {

	#
	# This function will create an empty, unique temporary file.
	#
	# It takes one argument which is the pathname for the file,
	# excluding the suffix. The function will return the pathname
	# in TEMPFILE.
	#

	TEMPFILE=""

	TEMPFILE_BASE=$1


	if [ -n "${MKTEMP_CMD}" ]; then
		TEMPFILE=`${MKTEMP_CMD} ${TEMPFILE_BASE}.XXXXXXXXXX`
	elif [ -n "$RANDOM" ]; then
		TEMPFILE="${TEMPFILE_BASE}.$RANDOM"
	elif [ $BSDOS -eq 1 ]; then
		TEMPFILE="${TEMPFILE_BASE}.`date +%s`"
	elif [ -n "`date +%N%s 2>/dev/null | grep '^[0-9][0-9]*$'`" ]; then
		TEMPFILE="${TEMPFILE_BASE}.`date +%N%s%N`"
	else
		TEMPFILE="${TEMPFILE_BASE}.`date +%Y%m%d%H%M%S`"
	fi


	#
	# Remove the file just in case it already exists!
	#

	rm -f ${TEMPFILE} >/dev/null 2>&1

	return
}


suckit_extra_checks() {

	#
	# This function carries out some extra checks of the suckit rootkit.
	# There are 3 extra checks, but we only display the result after
	# all the checks have completed. As such we store the result of
	# each check in a variable, and display the final result based on
	# the value of those variables.
	#

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --log-indent 2 --nl ROOTKIT_ADD_SUCKIT_LOG
	fi


	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	#
	# The first check tests the link count of the /sbin/init file.
	# We use the NLINKS variable to indicate the test result:
	#	-1 means that no stat command was available
	#	 0 means that the stat command gave an error
	#	 1 is okay
	#	>1 means that suckit may be installed
	#

	NLINKS=-1

	if [ -n "${STAT_CMD}" ]; then
		if [ -n "`echo \"${STAT_CMD}\" | grep '\.pl$'`" ]; then
			NLINKS=`${STAT_CMD} --nlink /sbin/init 2>/dev/null`
		else
			NLINKS=`${STAT_CMD} -c %h /sbin/init 2>/dev/null`
		fi

		test -z "${NLINKS}" && NLINKS=0

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ $NLINKS -eq 0 ]; then
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_LINK_COUNT "/sbin/init"
			elif [ $NLINKS -eq 1 ]; then
				display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_LINK_COUNT "/sbin/init"
			else
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_LINK_COUNT "/sbin/init"
			fi
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 4 ROOTKIT_LINK_COUNT "/sbin/init"
	fi


	#
	# The next test checks to see if certain files are being
	# hidden. These files have the '.xrk' or '.mem' suffix.
	# The HIDDEN variable will be used to indicate the result:
	#	<null> is okay
	#	'xrk' means that the 'xrk' suffix is hidden
	#	'mem' means that the 'mem' suffix is hidden
	#

	HIDDEN=""

	for EXT in xrk mem; do
		get_temp_file "${RKHTMPDIR}/suckitexttest"

		touch ${TEMPFILE}
		rm -f ${TEMPFILE}.${EXT} >/dev/null 2>&1
		mv ${TEMPFILE} ${TEMPFILE}.${EXT}

		if [ ! -f "${TEMPFILE}.${EXT}" ]; then
			if [ -n "${HIDDEN}" ]; then
				HIDDEN="${HIDDEN} and ${EXT}"
			else
				HIDDEN=${EXT}
			fi
		fi

		rm -f "${TEMPFILE}.${EXT}" >/dev/null 2>&1
	done

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		if [ -z "${HIDDEN}" ]; then
			display --to LOG --type PLAIN --result NONE_FOUND --log-indent 4 ROOTKIT_ADD_SUCKIT_EXT
		else
			display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_ADD_SUCKIT_EXT
		fi
	fi


	#
	# Finally we perform a check using the skdet command, if it
	# is present. The SKDET variable will be used to indicate
	# the result:
	#	-1 means that skdet is not available
	#	 0 means that skdet found nothing
	#	 1 means that skdet found something
	#	 2 means that the version of skdet is unknown
	#
	# The variable SKDET_OUTPUT will contain any output from
	# the command.
	#

	SKDET=-1
	SKDET_OUTPUT=""
	SKDET_CMD=`find_cmd skdet`

	if [ -n "${SKDET_CMD}" ]; then
		#
		# We need to check the skdet version first.
		#

		SKDET=0
		SKDETOPT=""
		SKDETVER=`${SKDET_CMD} -v 2>&1 | grep '^skdet.v' | awk -F'.' '{ print $1 }'`

		case "${SKDETVER}" in
		*v0)
			SKDETOPT="-a"
			;;
		*v1)
			SKDETOPT="-c"
			;;
		*)
			SKDET=2
			SKDET_OUTPUT=`${SKDET_CMD} -v 2>&1`
			;;
		esac

		if [ $SKDET -eq 0 ]; then
			SKDET_OUTPUT=`${SKDET_CMD} ${SKDETOPT} 2>&1 | tr -s ' ' | grep -i 'invis'`

			test -n "${SKDET_OUTPUT}" && SKDET=1
		fi

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ $SKDET -eq 0 ]; then
				display --to LOG --type PLAIN --result OK --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
			else
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
			fi
		fi
	elif [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --result SKIPPED --log-indent 4 ROOTKIT_ADD_SUCKIT_SKDET
		display --to LOG --type INFO NOT_FOUND_CMD "skdet"
	fi


	#
	# Now we can display the results.
	#

	if [ $NLINKS -eq 1 -a -z "${HIDDEN}" -a $SKDET -le 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_ADD_SUCKIT
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}Suckit Rookit (additional checks), "

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_ADD_SUCKIT

		if [ $NLINKS -eq -1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_LINK_NOCMD
		elif [ $NLINKS -eq 0 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_LINK_COUNT_CMDERR "${STAT_CMD}" "/sbin/init"
		elif [ $NLINKS -gt 1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_LINK_FOUND "$NLINKS"
		fi

		if [ -n "${HIDDEN}" ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_EXT_FOUND "${HIDDEN}"
		fi

		if [ $SKDET -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_SKDET_FOUND "${SKDET_OUTPUT}"
		elif [ $SKDET -eq 2 ]; then
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_ADD_SUCKIT_SKDET_VER "${SKDET_OUTPUT}"
		fi
	fi

	return
}


scanrootkit() {

	#
	# This function performs the actual check for a rootkit.
	# It uses the variables SCAN_ROOTKIT, SCAN_FILES, SCAN_DIRS
	# and SCAN_KSYMS. These will have been set before the
	# function is called.
	#

	SCAN_STATUS=0

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi


	#
	# First check to see if any of the known files exist.
	#

	FILE_FOUND=""

	for RKHTMPVAR2 in ${SCAN_FILES}; do
		RKHTMPVAR=`echo "${RKHTMPVAR2}" | tr '%' ' '`

		#
		# If the option SCANROOTKITMODE is set to "THOROUGH" the scanrootkit()  function
		# will search (on a per rootkit basis) for filenames in all of the directories (as defined
		# by the result of running 'find "${RKHROOTDIR}/" -xdev'). While still not optimal, as it 
		# still searches for only file names as opposed to file contents, this is one step away
		# from the rigidity of searching in known (evidence) or default (installation) locations.
		#
		# THIS OPTION SHOULD NOT BE ENABLED BY DEFAULT
		# You should only activate this feature as part of a more thorough investigation which
		# should be based on relevant best practices and procedures. 
		# Apart from ameliorating the case with respect to functionality (e.g. reporting) this feature does not
		# concern itself with efficiency so asking for improvements like whitelisting, de-duping or false positives is 
		# out of the question.
		# Enabling this feature implies you have the knowledge to interprete results properly.
		#

		case "${SCANROOTKITMODE}" in
			THOROUGH) # Search the whole filesystem
					RKHTMPVAR=`basename "${RKHTMPVAR}"`
					RKHTMPVAR=`find "${RKHROOTDIR}/" -xdev -iname "${RKHTMPVAR}"`
					for RKHTMPVARITEM in $RKHTMPVAR; do
						if [ -f "${RKHTMPVAR}" -o -b "${RKHTMPVAR}" -o -c "${RKHTMPVAR}" -o -L "${RKHTMPVAR}" -o -p "${RKHTMPVAR}" -o -S "${RKHTMPVAR}" ]; then
							SCAN_STATUS=1
							FILE_FOUND="${FILE_FOUND} ${RKHTMPVAR2}"
							test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_FILE "${RKHTMPVAR}"
						fi
					done
				;;
				*) # Scan ze old vay
					if [ -f "${RKHTMPVAR}" ]; then
						#
						# We first check to see if the file is whitelisted. Note that we use
						# the un-translated file name. This allows us to check for filenames
						# with spaces, but without causing problems for our space-delimited test.
						#
	
						RKHTMPVAR3=`echo "${RKHTMPVAR2}" | sed -e 's/\./\\\./g'`
	
						if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR3} \"`" ]; then
							display --to LOG --type INFO FILE_PROP_WL "${RKHTMPVAR}" rootkit
						else
							SCAN_STATUS=1
							FILE_FOUND="${FILE_FOUND} ${RKHTMPVAR2}"
						fi
	
						test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_FILE "${RKHTMPVAR}"
					elif [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_FILE "${RKHTMPVAR}"
					fi
				;;
		esac
	done


	#
	# Next check to see if any of the directories exist.
	#

	DIR_FOUND=""

	for RKHTMPVAR2 in ${SCAN_DIRS}; do
		RKHTMPVAR=`echo "${RKHTMPVAR2}" | tr '%' ' '`

		if [ -d "${RKHTMPVAR}" ]; then
			#
			# We first check to see if the directory is whitelisted. Note that we use
			# the un-translated directory name. This allows us to check for directory
			# names with spaces, but without causing problems for our space-delimited test.
			#

			RKHTMPVAR3=`echo "${RKHTMPVAR2}" | sed -e 's/\./\\\./g'`

			if [ -n "`echo \"${RTKT_DIR_WHITELIST}\" | grep \" ${RKHTMPVAR3} \"`" ]; then
				display --to LOG --type INFO FILE_PROP_WL_DIR "${RKHTMPVAR}" rootkit
			else
				SCAN_STATUS=1
				DIR_FOUND="${DIR_FOUND} ${RKHTMPVAR2}"
			fi

			test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${RKHTMPVAR}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${RKHTMPVAR}"
		fi
	done


	#
	# Next check the ksyms or kallsyms file.
	#

	KSYM_FOUND=""

	if [ -n "${SCAN_KSYMS}" ]; then
		for KS in ${SCAN_KSYMS}; do
			if [ -n "${KSYMS_FILE}" ]; then
				KSYM=`echo "${KS}" | sed -e 's/\./\\\./g'`

				if [ -n "`grep \"${KSYM}\" ${KSYMS_FILE}`" ]; then
					SCAN_STATUS=1
					KSYM_FOUND="${KSYM_FOUND} ${KS}"

					test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND  --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
				elif [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "${KS}"
			fi
		done
	fi


	#
	# Now display the results.
	#

	if [ $SCAN_STATUS -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 NAME "${SCAN_ROOTKIT}"
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"


		#
		# Log any files, directories or ksyms found.
		#

		for RKHTMPVAR in ${FILE_FOUND}; do
			RKHTMPVAR=`echo "${RKHTMPVAR}" | tr '%' ' '`
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_FILE_FOUND "${RKHTMPVAR}"
		done

		for RKHTMPVAR in ${DIR_FOUND}; do
			RKHTMPVAR=`echo "${RKHTMPVAR}" | tr '%' ' '`
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_DIR_FOUND "${RKHTMPVAR}"
		done

		for RKHTMPVAR in ${KSYM_FOUND}; do
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_KSYM_FOUND "${RKHTMPVAR}"
		done
	fi

	return
}


check_required_commands() {

	#
	# This function checks that some required commands are
	# present on the system. The function takes one argument
	# which is a list of directories to look in.
	#

	for CMD in ${REQCMDS}; do
		SEEN=0

		for DIR in $1; do
			if [ -f "${DIR}/${CMD}" -a -x "${DIR}/${CMD}" ]; then
				SEEN=1
				break
			fi
		done

		if [ $SEEN -eq 0 ]; then
			echo "The command '$CMD' must be present on the system in order to run rkhunter."
			exit 1
		fi
	done

	return
}


check_commands() {

	#
	# We check for some commands used in the tests. If the command
	# is found then a variable including the command name is set.
	# These commands are not 'required', so nothing happens if the
	# command is not found. The commands can be defined in the
	# configuration file, and a value of 'DISABLED' will cause a
	# command to not exist. A value of 'BUILTIN' may be used for
	# the 'stat' and 'readlink' commands, to indicate that the
	# supplied scripts should be used. We have to handle the 'stat'
	# command in a special way so that the perl module does not get
	# used if the command is to be disabled.
	#

	for CMD in ${CMDLIST}; do
		RKHTMPVAR=`echo ${CMD} | tr '[:lower:]' '[:upper:]'`
		RKHTMPVAR="${RKHTMPVAR}_CMD"


		#
		# See if the user has defined the command in
		# the configuration file.
		#

		CFG_CMD=`get_option 2 single "${RKHTMPVAR}"` || exit 1

		if [ -n "${CFG_CMD}" ]; then
			if [ "${CFG_CMD}" = "DISABLED" -o "${CFG_CMD}" = "BUILTIN" ]; then
				eval ${RKHTMPVAR}=\"${CFG_CMD}\"
			else
				#
				# Check that the command is executable.
				#

				MCMD=`echo "${CFG_CMD}" | cut -d' ' -f1`

				if [ -n "`find_cmd ${MCMD}`" ]; then
					eval ${RKHTMPVAR}=\"${CFG_CMD}\"
				else
					CFG_CMD=""
				fi
			fi
		fi


		#
		# If the command has not been predefined, or is not
		# executable, then go find the command to use.
		#

		test -z "${CFG_CMD}" && eval ${RKHTMPVAR}=`find_cmd ${CMD}`
	done


	#
	# If we cannot find a 'stat' command, or the supplied script is to
	# be used, then we must check to see if perl is available. If it is,
	# then the supplied 'stat' script can be used.
	#

	if [ -n "${PERL_CMD}" -a "${PERL_CMD}" != "DISABLED" ]; then
		if [ -z "${STAT_CMD}" -o "${STAT_CMD}" = "BUILTIN" ]; then
			if [ -r "${SCRIPT_PATH}/check_modules.pl" ]; then
				MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl File::stat Getopt::Long 2>&1 | grep 'NOT installed'`
			else
				MOD_INSTALLED="module not found"
			fi

			if [ -z "${MOD_INSTALLED}" -a -r "${SCRIPT_PATH}/stat.pl" ]; then
				STAT_CMD="${PERL_CMD} ${SCRIPT_PATH}/stat.pl"
			else
				STAT_CMD=""
			fi
		fi
	elif [ "${STAT_CMD}" = "BUILTIN" ]; then
		STAT_CMD=""
	fi


	#
	# If the readlink command cannot be found, or it does not support
	# the '-f' option, then we must use the supplied shell script.
	#

	if [ -z "${READLINK_CMD}" -o "${READLINK_CMD}" = "BUILTIN" ]; then
		test -x "${SCRIPT_PATH}/readlink.sh" && READLINK_CMD="${SCRIPT_PATH}/readlink.sh" || READLINK_CMD=""
	elif [ -n "`${READLINK_CMD} -f ${SCRIPT_PATH}/readlink.sh 2>&1 >/dev/null`" ]; then
		test -x "${SCRIPT_PATH}/readlink.sh" && READLINK_CMD="${SCRIPT_PATH}/readlink.sh" || READLINK_CMD=""
	fi

	test -n "${READLINK_CMD}" && HAVE_READLINK=1


	#
	# Finally we must remove all the DISABLED commands.
	#

	for CMD in ${CMDLIST}; do
		RKHTMPVAR=`echo ${CMD} | tr '[:lower:]' '[:upper:]'`
		RKHTMPVAR="${RKHTMPVAR}_CMD"
		RKHTMPVAR2=`eval echo "\\$${RKHTMPVAR}"`

		test "${RKHTMPVAR2}" = "DISABLED" -o "${RKHTMPVAR2}" = "BUILTIN" && eval ${RKHTMPVAR}=\"\"
	done

	return
}


get_installdir_option() {

	#
	# This function obtains the RKH installation directory. It must
	# be set by the installer script, and has no default.
	#

	RKHINSTALLDIR=`get_option 1 single INSTALLDIR` || exit 1

	if [ -z "${RKHINSTALLDIR}" ]; then
		echo "Invalid INSTALLDIR configuration option - no installation directory specified."
		exit 1
	elif [ ! -d "${RKHINSTALLDIR}" ]; then
		echo "Installation directory does not exist: ${RKHINSTALLDIR}"
		exit 1
	elif [ ! -r "${RKHINSTALLDIR}" ]; then
		echo "Installation directory is not readable: ${RKHINSTALLDIR}"
		exit 1
	fi

	return
}


get_language_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${LANGUAGE}" ]; then
		LANGUAGE=`echo "${LANGUAGE}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${LANGUAGE}" ]; then
			echo "Invalid '--language' option - no language given."
			exit 1
		fi
	else
		LANGUAGE=`get_option 1 single LANGUAGE` || exit 1
	fi

	#
	# If no language has been set, then use English.
	#

	test -z "${LANGUAGE}" && LANGUAGE="en"


	#
	# Now check that the language is available.
	#

	if [ ! -d "${DB_PATH}/i18n" ]; then
		echo "The internationalisation directory does not exist: ${DB_PATH}/i18n"
		exit 1
	fi

	#
	# If we are using the '--update' option, then the language files
	# will be installed if they are missing. As such, we cannot check
	# them here.
	#

	if [ ! -s "${DB_PATH}/i18n/${LANGUAGE}" -a "${LANGUAGE}" != "en" ]; then
		if [ $UPDATE_ONLY -eq 1 ]; then
			RKHLANGUPDT=1
		else
			echo "The language specified is not available: ${LANGUAGE}"
			echo "Use the command 'rkhunter --lang en --list languages' to see the list of available languages."
			exit 1
		fi
	elif [ ! -s "${DB_PATH}/i18n/en" ]; then
		if [ $UPDATE_ONLY -eq 1 ]; then
			RKHLANGUPDT=1
		else
			echo "The English language file must be present: ${DB_PATH}/i18n/en"
			echo "If it has been deleted, then you will need to run 'rkhunter --update' with no other options."
			exit 1
		fi
	fi

	#
	# Finally, find out what languages the user wants to be updated.
	# We add in the default language, and 'en', if they have not
	# been specified.
	#

	if [ $UPDATE -eq 1 ]; then
		UPDATE_LANG=`get_option 2 single UPDATE_LANG` || exit 1

		if [ -n "${UPDATE_LANG}" ]; then
			if [ -z "`echo \" ${UPDATE_LANG} \" | grep \" ${LANGUAGE} \"`" ]; then
				UPDATE_LANG="${UPDATE_LANG} ${LANGUAGE}"
			fi

			if [ -z "`echo \" ${UPDATE_LANG} \" | grep ' en '`" ]; then
				UPDATE_LANG="${UPDATE_LANG} en"
			fi
		fi
	fi

	return
}


get_logfile_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${RKHLOGFILE}" ]; then
		RKHLOGFILE=`echo "${RKHLOGFILE}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${RKHLOGFILE}" ]; then
			echo "Invalid '--logfile' option - no logfile name given."
			exit 1
		fi
	else
		RKHLOGFILE=`get_option 1 single LOGFILE` || exit 1

		if [ -z "${RKHLOGFILE}" ]; then
			RET_CODE=1
			RKHLOGFILE="${DFLT_LOGFILE}"
			echo "Default logfile will be used (${RKHLOGFILE})."
		fi
	fi

	#
	# Now check that the given option is usable.
	#

	if [ "${RKHLOGFILE}" = "/dev/null" ]; then
		APPEND_LOG=0
	else
		LOGDIR=`echo "${RKHLOGFILE}" | sed -e 's:/[^/][^/]*$::'`

		if [ -z "`echo \"${LOGDIR}\" | grep '/'`" ]; then
			LOGDIR="."
		fi

		if [ "${LOGDIR}" = "${RKHLOGFILE}" ]; then
			echo "No log filename given: ${RKHLOGFILE}"
			exit 1
		elif [ ! -d "${LOGDIR}" ]; then
			echo "Logfile directory does not exist: ${RKHLOGFILE}"
			exit 1
		elif [ ! -w "${LOGDIR}" ]; then
			echo "Logfile directory is not writable: ${RKHLOGFILE}"
			exit 1
		elif [ ! -r "${LOGDIR}" ]; then
			echo "Logfile directory is not readable: ${RKHLOGFILE}"
			exit 1
		elif [ -h "${RKHLOGFILE}" ]; then
			echo "Logfile is a symbolic link: ${RKHLOGFILE}"
			echo "This is a security problem. The link points to another file, and that file is about to be modified by rkhunter."
			exit 1
		elif [ -e "${RKHLOGFILE}" -a ! -f "${RKHLOGFILE}" ]; then
			echo "Logfile already exists but it is not a file: ${RKHLOGFILE}"
			exit 1
		fi


		#
		# Now check whether we should append to the logfile
		# or overwrite it. We check the configuration file
		# option, if it is given, and ensure that it is valid.
		#

		if [ $APPEND_OPT -eq 0 ]; then
			APPEND_LOG=`get_option 1 single APPEND_LOG` || exit 1

			if [ -n "${APPEND_LOG}" ]; then
				if [ "${APPEND_LOG}" != "0" -a "${APPEND_LOG}" != "1" ]; then
					echo "Invalid APPEND_LOG configuration option: not a valid number: ${APPEND_LOG}"
					exit 1
				fi
			else
				APPEND_LOG=0
			fi
		fi


		#
		# Finally, check if the logfile should be copied if
		# there were any errors or warnings. Obviously no
		# copy is done if no logfile is used.
		#

		RKHTMPVAR=`get_option 1 single COPY_LOG_ON_ERROR` || exit 1

		if [ -n "${RKHTMPVAR}" ]; then
			if [ "${RKHTMPVAR}" = "0" -o "${RKHTMPVAR}" = "1" ]; then
				COPY_LOG_ON_ERROR=$RKHTMPVAR
			else
				echo "Invalid COPY_LOG_ON_ERROR configuration option: not a valid number: ${RKHTMPVAR}"
				exit 1
			fi
		fi
	fi

	return
}


get_tmpdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${RKHTMPDIR}" ]; then
		RKHTMPDIR=`echo "${RKHTMPDIR}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${RKHTMPDIR}" ]; then
			echo "Invalid '--tmpdir' option - no directory name given."
			exit 1
		fi
	else
		RKHTMPDIR=`get_option 1 single TMPDIR` || exit 1

		if [ -z "${RKHTMPDIR}" ]; then
			RET_CODE=1
			RKHTMPDIR="${RKHINSTALLDIR}/lib/rkhunter/tmp"
			echo "Default temporary directory will be used (${RKHTMPDIR})."
		fi
	fi

	#
	# Now check that the given option is usable.
	#

	if [ ! -d "${RKHTMPDIR}" ]; then
		echo "Temporary directory does not exist: ${RKHTMPDIR}"
		exit 1
	elif [ ! -w "${RKHTMPDIR}" ]; then
		echo "Temporary directory is not writable: ${RKHTMPDIR}"
		exit 1
	elif [ ! -r "${RKHTMPDIR}" ]; then
		echo "Temporary directory is not readable: ${RKHTMPDIR}"
		exit 1
	elif [ "${RKHTMPDIR}" = "${RKHROOTDIR}/tmp" -o "${RKHTMPDIR}" = "${RKHROOTDIR}/var/tmp" ]; then
		echo "Do not use ${RKHTMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to contain system files, so it must be secure."
		exit 1
	elif [ "${RKHTMPDIR}" = "${RKHROOTDIR}/etc" ]; then
		echo "Do not use ${RKHTMPDIR} as the temporary directory."
		echo "This directory will be used by rkhunter to copy and delete certain system files."
		exit 1
	fi

	return
}


get_dbdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${DB_PATH}" ]; then
		DB_PATH=`echo "${DB_PATH}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${DB_PATH}" ]; then
			echo "Invalid '--dbdir' option - no directory name given."
			exit 1
		fi
	else
		DB_PATH=`get_option 1 single DBDIR` || exit 1

		if [ -z "${DB_PATH}" ]; then
			RET_CODE=1
			DB_PATH="${RKHINSTALLDIR}/lib/rkhunter/db"
			echo "Default database directory will be used (${DB_PATH})."
		fi
	fi

	#
	# Now check that the given option is usable.
	#

	if [ ! -d "${DB_PATH}" ]; then
		echo "Database directory does not exist: ${DB_PATH}"
		exit 1
	elif [ ! -r "${DB_PATH}" ]; then
		echo "Database directory is not readable: ${DB_PATH}"
		exit 1
	elif [ $PROP_UPDATE -eq 1 -o $UPDATE -eq 1 ]; then
		if [ ! -w "${DB_PATH}" ]; then
			echo "Database directory is not writable: ${DB_PATH}"
			exit 1
		fi
	fi

	RKHDAT_FILE="${DB_PATH}/rkhunter.dat"
	RKH_FILEPROP_LIST="${DB_PATH}/rkhunter_prop_list.dat"

	return
}


add_extra_dirs() {

	#
	# This functions takes care of any additional directories
	# that may exist on some systems. After the function is called
	# the value of EXTRA_DIRS must be added to whatever variable
	# is being used.
	#

	EXTRA_DIRS=""

	if [ $SUNOS -eq 1 ]; then
		#
		# Add in some other directories, and those which
		# contain the Sun 'companion' software.
		#

		test -d /usr/sfw && EXTRA_DIRS="${EXTRA_DIRS} /usr/sfw/bin /usr/sfw/sbin /usr/sfw/libexec"
		test -d /opt/sfw && EXTRA_DIRS="${EXTRA_DIRS} /opt/sfw/bin /opt/sfw/sbin /opt/sfw/libexec"
		test -d /usr/xpg4/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/xpg4/bin"
		test -d /usr/ccs/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/ccs/bin"
		test -d /usr/5bin -a ! -h /usr/5bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/5bin"
		test -d /usr/ucb && EXTRA_DIRS="${EXTRA_DIRS} /usr/ucb"


		#
		# OpenSolaris distributions (e.g. BeleniX) may use
		# other directories.
		#

		test -d /usr/foss && EXTRA_DIRS="${EXTRA_DIRS} /usr/foss/bin /usr/foss/sbin /usr/foss/libexec"
	elif [ $BSDOS -eq 1 ]; then
		test -d /usr/pkg/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/bin"
		test -d /usr/pkg/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/sbin"
		test -d /usr/pkg/libexec && EXTRA_DIRS="${EXTRA_DIRS} /usr/pkg/libexec"
	elif [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		#
		# Cater for Fink (Mac OS X) additional software.
		#

		test -d /sw/bin && EXTRA_DIRS="${EXTRA_DIRS} /sw/bin"
		test -d /sw/sbin && EXTRA_DIRS="${EXTRA_DIRS} /sw/sbin"
	elif [ $IRIXOS -eq 1 ]; then
		test -d /usr/ucb && EXTRA_DIRS="${EXTRA_DIRS} /usr/ucb"
		test -d /usr/freeware/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/freeware/bin"
		test -d /usr/freeware/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/freeware/sbin"
		test -d /usr/xpg4/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/xpg4/bin"
	elif [ -f "/etc/GoboLinuxVersion" ]; then
		#
		# We have no other easy way of detecting GoboLinux.
		# It has a peculiar filesystem layout, so we need to
		# add in this little bit of support to help it work
		# with RKH.
		#

		test -d "/System/Links/Executables" && EXTRA_DIRS="/System/Links/Executables"
	fi


	#
	# Finally check if there are any optional
	# bin and sbin directories present.
	#

	test -d /usr/opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/bin"
	test -d /usr/opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /usr/opt/sbin"
	test -d /opt/bin && EXTRA_DIRS="${EXTRA_DIRS} /opt/bin"
	test -d /opt/sbin && EXTRA_DIRS="${EXTRA_DIRS} /opt/sbin"

	return
}


get_bindir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	USE_DFLT=0

	if [ -n "${BINPATHS}" ]; then
		BINPATHS=`echo "${BINPATHS}" | tr -d '"' | tr -d "'" | tr '	' ' ' | tr -s ' '`

		if [ "${BINPATHS}" = " " ]; then
			echo "Invalid '--bindir option' - no directory names given."
			exit 1
		fi
	else
		BINPATHS=`get_option 2 single BINDIR` || exit 1

		if [ -z "${BINPATHS}" ]; then
			USE_DFLT=1

			BINPATHS="${DFLT_BINPATHS}"


			#
			# Under some OS's /bin is a link to /usr/bin, so
			# there is no need to look in it.
			#

			if [ $SUNOS -eq 1 -o $IRIXOS -eq 1 -o "${OPERATING_SYSTEM}" = "AIX" ]; then
				if [ -h /bin ]; then
					RKHB=""

					for DIR in ${BINPATHS}; do
						test "${DIR}" != "/bin" && RKHB="${RKHB} ${DIR}"
					done

					BINPATHS=`echo ${RKHB}`
				fi
			fi


			add_extra_dirs
			BINPATHS="${BINPATHS}${EXTRA_DIRS}"
		fi
	fi


	#
	# This is a simple check that each directory begins with
	# a '.' or '/'. We allow non-existent directories because
	# this list may be used with RKHROOTDIR. As such the directory
	# may not exist on the local host, but may exist on a
	# remotely diagnosed system.
	#

	for DIR in ${BINPATHS}; do
		if [ -z "`echo ${DIR} | grep '^[./]'`" ]; then
			echo "Invalid BINDIR directory found: ${DIR}"
			exit 1
		fi
	done

	return
}


get_scriptdir_option() {

	#
	# Get the value from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#
	# Note: The installer will set this option. As such there
	# is no default.
	#

	SCRIPT_PATH=`get_option 1 single SCRIPTDIR` || exit 1

	if [ -z "${SCRIPT_PATH}" ]; then
		echo "The SCRIPTDIR configuration option has not been set by the installer."
		exit 1
	fi

	#
	# Now check that the given option is usable.
	#

	if [ ! -d "${SCRIPT_PATH}" ]; then
		echo "Script directory does not exist: ${SCRIPT_PATH}"
		exit 1
	elif [ ! -r "${SCRIPT_PATH}" ]; then
		echo "Script directory is not readable: ${SCRIPT_PATH}"
		exit 1
	fi

	return
}


find_cmd() {

	#
	# This function performs a search of the PATH and BINPATHS
	# directories looking for the requested command. The full
	# pathname is returned if the command is found.
	#
	# If a full pathname is provided then we simply check that
	# it is executable.
	#

	CMD=$1

	test -z "${CMD}" && return

	if [ -n "`echo ${CMD} | grep '/'`" ]; then
		test -f "${CMD}" -a -x "${CMD}" && echo "${CMD}"
	else
		for CMDDIR in ${SPACEDPATH} ${BINPATHS}; do
			if [ -f "${CMDDIR}/${CMD}" -a -x "${CMDDIR}/${CMD}" ]; then
				echo "${CMDDIR}/${CMD}"
				return
			fi
		done
	fi

	return
}


get_rootdir_option() {

	#
	# First get the option from the command-line or the
	# configuration file, and do a simple check on whether
	# it is empty or a space.
	#

	if [ -n "${RKHROOTDIR}" ]; then
		RKHROOTDIR=`echo "${RKHROOTDIR}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${RKHROOTDIR}" ]; then
			echo "Invalid '--rootdir' option - no directory name given."
			exit 1
		fi
	else
		RKHROOTDIR=`get_option 1 single ROOTDIR` || exit 1
	fi

	#
	# Now check that the given option is usable.
	#

	if [ -n "${RKHROOTDIR}" ]; then
		if [ ! -d "${RKHROOTDIR}" ]; then
			echo "The root directory does not exist: ${RKHROOTDIR}"
			exit 1
		elif [ ! -r "${RKHROOTDIR}" ]; then
			echo "The root directory is not readable: ${RKHROOTDIR}"
			exit 1
		fi
	fi

	return
}


get_mailonwarn_option() {

	#
	# Get the option from the configuration file. If it is set,
	# then we get the MAIL_CMD option as well.
	#

	MAILONWARNING=`get_option 2 single MAIL-ON-WARNING` || exit 1

	if [ -n "${MAILONWARNING}" ]; then
		MAIL_CMD=`get_option 2 single MAIL_CMD` || exit 1

		test -z "${MAIL_CMD}" && MAIL_CMD="mail -s \"[rkhunter] Warnings found for \${HOST_NAME}\""


		#
		# Check that the mail command is executable.
		#

		MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f1`
		MC=`find_cmd ${MCMD}`

		if [ -n "${MC}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			MCMD=`echo "${MAIL_CMD}" | cut -d' ' -f2-`

			if [ -z "${MCMD}" -o "${MCMD}" = "${MAIL_CMD}" ]; then
				MAIL_CMD=$MC
			else
				MAIL_CMD="${MC} ${MCMD}"
			fi
		else
			echo "Invalid MAIL_CMD configuration option - command '${MCMD}' is non-existent or not executable."
			exit 1
		fi
	elif [ -z "`grep -h \"^MAIL-ON-WARNING=\" ${CONFIGFILE} ${LOCALCONFIGFILE}`" ]; then
		RET_CODE=1
		echo "No MAIL-ON-WARNING option has been configured."
	fi

	return
}


get_webcmd_option() {

	#
	# Get the option from the configuration file. If it is set,
	# then we set the RKHWEBCMD_OPTS option as well if necessary.
	#

	RKHWEBCMD=`get_option 2 single WEBCMD` || exit 1

	if [ -n "${RKHWEBCMD}" ]; then
		#
		# Check that the command is executable.
		#

		WCMD=`echo "${RKHWEBCMD}" | cut -d' ' -f1`
		WC=`find_cmd ${WCMD}`

		if [ -n "${WC}" ]; then
			#
			# We find if there any command options, and set
			# the command to use the full pathname.
			#

			RKHWEBCMD_OPTS=`echo "${RKHWEBCMD}" | cut -d' ' -f2-`

			test "${RKHWEBCMD_OPTS}" = "${RKHWEBCMD}" && RKHWEBCMD_OPTS=""

			RKHWEBCMD="${WC}"
			test -n "${BASENAME_CMD}" && RKHWEBCMD_BASE=`${BASENAME_CMD} ${WC}` || RKHWEBCMD_BASE=`echo "${WC}" | sed -e 's:^.*/::'`
		else
			echo "Invalid WEBCMD configuration option - command '${WCMD}' is non-existent or not executable."
			exit 1
		fi
	fi

	return
}


get_syslog_option() {

	#
	# First see if we want to use syslog or not from the command-line
	# or configuration file.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${USE_SYSLOG}" ]; then
			echo "Invalid '--syslog' option - no facility/priority names given."
			exit 1
		fi
	else
		USE_SYSLOG=`get_option 1 single USE_SYSLOG` || exit 1
	fi


	#
	# If we are to use syslog, then get the facility and priority levels.
	# Additionally, test that they are valid.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		USE_SYSLOG=`echo "${USE_SYSLOG}" | tr '[:upper:]' '[:lower:]'`

		if [ "${USE_SYSLOG}" = "none" ]; then
			# The value of 'none' will be processed later on.
			return
		elif [ -z "`echo \"${USE_SYSLOG}\" | grep '^[a-z][a-z0-7]*\.[a-z][a-z]*$'`" ]; then
			echo "Invalid syslog facility/priority value: ${USE_SYSLOG}"
			exit 1
		fi

		FOUND=0

		SYSLOG_F=`echo "${USE_SYSLOG}" | cut -d. -f1`
		SYSLOG_P=`echo "${USE_SYSLOG}" | cut -d. -f2`

		for RKHTMPVAR in auth authpriv cron daemon kern user local0 local1 local2 local3 local4 local5 local6 local7; do
			if [ "${SYSLOG_F}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog facility name: ${SYSLOG_F}"
			exit 1
		fi


		FOUND=0

		for RKHTMPVAR in debug info notice warning err crit alert emerg; do
			if [ "${SYSLOG_P}" = "${RKHTMPVAR}" ]; then
				FOUND=1
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "Invalid syslog priority name: ${SYSLOG_P}"
			exit 1
		fi
	fi

	return
}


get_ssh_options() {

	#
	# We check some SSH options in this function. They can only
	# be set in the configuration file.
	#

	#
	# See if the ALLOW_SSH_ROOT_USER option is specified in the
	# configuration file. The value should match what has been set
	# in the SSH configuration file for the PermitRootLogin option.
	# As such it's value is not just zero or one.
	#

	ALLOW_SSH_ROOT_USER=`get_option 1 single ALLOW_SSH_ROOT_USER` || exit 1

	if [ -n "${ALLOW_SSH_ROOT_USER}" ]; then
		ALLOW_SSH_ROOT_USER=`echo "${ALLOW_SSH_ROOT_USER}" | tr '[:upper:]' '[:lower:]'`
	else
		#
		# By default SSH tends to allow root access. However, we
		# do not. By setting this option to 'no', the user will
		# receive a warning unless they set the options the same.
		#

		ALLOW_SSH_ROOT_USER="no"
	fi


	#
	# See if the ALLOW_SSH_PROT_V1 option is specified in the
	# configuration file.
	#

	ALLOW_SSH_PROT_V1=`get_option 1 single ALLOW_SSH_PROT_V1` || exit 1

	if [ -n "${ALLOW_SSH_PROT_V1}" ]; then
		if [ "${ALLOW_SSH_PROT_V1}" != "0" -a "${ALLOW_SSH_PROT_V1}" != "1" -a "${ALLOW_SSH_PROT_V1}" != "2" ]; then
			echo "Invalid ALLOW_SSH_PROT_V1 configuration option: not a valid number: ${ALLOW_SSH_PROT_V1}"
			exit 1
		fi
	else
		ALLOW_SSH_PROT_V1=0
	fi


	#
	# See if the directory of the SSH configuration file has been set.
	#

	SSH_CONFIG_DIR=`get_option 1 single SSH_CONFIG_DIR` || exit 1

	if [ -n "${SSH_CONFIG_DIR}" ]; then
		if [ ! -d "${SSH_CONFIG_DIR}" ]; then
			echo "The SSH configuration file directory does not exist: ${SSH_CONFIG_DIR}"
			exit 1
		elif [ ! -r "${SSH_CONFIG_DIR}" ]; then
			echo "The SSH configuration file directory is not readable: ${SSH_CONFIG_DIR}"
			exit 1
		fi
	fi

	return
}


get_syslog_config_options() {

	#
	# We check some syslog configuration options in this function.
	# They can only be set in the configuration file.
	#

	#
	# See if the ALLOW_SYSLOG_REMOTE_LOGGING option is specified
	# in the configuration file.
	#

	ALLOW_SYSLOG_REMOTE_LOGGING=`get_option 1 single ALLOW_SYSLOG_REMOTE_LOGGING` || exit 1

	if [ -n "${ALLOW_SYSLOG_REMOTE_LOGGING}" ]; then
		if [ "${ALLOW_SYSLOG_REMOTE_LOGGING}" != "0" -a "${ALLOW_SYSLOG_REMOTE_LOGGING}" != "1" ]; then
			echo "Invalid ALLOW_SYSLOG_REMOTE_LOGGING configuration option: not a valid number: ${ALLOW_SYSLOG_REMOTE_LOGGING}"
			exit 1
		fi
	else
		ALLOW_SYSLOG_REMOTE_LOGGING=0
	fi


	#
	# See if the pathname to the syslog configuration file has been set.
	#

	SYSLOG_CONFIG_FILE=`get_option 1 single SYSLOG_CONFIG_FILE` || exit 1

	if [ -n "`echo \"${SYSLOG_CONFIG_FILE}\" | grep -i '^none$'`" ]; then
		SYSLOG_CONFIG_FILE="NONE"
	fi


	return
}


get_auto_x_option() {

	#
	# For the second colour set we first see if the auto X detect option
	# has been set. If it is set, and X is in use, then the second colour
	# set is used. If X is not in use, or the auto detect option is not
	# set, then we only use the second colour set if the command-line
	# option is used or it is configured in the configuration file.
	#

	if [ $AUTO_X_OPT -eq 0 ]; then
		AUTO_X_DTCT=`get_option 1 single AUTO_X_DETECT` || exit 1

		if [ -n "${AUTO_X_DTCT}" ]; then
			if [ "${AUTO_X_DTCT}" != "0" -a "${AUTO_X_DTCT}" != "1" ]; then
				echo "Invalid AUTO_X_DETECT configuration option: not a valid number: ${AUTO_X_DTCT}"
				exit 1
			fi
		else
			AUTO_X_DTCT=0
		fi
	fi


	if [ $AUTO_X_DTCT -eq 1 -a -n "$DISPLAY" ]; then
		CLRSET2=1
	fi


	if [ $CLRSET2 -eq 0 ]; then
		CLRSET2=`get_option 1 single COLOR_SET2` || exit 1

		if [ -n "${CLRSET2}" ]; then
			if [ "${CLRSET2}" != "0" -a "${CLRSET2}" != "1" ]; then
				echo "Invalid COLOR_SET2 configuration option: not a valid number: ${CLRSET2}"
				exit 1
			fi
		else
			CLRSET2=0
		fi
	fi


	#
	# Finally, we get the option to see if whitelisted
	# results are to be shown as white rather than green.
	#

	WLIST_IS_WHITE=`get_option 1 single WHITELISTED_IS_WHITE` || exit 1

	if [ -n "${WLIST_IS_WHITE}" ]; then
		if [ "${WLIST_IS_WHITE}" != "0" -a "${WLIST_IS_WHITE}" != "1" ]; then
			echo "Invalid WHITELISTED_IS_WHITE configuration option: not a valid number: ${WLIST_IS_WHITE}"
			exit 1
		fi
	else
		WLIST_IS_WHITE=0
	fi

	return
}


get_locking_options() {

	#
	# This function gets the configuration options to see if locking
	# should be used when RKH is run. The mechanism for locking uses
	# a simple timer, and will display some basic messages while RKH
	# is trying to get the lock.
	#
	# All of these options can only be set in the configuration file.
	#

	RKHTMPVAR=`get_option 1 single USE_LOCKING` || exit 1

	if [ -n "${RKHTMPVAR}" ]; then
		if [ "${RKHTMPVAR}" = "0" -o "${RKHTMPVAR}" = "1" ]; then
			USE_LOCKING=$RKHTMPVAR
		else
			echo "Invalid USE_LOCKING configuration option: not a valid number: ${RKHTMPVAR}"
			exit 1
		fi
	else
		USE_LOCKING=0
	fi

	test $USE_LOCKING -eq 0 && return


	#
	# Now get the lock timeout value. This must be a positive integer.
	# The default value is 300 seconds (5 minutes).
	#

	RKHTMPVAR=`get_option 1 single LOCK_TIMEOUT` || exit 1

	if [ -n "`echo \"${RKHTMPVAR}\" | grep '^[0-9][0-9]*$'`" ]; then
		LOCK_TIMEOUT=$RKHTMPVAR
	elif [ -n "${RKHTMPVAR}" ]; then
		echo "Invalid LOCK_TIMEOUT configuration option: not a valid number: ${RKHTMPVAR}"
		exit 1
	else
		LOCK_TIMEOUT=300
	fi


	#
	# Finally, we get the option to see if any lock messages should
	# be shown or not. If the user has used the '--quiet' option,
	# then we cannot display the lock messages. Otherwise, these are
	# only shown on the screen, and not logged anywhere. The default
	# is to show the messages.
	#

	RKHTMPVAR=`get_option 1 single SHOW_LOCK_MSGS` || exit 1

	if [ -n "${RKHTMPVAR}" ]; then
		if [ "${RKHTMPVAR}" = "0" -o "${RKHTMPVAR}" = "1" ]; then
			SHOW_LOCK_MSGS=$RKHTMPVAR
		else
			echo "Invalid SHOW_LOCK_MSGS configuration option: not a valid number: ${RKHTMPVAR}"
			exit 1
		fi
	else
		SHOW_LOCK_MSGS=1
	fi

	test $QUIET -eq 1 && SHOW_LOCK_MSGS=0

	return
}


get_enable_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# all tests are enabled.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${ENABLE_TESTS}" ]; then
			ENABLE_TESTS=`echo "${ENABLE_TESTS}" | tr -d '"' | tr -d "'" | tr ',' ' ' | tr '	' ' ' | tr -s ' '`
			ENABLE_TESTS=`echo ${ENABLE_TESTS}`

			if [ -z "${ENABLE_TESTS}" ]; then
				echo "Invalid '--enable' option - no test names given."
				exit 1
			else
				ENABLE_TESTS=`echo "${ENABLE_TESTS}" | tr '[:upper:]' '[:lower:]'`
			fi


			#
			# We do a simple test here to see if just one test
			# name was given. If it was then we skip the key
			# press feature since it is most likely that the user
			# doesn't want that. We also check that only the
			# --enable option has been given, and that the test
			# name is not 'all'.
			#

			if [ "${ENABLE_TESTS}" != "all" -a -z "`echo \"${ENABLE_TESTS}\" | grep ' '`" ]; then
				SKIP_KEY_PRESS=1
			fi
		fi
	else
		ENABLE_TESTS=`get_option 2 single ENABLE_TESTS` || exit 1
		ENABLE_TESTS=`echo "${ENABLE_TESTS}" | tr '[:upper:]' '[:lower:]'`
	fi

	test -z "${ENABLE_TESTS}" && ENABLE_TESTS="all"


	#
	# We now need to look for group names in our list, and expand
	# them to the individual test names. This allows us to then
	# check against specific test names as well as group names.
	# We also need to check if a given test name is part of a group.
	# If it is, then we must add the group name.
	#

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			ENABLE_TESTS="all"
			break
		fi

		for RKHTMPVAR in ${GROUPED_TESTS}; do
			GROUP_NAME=`echo "${RKHTMPVAR}" | cut -d: -f1`

			if [ -n "`echo \"${RKHTMPVAR}\" | grep ':'`" ]; then
				GROUP_TESTS=`echo "${RKHTMPVAR}" | cut -d: -f2-`
			else
				GROUP_TESTS=""
			fi

			if [ "${TEST_NAME}" = "${GROUP_NAME}" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} `echo \"${GROUP_TESTS}\" | tr ':' ' '`"
				break
			elif [ -z "${GROUP_TESTS}" ]; then
				continue
			elif [ -n "`echo \":${GROUP_TESTS}:\" | grep \":${TEST_NAME}:\"`" ]; then
				ENABLE_TESTS="${ENABLE_TESTS} ${GROUP_NAME}"
			fi
		done
	done


	#
	# Check that the names we have been given are valid.
	#

	RKHTMPVAR=" all `echo ${KNOWN_TESTS}` "

	for TEST_NAME in ${ENABLE_TESTS}; do
		if [ "${TEST_NAME}" = "none" ]; then
			echo "'none' cannot be used in the enable test list."
			exit 1
		elif [ -z "`echo \"${RKHTMPVAR}\" | grep \" ${TEST_NAME} \"`" ]; then
			echo "Unknown enable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_disable_option() {

	#
	# If the option is not specified on the command-line, then
	# get it from the configuration file. We validate the test
	# names given against the list of known test names. By default
	# no tests are disabled.
	#
	# Note: disabled tests are always compared against the list
	# of enabled tests. Hence, if we used
	#      'rkhunter -c --enable system_commands --disable apps'
	# then only the system command tests are run. Any other test is
	# not run because it is not in the '--enable' list. As such
	# the '--disable' option in the example above is not necessary.
	#

	if [ $ENDIS_OPT -eq 1 ]; then
		if [ -n "${DISABLE_TESTS}" ]; then
			DISABLE_TESTS=`echo "${DISABLE_TESTS}" | tr -d '"' | tr -d "'" | tr ',' ' ' | tr '	' ' ' | tr -s ' '`
			DISABLE_TESTS=`echo ${DISABLE_TESTS}`

			if [ -z "${DISABLE_TESTS}" ]; then
				echo "Invalid '--disable' option - no test names given."
				exit 1
			fi
		fi
	else
		DISABLE_TESTS=`get_option 2 single DISABLE_TESTS` || exit 1
	fi

	if [ -z "${DISABLE_TESTS}" ]; then
		DISABLE_TESTS="none"
	else
		DISABLE_TESTS=`echo "${DISABLE_TESTS}" | tr '[:upper:]' '[:lower:]'`
	fi


	#
	# Note that we do not need to check the disabled test names
	# against the group names. If a disabled test name does not appear
	# in the enabled list then it will, by default, be ignored. If
	# a group name appears in the enabled and disabled lists, then
	# it will be disabled.
	#
	# Check that the names we have been given are valid.
	#

	RKHTMPVAR=" all none `echo ${KNOWN_TESTS}` "

	for TEST_NAME in ${DISABLE_TESTS}; do
		if [ "${TEST_NAME}" = "all" ]; then
			echo "'all' cannot be used in the disable test list."
			exit 1
		elif [ "${TEST_NAME}" = "none" ]; then
			DISABLE_TESTS="none"
			break
		elif [ -z "`echo \"${RKHTMPVAR}\" | grep \" ${TEST_NAME} \"`" ]; then
			echo "Unknown disable test name given: ${TEST_NAME}"
			exit 1
		fi
	done

	return
}


get_xinetd_option() {

	#
	# This function obtains the inetd and xinetd configuration
	# file pathnames from the config file. It also get the
	# whitelisted services.
	#

	FNAME=`get_option 1 single INETD_CONF_PATH` || exit 1

	if [ -n "${FNAME}" ]; then
		INETD_CONF_PATH="${FNAME}"

		if [ ! -f "${INETD_CONF_PATH}" ]; then
			echo "Invalid INETD_CONF_PATH configuration option - non-existent pathname specified: ${INETD_CONF_PATH}"
			exit 1
		fi
	fi

	INETDALLOWEDSVCS=`get_option 1 multi INETD_ALLOWED_SVC` || exit 1


	#
	# Now do the same for xinetd.
	#

	FNAME=`get_option 1 single XINETD_CONF_PATH` || exit 1

	if [ -n "${FNAME}" ]; then
		XINETD_CONF_PATH="${FNAME}"

		if [ ! -f "${XINETD_CONF_PATH}" ]; then
			echo "Invalid XINETD_CONF_PATH configuration option - non-existent pathname specified: ${XINETD_CONF_PATH}"
			exit 1
		fi
	fi

	XINETDALLOWEDSVCS=`get_option 1 multi XINETD_ALLOWED_SVC` || exit 1

	return
}


get_ports_option() {

	#
	# Get the option from the configuration file, and do some
	# checks that it is valid.
	#

	RKHTMPVAR=`get_option 2 single PORT_WHITELIST` || exit 1

	if [ -n "${RKHTMPVAR}" ]; then
		#
		# Loop through the list checking that it all looks okay.
		#

		FOUND=0

		if [ -n "`echo \"${RKHTMPVAR}\" | grep '\*'`" ]; then
			PORT_WHITELIST_ALL_TRUSTED=1
			RKHTMPVAR=`echo "${RKHTMPVAR}" | tr -d '*'`
		fi

		for RKHTMPVAR2 in ${RKHTMPVAR}; do
			if [ -n "`echo \"${RKHTMPVAR2}\" | grep '^/'`" ]; then
				if [ ! -f "${RKHTMPVAR2}" ]; then
					FOUND=1
					echo "Non-existent pathname specified in PORT_WHITELIST configuration option: ${RKHTMPVAR2}"
				else
					PORT_WHITELIST_PATH="${PORT_WHITELIST_PATH} ${RKHTMPVAR2}"
				fi
			elif [ -n "`echo \"${RKHTMPVAR2}\" | egrep -i '^(TCP|UDP):[1-9][0-9]*$'`" ]; then
				PORT=`echo ${RKHTMPVAR2} | cut -d: -f2`

				if [ $PORT -gt 65535 ]; then
					FOUND=1
					echo "Invalid port specified in PORT_WHITELIST configuration option: ${RKHTMPVAR2}"
				else
					PORT_WHITELIST="${PORT_WHITELIST} ${RKHTMPVAR2}"
				fi
			else
				FOUND=1
				echo "Invalid entry specified in PORT_WHITELIST configuration option: ${RKHTMPVAR2}"
			fi
		done

		test $FOUND -eq 1 && exit 1

		PORT_WHITELIST=`echo " ${PORT_WHITELIST} " | tr '[:lower:]' '[:upper:]'`
		PORT_WHITELIST_PATH=" ${PORT_WHITELIST_PATH} "
	fi

	return
}


get_shadow_file_option() {

	#
	# Get the option from the configuration file. We also cater
	# for cases such as BSD systems and users of TCB shadow files.
	# If the shadow file itself does not exist, then we look in
	# the password file to see if it contains the passwords.
	#

	SHADOW_FILE=`get_option 1 single PASSWORD_FILE` || exit 1

	if [ -n "${SHADOW_FILE}" ]; then
		if [ -s "${RKHROOTDIR}${SHADOW_FILE}" ]; then
			SHADOW_FILE="${RKHROOTDIR}${SHADOW_FILE}"
		else
			SHADOW_FILE=""
		fi
	elif [ -s "${RKHROOTDIR}/etc/shadow" ]; then
		SHADOW_FILE="${RKHROOTDIR}/etc/shadow"
	elif [ $BSDOS -eq 1 -a -s "${RKHROOTDIR}/etc/master.passwd" ]; then
		SHADOW_FILE="${RKHROOTDIR}/etc/master.passwd"
	elif [ -f "${RKHROOTDIR}/etc/tcb/root/shadow" ]; then
		HAVE_TCB_SHADOW=1
	elif [ -s "${RKHROOTDIR}/etc/passwd" ]; then
		#
		# If the passwords are stored in the passwd file, then
		# it should contain at least 3 non-colon characters in the
		# second field. Checking for 3 characters allows for normal
		# shadow entries such as 'x', '!!' or '*'. It is assumed
		# that at least one account will have a password.
		#

		if [ -n "`grep '^[^:]*:[^:][^:][^:]' ${RKHROOTDIR}/etc/passwd`" ]; then
			SHADOW_FILE="${RKHROOTDIR}/etc/passwd"
		fi
	fi

	return
}


test_epoch_cmd() {

	#
	# This function simply checks if the supplied command
	# can process epoch second times. We do this by using
	# the '%s' formatting option, and the 'seconds ago'
	# time format. If the command understands both of these
	# then we can use it for the epoch date.
	#

	RKHTMPVAR=$1

	if [ -n "`${RKHTMPVAR} --date '5 seconds ago' '+%s' 2>/dev/null | grep '^[0-9][0-9]*$'`" ]; then
		EPOCH_DATE_CMD=${RKHTMPVAR}
	fi

	return
}


get_epoch_date_cmd_option() {

	#
	# Get the option from the configuration file, or work out
	# if the 'date' command is suitable.
	#

	EPOCH_DATE_CMD=`get_option 1 single EPOCH_DATE_CMD` || exit 1

	#
	# Check the type of config file option we have. They user may have
	# specified a command to use or 'NONE', in which case we return.
	# If they specified 'PERL' then check we have a 'perl' command,
	# and then return.
	#

	if [ -n "`echo \"${EPOCH_DATE_CMD}\" | grep -i '^perl$'`" ]; then
		EPOCH_DATE_CMD=""
		test -z "${PERL_CMD}" && EPOCH_DATE_CMD="NONE"
		return
	elif [ -n "`echo \"${EPOCH_DATE_CMD}\" | grep -i '^none$'`" ]; then
		EPOCH_DATE_CMD="NONE"
		return
	elif [ -n "${EPOCH_DATE_CMD}" ]; then
		RKHTMPVAR=`echo "${EPOCH_DATE_CMD}" | cut -d' ' -f1`
		test -x "${RKHTMPVAR}" || EPOCH_DATE_CMD="NONE"
		return
	fi


	#
	# Now we test if the 'date' command supports processing epoch seconds.
	#

	test_epoch_cmd "date"

	test -n "${EPOCH_DATE_CMD}" && return


	#
	# For SunOS systems we need to check
	# some other 'date' commands.
	#

	if [ $SUNOS -eq 1 ]; then
		for RKHTMPVAR2 in `find_cmd gdate` /opt/sfw/bin/date; do
			test_epoch_cmd "${RKHTMPVAR2}"
			test -n "${EPOCH_DATE_CMD}" && break
		done
	fi

	return
}


get_if_prelinked() {

	#
	# If the system appears to be using prelinking, but no
	# prelink command can be found, then we simply skip the
	# file properties hash check.
	#

	LIBSAFE_TEST1=""
	LIBSAFE_TEST2=""

	if [ -f "${RKHROOTDIR}/etc/prelink.cache" ]; then
		PRELINK_CMD=`find_cmd prelink`

		#
		# Test (twice) for existance of Libsafe since this seems to
		# riddle prelink test results with "dependency cycle" errors.
		# Don't test for existance of /lib/libsafe since it may be
		# installed elsewhere.
		# If Libsafe is found *and* this is a prelink system, we'll
		# skip the prelink test.
		#

		if [ -f "${RKHROOTDIR}/etc/ld.so.preload" ]; then
			LIBSAFE_TEST1=`grep libsafe ${RKHROOTDIR}/etc/ld.so.preload 2>&1`
		fi

		if [ -n "${LDD_CMD}" -a -f "${RKHROOTDIR}/lib/libdl.so.?" ]; then
			LIBSAFE_TEST2=`${LDD_CMD} ${RKHROOTDIR}/lib/libdl.so.? | grep libsafe 2>&1`
		fi

		if [ -z "${PRELINK_CMD}" ]; then
			SKIP_HASH_MSG=1
		elif [ -z "${LIBSAFE_TEST1}" -a -z "${LIBSAFE_TEST2}" ]; then
			PRELINKED=1

			#
			# Only use 'runcon' if SELinux is enabled.
			#

			SESTATUS_CMD=`find_cmd sestatus`

			if [ -n "${SESTATUS_CMD}" ]; then
				if [ -n "`${SESTATUS_CMD} 2>/dev/null | grep ' status: *enabled$'`" ]; then
					SELINUX_ENABLED=1
					RUNCON_CMD=`find_cmd runcon`
					test -n "${RUNCON_CMD}" && USE_RUNCON=1
				fi
			fi
		elif [ -n "${LIBSAFE_TEST1}" -a -n "${LIBSAFE_TEST2}" ]; then
			SKIP_HASH_MSG=3
		fi
	fi

	return
}


get_md5_hash_function() {

	#
	# This is a short function to try and locate
	# an MD5 hash function command.
	#

	if [ $PRELINKED -eq 1 ]; then
		if [ $USE_RUNCON -eq 1 ]; then
			echo "${RUNCON_CMD} -u root -- ${PRELINK_CMD} --verify --md5"
		else
			echo "${PRELINK_CMD} --verify --md5"
		fi
	else
		HFUNC=`find_cmd md5sum`

		test -z "${HFUNC}" && HFUNC=`find_cmd md5`

		if [ -z "${HFUNC}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::MD5 2>&1 | grep 'Digest::MD5 installed'`

			test -n "${MOD_INSTALLED}" && echo "${PERL_CMD} ${SCRIPT_PATH}/filehashmd5.pl"
		else
			echo "${HFUNC}"
		fi
	fi

	return
}


get_hash_function() {

	#
	# Get the option from the configuration file, and do a simple
	# check on whether it is empty or a space.
	#

	if [ $HASH_OPT -eq 1 ]; then
		HASH_FUNC=`echo "${HASH_FUNC}" | tr -d '"' | tr -d "'" | tr '	' ' ' | tr -s ' '`
		HASH_FUNC=`echo ${HASH_FUNC}`

		if [ -z "${HASH_FUNC}" ]; then
			echo "Invalid '--hash' option: no hash function given."
			exit 1
		fi
	else
		HASH_FUNC=`get_option 2 single HASH_FUNC` || exit 1
	fi

	if [ -n "`echo \"${HASH_FUNC}\" | egrep -i '^(MD5|SHA1|SHA224|SHA256|SHA384|SHA512|NONE)$'`" ]; then
		HASH_FUNC=`echo "${HASH_FUNC}" | tr '[:lower:]' '[:upper:]'`
	fi


	#
	# At this point we have either been given a hash function command,
	# one of the reserved words 'MD5', 'NONE', or one of the SHA functions,
	# or nothing. For the SHA and MD5 reserved words we must find the
	# SHA or MD5 command or use the supplied perl scripts.
	#

	SHA_SIZE=0

	test -z "${HASH_FUNC}" && HASH_FUNC="SHA1"

	case "${HASH_FUNC}" in
	SHA1)	SHA_SIZE=1
		;;
	SHA224)	SHA_SIZE=224
		;;
	SHA256)	SHA_SIZE=256
		;;
	SHA384)	SHA_SIZE=384
		;;
	SHA512)	SHA_SIZE=512
		;;
	esac

	if [ "${HASH_FUNC}" = "SHA1" -a  $PRELINKED -eq 1 ]; then
		PRELINK_HASH="SHA1"

		if [ $USE_RUNCON -eq 1 ]; then
			HASH_FUNC="${RUNCON_CMD} -u root -- ${PRELINK_CMD} --verify --sha"
		else
			HASH_FUNC="${PRELINK_CMD} --verify --sha"
		fi
	elif [ $SHA_SIZE -gt 0 ]; then
		HF=`find_cmd sha${SHA_SIZE}sum`

		test -z "${HF}" && HF=`find_cmd sha${SHA_SIZE}`

		if [ -z "${HF}" -a -n "${PERL_CMD}" ]; then
			MOD_INSTALLED=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Digest::SHA Digest::SHA1 Digest::SHA256 2>&1`

			if [ -n "`echo \"${MOD_INSTALLED}\" | grep 'Digest::SHA installed'`" ]; then
				HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha.pl SHA512 $SHA_SIZE"
			elif [ $SHA_SIZE -eq 256 -o $SHA_SIZE -eq 384 -o $SHA_SIZE -eq 512 ]; then
				if [ -n "`echo \"${MOD_INSTALLED}\" | grep 'Digest::SHA256 installed'`" ]; then
					HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha.pl SHA256 $SHA_SIZE"
				else
					HASH_FUNC=""
				fi
			elif [ $SHA_SIZE -eq 1 ]; then
				if [ -n "`echo \"${MOD_INSTALLED}\" | grep 'Digest::SHA1 installed'`" ]; then
					HASH_FUNC="${PERL_CMD} ${SCRIPT_PATH}/filehashsha.pl SHA1 $SHA_SIZE"
				else
					HASH_FUNC=""
				fi
			else
				HASH_FUNC=""
			fi
		else
			HASH_FUNC=$HF
		fi
	fi


	#
	# If we still have no hash function, then look for an MD5 command.
	#

	if [ \( -z "${HASH_FUNC}" -a $SHA_SIZE -eq 1 \) -o "${HASH_FUNC}" = "MD5" ]; then
		HASH_FUNC=`get_md5_hash_function`

		if [ $PRELINKED -eq 1 ]; then
			PRELINK_HASH="MD5"
		elif [ -z "`echo \"${HASH_FUNC}\" | grep '/filehashmd5\.pl$'`" ]; then
			MD5_CMD="${HASH_FUNC}"
		fi
	fi


	#
	# A final check that the command is actually executable.
	# This will ensure that the SHA/MD5 perl scripts have been
	# installed correctly, should they be needed.
	#

	if [ "${HASH_FUNC}" = "NONE" ]; then
		:
	elif [ -n "${HASH_FUNC}" ]; then
		HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f1`
		HF=`find_cmd ${HCMD}`

		if [ -n "${HF}" ]; then
			#
			# We rebuild the command to use the full pathname.
			#

			HCMD=`echo "${HASH_FUNC}" | cut -d' ' -f2-`

			if [ -z "${HCMD}" -o "${HCMD}" = "${HASH_FUNC}" ]; then
				HASH_FUNC=$HF
			else
				HASH_FUNC="${HF} ${HCMD}"
			fi
		elif [ $HASH_OPT -eq 1 ]; then
			echo "Invalid '--hash' option: command '${HCMD}' is non-existent or not executable."
			exit 1
		else
			echo "Invalid HASH_FUNC configuration option: command '${HCMD}' is non-existent or not executable."
			exit 1
		fi
	elif [ $HASH_OPT -eq 1 ]; then
		echo "Invalid '--hash' option: no usable hash command or perl modules could be found."
		exit 1
	elif [ $SHA_SIZE -gt 1 ]; then
		echo "Invalid HASH_FUNC configuration option: no usable hash command or perl modules for SHA${SHA_SIZE} could be found."
		exit 1
	else
		echo "Invalid HASH_FUNC configuration option: no usable hash command or perl modules for SHA1 or MD5 could be found."
		exit 1
	fi


	#
	# Now we get the hash field index. We will assume a field value
	# of one, but this value must be configurable since we allow
	# the user to specify the hash function to use.
	#

	RKHTMPVAR=`get_option 1 single HASH_FLD_IDX` || exit 1

	if [ -n "${RKHTMPVAR}" ]; then
		if [ -z "`echo \"${RKHTMPVAR}\" | grep '^[1-9][0-9]*$'`" ]; then
			echo "Invalid HASH_FLD_IDX configuration option: not a valid number: ${RKHTMPVAR}"
			exit 1
		else
			HASH_FLD_IDX=${RKHTMPVAR}
		fi
	fi


	#
	# Next we get the package manager to use for the file
	# properties hash check and update. If a file is not owned
	# as part of a package, the hash function defined above
	# will be used instead.
	#

	if [ -n "${PKGMGR}" ]; then
		PKGMGR=`echo "${PKGMGR}" | tr -d '" 	' | tr -d "'"`

		if [ -z "${PKGMGR}" ]; then
			echo "Invalid '--pkgmgr' option: no package manager given."
			exit 1
		fi
	else
		PKGMGR=`get_option 1 single PKGMGR` || exit 1
	fi

	PKGMGR=`echo "${PKGMGR}" | tr '[:lower:]' '[:upper:]'`

	test "${PKGMGR}" = "NONE" && PKGMGR=""


	#
	# Now check that the package manager we have been given is valid.
	#

	case "${PKGMGR}" in
	"")
		;;
	RPM)
		RPM_CMD=`find_cmd rpm`

		if [ -z "${RPM_CMD}" ]; then
			echo "Unable to find 'rpm' command for package manager 'RPM'."
			exit 1
		fi
		;;
	DPKG)
		DPKG_CMD=`find_cmd dpkg-query`

		test -z "${DPKG_CMD}" && DPKG_CMD=`find_cmd dpkg`

		if [ -z "${DPKG_CMD}" ]; then
			echo "Unable to find 'dpkg-query' or 'dpkg' commands for package manager 'DPKG'."
			exit 1
		fi

		if [ ! -d "/var/lib/dpkg/info" ]; then
			echo "Unable to find package database directory (/var/lib/dpkg/info) for package manager 'DPKG'."
			exit 1
		fi

		if [ $CHECK -eq 1 ]; then
			PKGMGR_MD5_HASH=`get_md5_hash_function`

			if [ -z "${PKGMGR_MD5_HASH}" ]; then
				echo "Unable to find an MD5 hash function command to assist package manager 'DPKG'."
				exit 1
			fi
		fi
		;;
	BSD)
		PKG_CMD=`find_cmd pkg_info`

		if [ -z "${PKG_CMD}" ]; then
			echo "Unable to find 'pkg_info' command for package manager 'BSD'."
			exit 1
		fi

		if [ ! -d "/var/db/pkg" ]; then
			echo "Unable to find package database directory (/var/db/pkg) for package manager 'BSD'."
			exit 1
		fi

		if [ $CHECK -eq 1 ]; then
			PKGMGR_MD5_HASH=`get_md5_hash_function`

			if [ -z "${PKGMGR_MD5_HASH}" ]; then
				echo "Unable to find an MD5 hash function command to assist package manager 'BSD'."
				exit 1
			fi
		fi
		;;
	*)
		echo "Invalid package manager given: ${PKGMGR}"
		exit 1
		;;
	esac


	#
	# Finally we see if any files are to be exempt from the
	# package manager verification. These will go through the
	# usual commands to get the file info, so they will still
	# be tested.
	#

	ERRCODE=0

	PKGMGRNOVRFY=`get_option 2 multi PKGMGR_NO_VRFY` || exit 1

	for RKHTMPVAR in ${PKGMGRNOVRFY}; do
		if [ ! -f "${RKHTMPVAR}" ]; then
			echo "Invalid PKGMGR_NO_VRFY configuration option: file does not exist: ${RKHTMPVAR}"
			ERRCODE=1
		fi
	done

	if [ $ERRCODE -eq 0 ]; then
		test -n "${PKGMGRNOVRFY}" && PKGMGRNOVRFY=" ${PKGMGRNOVRFY} "
	else
		exit $ERRCODE
	fi

	return
}


get_scan_mode_dev_option() {

	#
	# SCAN_MODE_DEV governs how we scan /dev for suspicious files.
	# The two allowed options are "commented out" or LAZY.
	# If commented out, the default, we do a thorough scan which
	# will increase the runtime of rkhunter.
	#

	#
	# See if the option is specified in the configuration file.
	#

	SCAN_MODE_DEV=`get_option 1 single SCAN_MODE_DEV` || exit 1

	if [ -n "${SCAN_MODE_DEV}" ]; then
		SCAN_MODE_DEV=`echo "${SCAN_MODE_DEV}" | tr '[:lower:]' '[:upper:]'`

		case "${SCAN_MODE_DEV}" in
		THOROUGH|LAZY)
			;;
		*)	# Don't make this fatal.
			echo "Invalid SCAN_MODE_DEV configuration option: ${SCAN_MODE_DEV}"
			echo "Defaulting to THOROUGH mode."

			SCAN_MODE_DEV="THOROUGH"
			;;
		esac
	else
		SCAN_MODE_DEV="THOROUGH"
	fi

	return
}


get_startup_paths_option() {

	#
	# This function gets the system startup files and directories
	# from the configuration file. There are no defaults.
	#
	# For backward compatability we still check for the old options
	# of LOCAL_RC_PATH and SYSTEM_RC_DIR.
	#

	STARTUP_PATHS=`get_option 2 single STARTUP_PATHS` || exit 1

	RKHTMPVAR=`get_option 2 single LOCAL_RC_PATH` || exit 1
	test -n "${RKHTMPVAR}" && STARTUP_PATHS="${STARTUP_PATHS} ${RKHTMPVAR}"

	RKHTMPVAR=`get_option 1 single SYSTEM_RC_DIR` || exit 1
	test -n "${RKHTMPVAR}" && STARTUP_PATHS="${STARTUP_PATHS} ${RKHTMPVAR}"

	if [ -n "${STARTUP_PATHS}" ]; then
		#
		# First see if we have any startup files or not.
		#

		if [ -n "`echo \"${STARTUP_PATHS}\" | grep -i '^none$'`" ]; then
			STARTUP_PATHS="NONE"
		else
			#
			# Check that the given files and directories are usable.
			#

			for FNAME in ${STARTUP_PATHS}; do
				test -f "${FNAME}" && RKHTMPVAR="file" || RKHTMPVAR="directory"

				if [ ! -e "${FNAME}" ]; then
					echo "System startup file does not exist: ${FNAME}"
					exit 1
				elif [ -h "${FNAME}" ]; then
					echo "System startup ${RKHTMPVAR} is a symbolic link: ${FNAME}"
					exit 1
				elif [ ! -r "${FNAME}" ]; then
					echo "System startup ${RKHTMPVAR} is not readable: ${FNAME}"
					exit 1
				elif [ ! -s "${FNAME}" ]; then
					echo "System startup file is empty: ${FNAME}"
					exit 1
				fi
			done
		fi
	fi

	return
}


get_rtkt_whitelist_options() {

	#
	# This function gets any whitelisted rootkit files
	# and directories from the configuration file.
	# There are no defaults.
	#

	RTKT_FILE_WHITELIST=`get_option 2 single RTKT_FILE_WHITELIST` || exit 1

	if [ -n "${RTKT_FILE_WHITELIST}" ]; then
		#
		# Check that the given files are usable.
		#

		FOUND=0

		for RKHTMPVAR2 in ${RTKT_FILE_WHITELIST}; do
			RKHTMPVAR=`echo "${RKHTMPVAR2}" | tr '%' ' '`

			if [ ! -f "${RKHTMPVAR}" ]; then
				FOUND=1
				echo "Whitelisted rootkit file does not exist: ${RKHTMPVAR2}"
			fi
		done

		test $FOUND -eq 1 && exit 1

		RTKT_FILE_WHITELIST=" ${RTKT_FILE_WHITELIST} "
	fi


	RTKT_DIR_WHITELIST=`get_option 2 single RTKT_DIR_WHITELIST` || exit 1

	if [ -n "${RTKT_DIR_WHITELIST}" ]; then
		#
		# Check that the given directories are usable.
		#

		FOUND=0

		for RKHTMPVAR2 in ${RTKT_DIR_WHITELIST}; do
			RKHTMPVAR=`echo "${RKHTMPVAR2}" | tr '%' ' '`

			if [ ! -d "${RKHTMPVAR}" ]; then
				FOUND=1
				echo "Whitelisted rootkit directory does not exist: ${RKHTMPVAR2}"
			fi
		done

		test $FOUND -eq 1 && exit 1

		RTKT_DIR_WHITELIST=" ${RTKT_DIR_WHITELIST} "
	fi

	return
}


get_shared_lib_whitelist_option() {

	#
	# This function gets any whitelisted shared library files
	# from the configuration file. There are no defaults.
	#

	SHARED_LIB_WHITELIST=`get_option 2 single SHARED_LIB_WHITELIST` || exit 1

	if [ -n "${SHARED_LIB_WHITELIST}" ]; then
		SHARED_LIB_WHITELIST=" ${SHARED_LIB_WHITELIST} "
	fi

	return
}


get_mirror_options() {

	#
	# This function gets the mirror file options.
	#

	#
	# First we see if the mirrors.dat file
	# should be rotated when it is used.
	#

	ROTATE_MIRRORS=`get_option 1 single ROTATE_MIRRORS` || exit 1

	if [ -n "${ROTATE_MIRRORS}" ]; then
		if [ "${ROTATE_MIRRORS}" != "0" -a "${ROTATE_MIRRORS}" != "1" ]; then
			echo "Invalid ROTATE_MIRRORS configuration option: not a valid number: ${ROTATE_MIRRORS}"
			exit 1
		fi
	else
		ROTATE_MIRRORS=1
	fi

	#
	# Now check that the mirror file is writable if necessary.
	#

	if [ $VERSIONCHECK -eq 1 -a $ROTATE_MIRRORS -eq 1 ]; then
		if [ ! -w "${DB_PATH}/mirrors.dat" ]; then
			echo "Mirror file is not writable: ${DB_PATH}/mirrors.dat"
			exit 1
		fi
	fi


	#
	# Next we see if the mirror file is to be updated when
	# we use the '--update' option.
	#

	if [ $UPDATE -eq 1 ]; then
		UPDATE_MIRRORS=`get_option 1 single UPDATE_MIRRORS` || exit 1

		if [ -n "${UPDATE_MIRRORS}" ]; then
			if [ "${UPDATE_MIRRORS}" != "0" -a "${UPDATE_MIRRORS}" != "1" ]; then
				echo "Invalid UPDATE_MIRRORS configuration option: not a valid number: ${UPDATE_MIRRORS}"
				exit 1
			fi
		else
			UPDATE_MIRRORS=1
		fi
	fi


	#
	# Finally, we see which mirrors are to be used.
	#

	MIRRORS_MODE=`get_option 1 single MIRRORS_MODE` || exit 1

	if [ -n "${MIRRORS_MODE}" ]; then
		if [ "${MIRRORS_MODE}" != "0" -a "${MIRRORS_MODE}" != "1" -a "${MIRRORS_MODE}" != "2" ]; then
			echo "Invalid MIRRORS_MODE configuration option: not a valid number: ${MIRRORS_MODE}"
			exit 1
		fi
	else
		MIRRORS_MODE=0
	fi

	return
}


get_os_info_options() {

	#
	# This function gets configuration options relating
	# to obtaining information about the O/S.
	#
	# The first part gets the 'release' file pathname
	# from the configuration file. There is no default.
	#

	OS_VERSION_FILE=`get_option 1 single OS_VERSION_FILE` || exit 1

	if [ -n "${OS_VERSION_FILE}" ]; then
		#
		# Check that the given file is usable.
		#

		if [ ! -f "${RKHROOTDIR}${OS_VERSION_FILE}" ]; then
			echo "O/S release file does not exist: ${RKHROOTDIR}${OS_VERSION_FILE}"
			exit 1
		elif [ -h "${RKHROOTDIR}${OS_VERSION_FILE}" ]; then
			echo "O/S release file is a symbolic link: ${RKHROOTDIR}${OS_VERSION_FILE}"
			exit 1
		elif [ ! -r "${RKHROOTDIR}${OS_VERSION_FILE}" ]; then
			echo "O/S release file is not readable: ${RKHROOTDIR}${OS_VERSION_FILE}"
			exit 1
		elif [ ! -s "${RKHROOTDIR}${OS_VERSION_FILE}" ]; then
			echo "O/S release file is empty: ${RKHROOTDIR}${OS_VERSION_FILE}"
			exit 1
		fi
	fi


	#
	# Next we get the option as to whether we should
	# issue a warning when the O/S info changes or not.
	#

	WARN_ON_OS_CHANGE=`get_option 1 single WARN_ON_OS_CHANGE` || exit 1

	if [ -n "${WARN_ON_OS_CHANGE}" ]; then
		if [ "${WARN_ON_OS_CHANGE}" != "0" -a "${WARN_ON_OS_CHANGE}" != "1" ]; then
			echo "Invalid WARN_ON_OS_CHANGE configuration option: not a valid number: ${WARN_ON_OS_CHANGE}"
			exit 1
		fi
	else
		WARN_ON_OS_CHANGE=1
	fi


	#
	# Now get the option as to whether we should automatically run
	# a properties update ('--propupd') if the O/S has changed.
	#

	UPDT_ON_OS_CHANGE=`get_option 1 single UPDT_ON_OS_CHANGE` || exit 1

	if [ -n "${UPDT_ON_OS_CHANGE}" ]; then
		if [ "${UPDT_ON_OS_CHANGE}" != "0" -a "${UPDT_ON_OS_CHANGE}" != "1" ]; then
			echo "Invalid UPDT_ON_OS_CHANGE configuration option: not a valid number: ${UPDT_ON_OS_CHANGE}"
			exit 1
		fi
	else
		UPDT_ON_OS_CHANGE=1
	fi

	return
}


get_user_fileprop_list() {

	#
	# This function gets any user supplied files and directories
	# for the file properties check and the properties file update.
	# It stores the different types of files and directories
	# found in different variables. Only basic syntax checking is
	# done here, further checking will be done later on.
	#
	# The configuration option can have three basic values:
	#
	#    1) A simple file (command) name - for example, 'top'
	#    2) A directory - for example, '/usr/local/sbin'
	#    3) A full file pathname - for example, '/usr/local/sbin/backup'
	#
	# The first two are simply added to the internal lists of files
	# and directories. These are then used to build the file properties
	# file list. The third type is added directly to the end of the file.
	#
	# The second and third types may be wildcarded. They may also be
	# excluded from the checks by preceding them with a '!'. Only
	# files and directories matching user added ones can be excluded.
	# This prevents users from excluding anything in the internal list.
	# For example: USER_FILEPROP_FILES_DIRS="/opt/b* !/opt/backup"
	#

	LEAVE=0

	RKHTMPVAR=`get_option 2 multi USER_FILEPROP_FILES_DIRS` || exit 1

	#
	# We 'echo' the variable so that any wildcards get expanded.
	#

	RKHTMPVAR=`echo ${RKHTMPVAR}`


	#
	# Now we loop through the entries and check them again. They
	# are then added to the relevant variable used to build the
	# file properties file list.
	#

	for FNAME in ${RKHTMPVAR}; do
		#
		# First check for anything which contains just dots,
		# forward-slashes, asterisks etc. This means that
		# '/' cannot be set.
		#

		if [ -n "`echo \"${FNAME}\" | grep '^[./*?!]*$'`" ]; then
			LEAVE=1
			echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid pathname: ${FNAME}"
			continue
		fi


		#
		# Next we check for any files or directories to be excluded.
		#

		if [ -n "`echo \"${FNAME}\" | grep '^!'`" ]; then
			RKHTMPVAR2=`echo ${FNAME} | cut -c2-`
			RKHTMPVAR2=`echo ${RKHTMPVAR2}`

			test -z "${USER_EXCLUDE_PROP}" && USER_EXCLUDE_PROP="${RKHTMPVAR2}" || USER_EXCLUDE_PROP="${USER_EXCLUDE_PROP} ${RKHTMPVAR2}"
			continue
		fi


		#
		# Now we check to see if it is a simple file name.
		#

		if [ -z "`echo \"${FNAME}\" | grep '^/'`" ]; then
			# Next check to see if it is a simple file name.
			# Check that it is not a pathname like 'abc/def'.
			if [ -n "`echo \"${FNAME}\" | grep '[;&!:/]'`" ]; then
				LEAVE=1
				echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid pathname: ${FNAME}"
			else
				# Check that it hasn't already been set.
				# If it has, then we just ignore it.

				RKHTMPVAR2=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

				if [ -z "`echo \" ${USER_SIMPLE_FILE_LIST} \" | grep \" ${RKHTMPVAR2} \"`" ]; then
					test -z "${USER_SIMPLE_FILE_LIST}" && USER_SIMPLE_FILE_LIST="${FNAME}" || USER_SIMPLE_FILE_LIST="${USER_SIMPLE_FILE_LIST} ${FNAME}"
				fi
			fi
		else
			# It's an absolute pathname. This could be a file or a directory.

			RKHTMPVAR2=""

			if [ -f "${FNAME}" ]; then
				# Check that it hasn't already been set.
				# If it has, then we just ignore it.

				RKHTMPVAR2=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

				test -n "`echo \"${USER_FILE_LIST}\" | grep \"^${RKHTMPVAR2}$\"`" && continue

				if [ -h "${FNAME}" -a $HAVE_READLINK -eq 1 ]; then
					RKHTMPVAR2=`${READLINK_CMD} -f ${FNAME}`

					if [ -n "${RKHTMPVAR2}" ]; then
						RKHTMPVAR3=`echo "${RKHTMPVAR2}" | sed -e 's/\([.[]\)/\\\\\1/g'`

						if [ -z "`echo \"${USER_FILE_LIST}\" | grep \"^${RKHTMPVAR3}$\"`" ]; then
							FNAME="${FNAME}
${RKHTMPVAR2}"
						fi
					fi
				fi

				#
				# Anything with a colon (':') in it is not allowed.
				#

				if [ -n "`echo \"${FNAME}\" | grep ':'`" ]; then
					LEAVE=1
					echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid pathname: ${FNAME}"
				else
					test -z "${USER_FILE_LIST}" && USER_FILE_LIST="${FNAME}" || USER_FILE_LIST="${USER_FILE_LIST}
${FNAME}"
				fi
			elif [ -d "${FNAME}" ]; then
				if [ -h "${FNAME}" -a $HAVE_READLINK -eq 1 ]; then
					RKHTMPVAR2=`${READLINK_CMD} -f ${FNAME}`

					if [ -z "${RKHTMPVAR2}" ]; then
						continue
					elif [ "${RKHTMPVAR2}" = "/" ]; then
						LEAVE=1
						echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid pathname: ${FNAME}"
						continue
					fi

					FNAME="${RKHTMPVAR2}"
				fi

				#
				# Check that the directory name does not contain a colon. We then check
				# that it hasn't already been set. If it has, then we just ignore it.
				#

				if [ -n "`echo \"${FNAME}\" | grep ':'`" ]; then
					LEAVE=1
					echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid pathname: ${FNAME}"
				else
					RKHTMPVAR2=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

					if [ -z "`echo \" ${USER_DIR_LIST} \" | grep \" ${RKHTMPVAR2} \"`" ]; then
						test -z "${USER_DIR_LIST}" && USER_DIR_LIST="${FNAME}" || USER_DIR_LIST="${USER_DIR_LIST} ${FNAME}"
					fi
				fi
			elif [ -h "${FNAME}" ]; then
				LEAVE=1
				RKHTMPVAR2=`${READLINK_CMD} -f ${FNAME}`
				echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Invalid link: ${FNAME} -> ${RKHTMPVAR2}"
			elif [ -e "${FNAME}" ]; then
				LEAVE=1
				echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Not a file or directory: ${FNAME}"
			else
				LEAVE=1
				echo "Invalid USER_FILEPROP_FILES_DIRS configuration option: Non-existent file or directory: ${FNAME}"
			fi
		fi
	done

	test $LEAVE -eq 1 && exit 1

	return
}


get_configfile_options() {

	#
	# We call separate functions to process each option. The option
	# is checked first to see if it has been given on the command-line,
	# and, if not, then if it is specified in the configuration file.
	# Note that some of these functions are in a specific order. If you
	# change them around, then make sure the functions still work
	# correctly.
	#

	get_installdir_option

	get_rootdir_option

	get_bindir_option

	get_logfile_option

	get_tmpdir_option

	get_dbdir_option

	get_language_option

	get_scriptdir_option

	get_auto_x_option

	get_locking_options


	#
	# Now that we have processed BINDIR, we will recheck the
	# required commands.
	#
	# Before proceeding too far we also check that we have certain
	# commands available. Typically these are commands which might
	# not have been installed as part of the core system, but are
	# used by RKH. These commands are not 'required' though.
	#

	check_required_commands "${BINPATHS}"

	check_commands


	#
	# Some options are only required when checking the system.
	#

	if [ $CHECK -eq 1 -o $PROP_UPDATE -eq 1 ]; then
		#
		# See if we are only to perform specific tests.
		#

		get_enable_option
		get_disable_option
	fi

	if [ $CHECK -eq 1 ]; then
		test $NOMOW -eq 0 && get_mailonwarn_option

		get_ssh_options

		get_syslog_config_options

		get_syslog_option

		get_scan_mode_dev_option

		get_startup_paths_option

		get_rtkt_whitelist_options

		check_test hashes && HASH_CHECK_ENABLED=1
		check_test attributes && HASH_CHECK_ENABLED=1

		check_test trojans && get_xinetd_option

		check_test ports && get_ports_option

		check_test group_accounts && get_shadow_file_option

		check_test shared_libs && get_shared_lib_whitelist_option

		get_epoch_date_cmd_option
	fi


	#
	# We only need the hash function option if we are going
	# to be checking the system or updating the file
	# properties database.
	#

	if `check_test properties` || test $PROP_UPDATE -eq 1; then
		#
		# For the file properties check we need to find out if
		# we are a prelinked system, and if so, then find out
		# which hash function to use. Secondly, we need to find
		# the 'stat' command. Finally, we need to see if the
		# user has specified any files or directories for the
		# file properties check.
		#

		get_if_prelinked

		test $SKIP_HASH_MSG -eq 0 && get_hash_function

		get_os_info_options

		get_user_fileprop_list
	fi

	#
	# If we are doing a file properties update, then we need to
	# see if we should be ignoring prelink errors for any files.
	#

	if [ $PROP_UPDATE -eq 1 ]; then
		RKHTMPVAR=`get_option 2 single IGNORE_PRELINK_DEP_ERR` || exit 1
		test -n "${RKHTMPVAR}" && PRELINK_DEP_ERR_CMDS=" ${RKHTMPVAR} "
	fi


	#
	# Get any set options when doing an update or version check.
	#

	if [ $UPDATE -eq 1 -o $VERSIONCHECK -eq 1 ]; then
		get_mirror_options

		get_webcmd_option
	fi

	return
}


get_readable_date() {

	#
	# This function returns a given epoch second time as a
	# human-readable date and time. It sets the READABLE_DATE
	# variable.
	#

	EPOCH_SECS=$1

	READABLE_DATE=""

	if [ "${EPOCH_DATE_CMD}" = "NONE" ]; then
		:
	elif [ -n "${EPOCH_DATE_CMD}" ]; then
		EPOCH_NOW=`${EPOCH_DATE_CMD} '+%s'`
		EPOCH_SECS=`expr $EPOCH_NOW - $EPOCH_SECS`

		READABLE_DATE=`${EPOCH_DATE_CMD} --date "$EPOCH_SECS seconds ago" '+%d-%b-%Y %H:%M:%S' 2>/dev/null`
	elif [ -n "${PERL_CMD}" ]; then
		READABLE_DATE=`${PERL_CMD} -e "@a=split(' ',scalar(localtime($EPOCH_SECS))); printf \"%d-%s-%d %s\",\\$a[2],\\$a[1],\\$a[4],\\$a[3];" 2>/dev/null`
	fi

	return
}


rkh_dat_set_version() {

	#
	# This function calculates and writes out the 'Version:' value
	# for the rkhunter.dat file. It looks for an old value, and adds
	# one to it. If there is no value then simply start at zero.
	#

	TODAY=`date +%Y%m%d 2>/dev/null`

	OLDVER=`grep '^[Vv]ersion:' ${RKHDAT_FILE} 2>/dev/null | tail -1 | cut -d: -f2`

	if [ -n "${OLDVER}" ]; then
		OLDDATE=`echo "${OLDVER}" | cut -c1-8`
		OLDVER=`echo "${OLDVER}" | cut -c9-10`

		if [ "${OLDVER}" = "99" -o "${OLDDATE}" != "${TODAY}" -o -z "${OLDVER}" -o -n "`echo \"${OLDVER}\" | grep '[^0-9]'`" ]; then
			NEWVER="00"
		else
			NEWVER=`expr ${OLDVER} + 1`
			test $NEWVER -lt 10 && NEWVER="0${NEWVER}"
		fi
	else
		NEWVER="00"
	fi

	echo "Version:${TODAY}${NEWVER}" >>${RKHDAT_TMPFILE}

	return
}


rkh_dat_get_os_info() {

	#
	# This function obtains information about the local computer
	# system. This is then written into the rkhunter.dat file
	# using a simple 'keyword:<value>' format. The OSNAME and
	# ARCH values are not important, but are simply used to check
	# whether they have changed since RKH was last run.
	#
	# Obtaining the OSNAME is somewhat tricky. There is no sure
	# way of finding the information, so we have to use some tricks
	# to locate the correct file. First we look for certain specific
	# O/S release files, and then at the /etc/release file, but not
	# if it is a link. Next we look for a generic /etc/*-release
	# file, again not as a link. This should find most O/S versions.
	# Overall this should also save users having to ask us to support
	# their O/S. In other cases, we will have to ask what file does
	# contain their O/S release information.
	#

	ARCH=`uname -m 2>/dev/null`

	if [ -n "${OS_VERSION_FILE}" ]; then
		REL_FILES="${RKHROOTDIR}${OS_VERSION_FILE}"
	else
		REL_FILES="${RKHROOTDIR}/etc/lsb-release ${RKHROOTDIR}/etc/debian_version ${RKHROOTDIR}/etc/slackware-version ${RKHROOTDIR}/var/ipcop/general-functions.pl ${RKHROOTDIR}/etc/lunar.release ${RKHROOTDIR}/etc/ROCK-VERSION ${RKHROOTDIR}/etc/GoboLinuxVersion ${RKHROOTDIR}/etc/kanotix-version ${RKHROOTDIR}/etc/sidux-version ${RKHROOTDIR}/etc/knoppix-version ${RKHROOTDIR}/etc/zenwalk-version ${RKHROOTDIR}/etc/release ${RKHROOTDIR}/etc/*-release"
	fi

	RKH_LSB_SEEN=0

	for FNAME in ${REL_FILES}; do
		if [ -f "${FNAME}" -a ! -h "${FNAME}" ]; then
			RELEASE=$FNAME

			RKH_IN_LSB=0

			case "${RELEASE}" in
			${RKHROOTDIR}/etc/lsb-release)
				RKH_IN_LSB=1
				RKH_LSB_SEEN=1
				OSNAME=`grep '^DISTRIB_DESCRIPTION=' ${RELEASE} | sed -e 's/DISTRIB_DESCRIPTION=//' | tr -d '"'`
				;;
			${RKHROOTDIR}/etc/gentoo-release)
				GENTOO=1
				if [ -h ${RKHROOTDIR}/etc/make.profile ]; then
					OSNAME="Gentoo `ls -l ${RKHROOTDIR}/etc/make.profile 2>/dev/null | sed -e 's/^.*\/\([^\/]*\)$/\1/'`"
				fi
				;;
			${RKHROOTDIR}/var/ipcop/general-functions.pl)
				OSNAME=`grep 'version *=' ${RELEASE} | head -n 1`
				;;
			${RKHROOTDIR}/etc/debian_version)
				OSNAME="Debian `cat ${RELEASE}`"
				;;
			${RKHROOTDIR}/etc/GoboLinuxVersion)
				OSNAME="GoboLinux `cat ${RELEASE}`"
				;;
			${RKHROOTDIR}/etc/knoppix-version)
				OSNAME="Knoppix `cat ${RELEASE}`"
				;;
			${RKHROOTDIR}/etc/zenwalk-version)
				OSNAME="Zenwalk `cat ${RELEASE}`"
				;;
			*)
				OSNAME=`awk '/^[ 	]*[^ 	]/ { print $0 }' ${RELEASE} | head -n 1`
				;;
			esac


			#
			# Strip out any leading blanks and tabs from the O/S version.
			#

			test -n "${OSNAME}" && OSNAME=`echo ${OSNAME}`


			#
			# If we have a release file but it seems to be blank,
			# and we are not looking at the LSB release file, then
			# we take a look for the first non-blank line. We
			# then, again, strip out any leading blanks and tabs.
			#

			if [ $RKH_IN_LSB -eq 0 -a -z "${OSNAME}" ]; then
				OSNAME=`awk '/^[ 	]*[^ 	]/ { print $0 }' ${RELEASE} | head -n 1`
				OSNAME=`echo ${OSNAME}`
			fi

			test -n "${OSNAME}" && break
		fi
	done


	if [ -z "${OSNAME}" ]; then
		RELEASE=""

		if [ -d "${RKHROOTDIR}/var/smoothwall" ]; then
			OSNAME="Smoothwall Linux"
			RELEASE="${RKHROOTDIR}/var/smoothwall"
		elif [ -n "`which sorcery 2>/dev/null | grep -v ' '`" -a -n "`which gaze 2>/dev/null | grep -v ' '`" ]; then
			OSNAME="Source Mage Linux"
		fi
	fi

	case "${OPERATING_SYSTEM}" in
	SunOS)
		ARCH=`uname -p 2>/dev/null`
		;;
	FreeBSD)
		ARCH=`sysctl -n hw.machine_arch 2>/dev/null`
		OSNAME=`uname -v 2>/dev/null | cut -d' ' -f1,2`
		;;
	OpenBSD)
		OSNAME="OpenBSD `uname -r 2>/dev/null`"
		;;
	Darwin)
		OSNAME=`sw_vers 2>/dev/null | grep '^ProductName:' | sed -e 's/ProductName: *//'`
		OSNAME="${OSNAME} `sw_vers 2>/dev/null | grep '^ProductVersion:' | sed -e 's/ProductVersion: *//'`"
#		OSNAME="${OSNAME} `sysctl kern.version 2>/dev/null | sed -e 's/^kern.version = //' | cut -d: -f1`"

		if [ -n "`sysctl -a 2>/dev/null | egrep '^(hw\.optional\.x86_64|hw\.optional\.64bitops|hw\.cpu64bit_capable).*1$'`" ]; then
			OSNAME="${OSNAME} (64-bit)"
		fi
		;;
	AIX)
		ARCH=`uname -p 2>/dev/null`
		OSNAME="IBM AIX `oslevel 2>/dev/null`"
		;;
	IRIX*)
		OSNAME="${OPERATING_SYSTEM} `uname -r 2>/dev/null`"
		;;
	esac


	#
	# If we still have no O/S version information, then as a last
	# resort we will look to see if an 'issue' file exists or use
	# whatever is in the LSB release file. We test these last because
	# they are not necessarily reliable in providing the O/S version.
	#
	# However, if an O/S has been found, but it seems to be just a
	# version number, then we look for the first word in the 'issue'
	# file and prepend that. Hopefully, it will make sense!
	#

	if [ -z "${OSNAME}" ]; then
		if [ -f "${RKHROOTDIR}/etc/issue" ]; then
			OSNAME=`awk '/^[ 	]*[^ 	]/ { print $0 }' ${RKHROOTDIR}/etc/issue | head -n 1`
			OSNAME=`echo ${OSNAME}`
			test -n "${OSNAME}" && RELEASE="${RKHROOTDIR}/etc/issue"
		fi

		if [ $RKH_LSB_SEEN -eq 1 -a -z "${OSNAME}" ]; then
			OSNAME=`awk '/^[ 	]*[^ 	]/ { print $0 }' ${RKHROOTDIR}/etc/lsb-release | head -n 1`
			OSNAME=`echo ${OSNAME}`
			test -n "${OSNAME}" && RELEASE="${RKHROOTDIR}/etc/lsb-release"
		fi
	elif [ -n "`echo \"${OSNAME}\" | grep '^[0-9.][0-9.]*$'`" ]; then
		if [ -f "${RKHROOTDIR}/etc/issue" ]; then
			RKHTMPVAR=`awk '/^[ 	]*[^ 	]/ { print $1 }' ${RKHROOTDIR}/etc/issue | head -n 1`

			test -n "${RKHTMPVAR}" && OSNAME="${RKHTMPVAR} ${OSNAME}"
		fi
	fi

	return
}


rkh_dat_set_file_properties() {

	#
	# This function obtains various bits of information about the
	# files to be checked. The format in the rkhunter.dat file is:
	#
	#     File:<pathname>:<hash value>:<inode>:<permissions>:<uid>:<gid>:
	#          <file size>:<date/time modified>:<package name>
	#
	# The format is actually governed by the stat.pl file, and the
	# output it produces. Changing the order of options does not
	# change the order of the output.
	#
	# To save time in the loops below, we determine the exact commands
	# required before using them.
	#

	NOHASH_COUNT=0
	PROP_FILE_LIST_COUNT=0
	PROP_FILE_PROPOPT_COUNT=0

	DIR_FILE_COUNT=""

	display --to LOG --type PLAIN SET_FILE_PROP_START


	if ! `check_test attributes` && test $ENDIS_OPT -eq 0; then
		SCMD=""
		INODECMD=""
	elif [ -z "${STAT_CMD}" ]; then
		SCMD=""
		INODECMD=""
	else
		if [ -n "`echo \"${STAT_CMD}\" | grep '\.pl$'`" ]; then
			SCMD="${STAT_CMD} --modeoct --raw --ino --mode --uid --gid --size --Mtime"
			INODECMD="${STAT_CMD} --modeoct --raw --ino"
		elif [ $BSDOS -eq 1 ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %z %m:'"
			INODECMD="${STAT_CMD} -f '%i'"
		else
			SCMD="${STAT_CMD} -c '%i 0%a %u %g %s %Y:'"
			INODECMD="${STAT_CMD} -c '%i'"
		fi
	fi


	if ! `check_test hashes` && test $ENDIS_OPT -eq 0; then
		HCMD=""
	elif [ -z "${PKGMGR}" -a "${HASH_FUNC}" = "NONE" ]; then
		HCMD=""
	else
		HCMD="${HASH_FUNC}"
	fi

	RDIR=`echo "${RKHROOTDIR}" | sed -e 's/\//\\\\\//g'`


	#
	# Now loop through the pathnames looking for the files.
	#

	for FNAME in `cat ${RKH_FILEPROP_LIST}`; do
		test ! -f "${FNAME}" && continue

		FDATA=""
		SYSHASH=""
		PKGNAME=""
		FNAMEGREP=""
		RPM_QUERY_RESULT=""
		NOVRFYFILE=0
		FILE_IS_PKGD=0
		DEPENDENCY_ERR=0

		PROP_FILE_LIST_COUNT=`expr ${PROP_FILE_LIST_COUNT} + 1`


		#
		# Test to see if we are looking for specific files or not.
		#

		if [ -z "${PROPUPD_OPT}" ]; then
			FILENAME=`echo "${FNAME}" | sed -e "s:^${RDIR}::"`

			FNAMEGREP=`echo "${FILENAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`
		else
			#
			# If we are looking for specific files, then just copy the
			# entries from the current rkhunter.dat file for the files
			# we aren't looking for. For the ones we do want, we fall
			# through and process them as before.
			#

			FNAMEGREP=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

			if [ -z "`echo \"${PROPUPD_OPT}\" | grep \" ${FNAMEGREP} \"`" ]; then
				RKHTMPVAR=`grep "^File:${FNAMEGREP}:" ${RKHDAT_FILE}`

				if [ -n "${RKHTMPVAR}" ]; then
					echo "${RKHTMPVAR}" >>${RKHDAT_TMPFILE}
					continue
				fi
			fi

			FILENAME="${FNAME}"

			PROP_FILE_PROPOPT_COUNT=`expr ${PROP_FILE_PROPOPT_COUNT} + 1`
		fi


		#
		# Sort out the directory counters.
		#

		test -n "${DIRNAME_CMD}" && DIR=`${DIRNAME_CMD} ${FILENAME}` || DIR=`echo "${FILENAME}" | sed -e 's:/[^/]*$::'`

		RKHTMPVAR2=`echo "${DIR}" | sed -e 's/\./\\\./g'`

		RKHTMPVAR=`echo "${DIR_FILE_COUNT}" | grep "^${RKHTMPVAR2}:"`

		if [ -z "${RKHTMPVAR}" ]; then
			DIR_FILE_COUNT="${DIR_FILE_COUNT}
${DIR}:1"
		else
			RKHTMPVAR=`echo ${RKHTMPVAR} | cut -d: -f2`
			RKHTMPVAR=`expr ${RKHTMPVAR} + 1`

			DIR_FILE_COUNT=`echo "${DIR_FILE_COUNT}" | sed -e "s;^\(${DIR}:\).*;\1${RKHTMPVAR};"`
		fi


		#
		# See if the file is to be exempt from any package manager verification.
		#

		if [ -n "`echo \"${PKGMGRNOVRFY}\" | grep \" ${FNAMEGREP} \"`" ]; then
			NOVRFYFILE=1
		fi


		#
		# Now start to get the file info by seeing if we
		# are using a package manager.
		#

		if [ "${PKGMGR}" = "RPM" ]; then
			#
			# First see if the file is exempt or belongs to a package.
			#

			if [ $NOVRFYFILE -eq 1 ]; then
				ERRCODE=1
			else
				RKHTMPVAR=`${RPM_CMD} -qf ${FILENAME} --queryformat '%{NAME}\n' 2>/dev/null`
				ERRCODE=$?
			fi

			if [ $ERRCODE -eq 0 ]; then
				#
				# Okay we have a package name.
				#

				FILE_IS_PKGD=1
				PKGNAME=`echo "${RKHTMPVAR}" | tail -1`

				RPM_QUERY_RESULT_ARCH=`${RPM_CMD} -qf --queryformat '[%{FILEMODES:octal}:%{FILEUSERNAME}:%{FILEGROUPNAME}:%{FILESIZES}:%{FILEMTIMES}:%{FILEMD5S}:%{ARCH}:%{FILENAMES}\n]' ${FILENAME} 2>/dev/null | grep ":${FNAMEGREP}\$"`
				ERRCODE=$?

				if [ $ERRCODE -eq 0 ]; then
					#
					# If multiple packages claim the same file, we 
					# use the last one in the list. However, if we
					# have 64-bit as well as 32-bit packages, then
					# we use the 64-bit package in preference (as
					# this is what RPM does).
					#

					RPM_QUERY_RESULT=`echo "${RPM_QUERY_RESULT_ARCH}" | egrep ':(x86_64|ia64):' | tail -1`

					test -z "${RPM_QUERY_RESULT}" && RPM_QUERY_RESULT=`echo "${RPM_QUERY_RESULT_ARCH}" | tail -1`

					FPERM="0`echo \"${RPM_QUERY_RESULT}\" | cut -d: -f1 | cut -c 3-`"
					FPERM=`echo "${FPERM}" | sed -e 's/^00/0/'`

					RKHUID=`echo "${RPM_QUERY_RESULT}" | cut -d: -f2`
					RKHUID=`grep "^${RKHUID}:" /etc/passwd 2>/dev/null | cut -d: -f3`

					RKHGID=`echo "${RPM_QUERY_RESULT}" | cut -d: -f3`
					RKHGID=`grep "^${RKHGID}:" /etc/group 2>/dev/null | cut -d: -f3`

					RKHSIZE=`echo "${RPM_QUERY_RESULT}" | cut -d: -f4`

					RKHDTM=`echo "${RPM_QUERY_RESULT}" | cut -d: -f5`

					#
					# Now get the inode value directly from the disk,
					# but only if prelinking is not being used.
					#

					RKHTMPVAR2=""

					test $PRELINKED -eq 0 && RKHTMPVAR2=`eval ${INODECMD} ${FNAME} 2>/dev/null | tr -d ' '`

					FDATA="${RKHTMPVAR2}:${FPERM}:${RKHUID}:${RKHGID}:${RKHSIZE}:${RKHDTM}"
				else
					display --to LOG --type INFO CMD_ERROR "rpm -qf --queryformat... ${FILENAME}" $ERRCODE
				fi
			fi
		fi


		if [ -n "${HCMD}" ]; then
			if [ -n "`echo \"${PRELINK_DEP_ERR_CMDS}\" | grep \" ${FNAMEGREP} \"`" ]; then
				FILE_IS_PKGD=1
				SYSHASH="ignore-prelink-dep-err"
				display --to LOG --type INFO FILE_PROP_IGNORE_PRELINK_DEP_ERR "${FILENAME}"
			else
				case "${PKGMGR}" in
				RPM)
					test $FILE_IS_PKGD -eq 1 && SYSHASH=`echo "${RPM_QUERY_RESULT}" | cut -d: -f6`
					;;
				DPKG)
					#
					# First see if the file is exempt or part of a known package.
					#

					if [ $NOVRFYFILE -eq 1 ]; then
						ERRCODE=1
					else
						RKHTMPVAR=`${DPKG_CMD} --search ${FILENAME} 2>/dev/null`
						ERRCODE=$?
					fi

					if [ $ERRCODE -eq 0 ]; then
						#
						# Now we sort out the base part of the package name.
						#

						PKGNAME=`echo "${RKHTMPVAR}" | tail -1 | cut -d: -f1`

						#
						# Next strip of the leading '/' from the pathname,
						# and then get the hash value.
						#

						if [ -n "${PKGNAME}" ]; then
							if [ -f "/var/lib/dpkg/info/${PKGNAME}.md5sums" ]; then
								FILNAM=`echo "${FILENAME}" | sed -e 's:^/::; s:\.:\\\.:g'`
								SYSHASH=`egrep "( |\./)${FILNAM}\$" /var/lib/dpkg/info/${PKGNAME}.md5sums 2>/dev/null | cut -d' ' -f1`
								test -n "${SYSHASH}" && FILE_IS_PKGD=1
							fi
						fi
					fi
					;;
				BSD)
					#
					# First see if the file is exempt or part of a known package.
					#

					if [ $NOVRFYFILE -eq 1 ]; then
						ERRCODE=1
					else
						RKHTMPVAR=`${PKG_CMD} -F -e ${FILENAME} 2>/dev/null`
						ERRCODE=$?
					fi

					if [ $ERRCODE -eq 0 ]; then
						#
						# Now we sort out the base part of the package name.
						#

						PKGNAME=`echo "${RKHTMPVAR}" | tail -1 | sed -e 's/[0-9]nb[0-9][0-9]*$//; s/-[0-9.]*$//'`

						#
						# Next strip of the leading '/usr/pkg' from the pathname,
						# and then get the hash value.
						#

						FILNAM=`echo "${FILENAME}" | sed -e 's:^/usr/pkg/::; s:\.:\\\.:g'`
						SYSHASH=`${PKG_CMD} -v -L ${RKHTMPVAR} 2>/dev/null | grep -A 1 "File: ${FILNAM}\$" | tail -1 | cut -d: -f3`
						test -n "${SYSHASH}" && FILE_IS_PKGD=1
					fi
					;;
				esac
			fi

			if [ $FILE_IS_PKGD -eq 0 ]; then
				if [ "${HCMD}" != "NONE" ]; then
					SYSHASH=""
					RKHTMPVAR=`${HCMD} ${FNAME} 2>&1`

					if [ -n "`echo \"${RKHTMPVAR}\" | egrep 'prelink.* (dependenc|adjusting unfinished)'`" ]; then
						DEPENDENCY_ERR=1
						RKHTMPVAR=`echo "${RKHTMPVAR}" | tr '\n' ':' | sed -e 's/:$//'`
					else
						SYSHASH=`echo "${RKHTMPVAR}" | cut -d' ' -f $HASH_FLD_IDX | grep '^[0-9a-fA-F]*$'`
					fi
				fi

				if [ -z "${SYSHASH}" ]; then
					if [ "${HCMD}" = "NONE" ]; then
						if [ $VERBOSE_LOGGING -eq 1 ]; then
							display --to LOG --type INFO FILE_PROP_NO_PKGMGR_FILE "${FNAME}"
						fi
					else
						NOHASH_COUNT=`expr ${NOHASH_COUNT} + 1`

						display --to LOG --type WARNING FILE_PROP_NO_SYSHASH "${FNAME}"

						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_NO_SYSHASH_CMD "${RKHTMPVAR}"

						if [ $DEPENDENCY_ERR -eq 1 ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_NO_SYSHASH_DEPENDENCY "${FNAME}"
						fi
					fi
				fi
			fi
		fi


		if [ -z "${SCMD}" ]; then
			FDATA=":::::"
		else
			if [ -z "${FDATA}" ]; then
				FDATA=`eval ${SCMD} ${FNAME} 2>/dev/null | tr ' ' ':' | sed -e 's/:$//'`
				test -z "${FDATA}" && FDATA=":::::"
			fi
		fi

		echo "File:${FILENAME}:${SYSHASH}:${FDATA}:${PKGNAME}:" >>${RKHDAT_TMPFILE}
	done


	#
	# Display the number of files found in the directories.
	#

	for DIR in ${DIR_FILE_COUNT}; do
		test -z "${DIR}" && continue

		RKHTMPVAR=`echo $DIR | cut -d: -f1`
		RKHTMPVAR2=`echo $DIR | cut -d: -f2`

		display --to LOG --type INFO SET_FILE_PROP_DIR_FILE_COUNT $RKHTMPVAR2 "${RKHTMPVAR}"
	done


	#
	# Finally put the new file in place.
	#

	if [ -f ${RKHDAT_FILE} ]; then
		RKHTMPVAR="updated"
	else
		RKHTMPVAR="created"
	fi

	if [ $NOHASH_COUNT -eq 0 ]; then
		if [ -n "${PROPUPD_OPT}" ]; then
			display --to SCREEN+LOG --type INFO SET_FILE_PROP_FILE_COUNT_PROPOPT "${RKHTMPVAR}" $PROP_FILE_LIST_TOTAL $PROP_FILE_PROPOPT_COUNT $PROP_FILE_LIST_COUNT
		else
			display --to SCREEN+LOG --type INFO SET_FILE_PROP_FILE_COUNT "${RKHTMPVAR}" $PROP_FILE_LIST_TOTAL $PROP_FILE_LIST_COUNT
		fi
	else
		RET_CODE=1

		if [ -n "${PROPUPD_OPT}" ]; then
			display --to SCREEN+LOG --type INFO SET_FILE_PROP_FILE_COUNT_NOHASH_PROPOPT "${RKHTMPVAR}" $PROP_FILE_LIST_TOTAL $PROP_FILE_PROPOPT_COUNT $PROP_FILE_LIST_COUNT $NOHASH_COUNT
		else
			display --to SCREEN+LOG --type INFO SET_FILE_PROP_FILE_COUNT_NOHASH "${RKHTMPVAR}" $PROP_FILE_LIST_TOTAL $PROP_FILE_LIST_COUNT $NOHASH_COUNT
		fi
	fi

	return
}


create_rkh_file_prop_list() {

	#
	# This function creates the file of pathnames
	# used for the file properties check.
	#

	rm -f ${RKH_FILEPROP_LIST} >/dev/null 2>&1

	for DIR in ${PROP_DIR_LIST}; do
		for FNAME in ${PROP_FILE_LIST}; do
			echo "${DIR}/${FNAME}" >>${RKH_FILEPROP_LIST}
		done
	done

	chmod 640 ${RKH_FILEPROP_LIST} >/dev/null 2>&1


	#
	# Now we add any user specified absolute
	# pathnames to be included in the list.
	#

	if [ -n "${USER_FILE_LIST}" ]; then
		for FNAME in ${USER_FILE_LIST}; do
			#
			# We must exclude any user requested files or directories.
			#

			RKHTMPVAR=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

			if [ -n "${USER_EXCLUDE_PROP}" ]; then
				test -n "`echo \" ${USER_EXCLUDE_PROP} \" | grep \" ${RKHTMPVAR} \"`" && continue
			fi

			test -z "`grep \"^${RKHTMPVAR}$\" ${RKH_FILEPROP_LIST} 2>/dev/null`" && echo "${FNAME}" >>${RKH_FILEPROP_LIST}
		done
	fi

	return
}


do_prop_update() {

	#
	# This function updates the local hosts rkhunter.dat file
	# with O/S information and file properties.
	#

	display --to LOG --type INFO --nl PROPUPD_START

	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${RKHTMPDIR}/rkhunter.dat"
	RKHDAT_TMPFILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHDAT_TMPFILE}"


	#
	# We now start to write out information about this system
	# to the file. Some information we already have available,
	# but for others we call functions to obtain what is wanted.
	#

	ARCH=""
	OSNAME=""
	RELEASE=""

	rkh_dat_set_version


	display --to LOG --type PLAIN PROPUPD_OSINFO_START

	rkh_dat_get_os_info

	echo "Host:${HOST_NAME}" >>${RKHDAT_TMPFILE}

	if [ -n "${ARCH}" ]; then
		echo "Arch:${ARCH}" >>${RKHDAT_TMPFILE}
		display --to LOG --type INFO PROPUPD_ARCH_FOUND "${ARCH}"
	fi

	if [ -n "${RELEASE}" ]; then
		display --to LOG --type INFO PROPUPD_REL_FILE "${RELEASE}"
	else
		display --to LOG --type INFO PROPUPD_NO_REL_FILE
		display --to LOG --type PLAIN NAME "      `ls -ld ${RKHROOTDIR}/etc/*release* ${RKHROOTDIR}/etc/*version* 2>/dev/null | tr '\n' ' '`"
	fi

	if [ -n "${OSNAME}" ]; then
		echo "OS:${OSNAME}" >>${RKHDAT_TMPFILE}
		display --to LOG --type INFO PROPUPD_OSNAME_FOUND "${OSNAME}"
	fi

	if [ $PRELINKED -eq 0 ]; then
		echo "Prelinked:No" >>${RKHDAT_TMPFILE}
	else
		echo "Prelinked:Yes" >>${RKHDAT_TMPFILE}
	fi

	#
	# We do not want to bother storing the file hashes or other attibutes
	# if the user has disabled these tests permanently. However, to do
	# this we must check whether the relevant test is enabled or not, and
	# that the --enable/--disable command-line options have not been used.
	#

	if ! `check_test hashes` && test $ENDIS_OPT -eq 0; then
		echo "Hash:Disabled" >>${RKHDAT_TMPFILE}
	elif [ -n "${PRELINK_HASH}" ]; then
		echo "Hash:${PRELINK_HASH}" >>${RKHDAT_TMPFILE}
	else
		echo "Hash:${HASH_FUNC}" >>${RKHDAT_TMPFILE}
	fi

	echo "Pkgmgr:${PKGMGR}" >>${RKHDAT_TMPFILE}

	if ! `check_test attributes` && test $ENDIS_OPT -eq 0; then
		echo "Attributes:Disabled" >>${RKHDAT_TMPFILE}
	elif [ -z "${STAT_CMD}" ]; then
		echo "Attributes:Nostatcmd" >>${RKHDAT_TMPFILE}
	else
		echo "Attributes:Stored" >>${RKHDAT_TMPFILE}
	fi


	#
	# Before we get the actual file properties we need
	# to write out the current list of pathnames.
	#

	create_rkh_file_prop_list


	#
	# Next get the file properties.
	#

	rkh_dat_set_file_properties


	#
	# Now put the new rkhunter.dat file in place.
	#

	cp -f -p ${RKHDAT_FILE} ${RKHDAT_FILE}.old >/dev/null 2>&1
	cp -f ${RKHDAT_TMPFILE} ${RKHDAT_FILE} >/dev/null 2>&1
	ERRCODE=$?

	if [ $ERRCODE -ne 0 ]; then
		RET_CODE=1
		display --to LOG --type INFO CMD_ERROR "cp ${RKHDAT_TMPFILE} ${RKHDAT_FILE}" $ERRCODE
		display --to SCREEN+LOG --type WARNING PROPUPD_ERROR $ERRCODE
	else
		display --to LOG --type INFO PROPUPD_NEW_DAT_FILE "${DB_PATH}"
	fi

	chmod 640 ${RKHDAT_FILE} >/dev/null 2>&1

	rm -f ${RKHDAT_TMPFILE} >/dev/null 2>&1

	return
}


get_next_mirror() {

	#
	# This function will obtain the next mirror in the mirrors file
	# if no mirror is currently being used. It then optionally
	# rotates the mirrors in the file.
	#


	#
	# Return if there is no mirrors file.
	#

	if [ ! -f "${DB_PATH}/mirrors.dat" ]; then
		display --to LOG --type INFO MIRRORS_NO_FILE "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# Return if there are no defined mirrors.
	#

	case $MIRRORS_MODE in
	0)
		MIRROR=`egrep -i '^(local|remote|mirror)=' ${DB_PATH}/mirrors.dat | head -n 1`
		;;
	1)
		MIRROR=`grep -i '^local=' ${DB_PATH}/mirrors.dat | head -n 1`
		;;
	2)
		MIRROR=`grep -i '^remote=' ${DB_PATH}/mirrors.dat | head -n 1`
		;;
	esac

	if [ -z "${MIRROR}" ]; then
		display --to LOG --type INFO MIRRORS_NO_MIRRORS "${DB_PATH}/mirrors.dat"
		return
	fi


	#
	# If we are not rotating the mirrors, then we need to calculate
	# which one to use next in the list. Return when we have done that.
	#

	if [ $ROTATE_MIRRORS -eq 0 ]; then
		N=`expr $TOTAL_MIRRORS - $MIRROR_COUNT`

		case $MIRRORS_MODE in
		0)
			MIRROR=`egrep -i '^(local|remote|mirror)=' ${DB_PATH}/mirrors.dat | head -n $N | tail -1 | cut -d= -f2-`
			;;
		1)
			MIRROR=`grep -i '^local=' ${DB_PATH}/mirrors.dat | head -n $N | tail -1 | cut -d= -f2-`
			;;
		2)
			MIRROR=`grep -i '^remote=' ${DB_PATH}/mirrors.dat | head -n $N | tail -1 | cut -d= -f2-`
			;;
		esac

		return
	fi


	#
	# Now get the version number of the mirrors file. If the version
	# does not exist or is corrupt, then we reset it to zero. This
	# then allows the file to be updated next time the '--update'
	# option is used.
	#

	MIRRORSVERSION=`grep '^[Vv]ersion:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${DB_PATH}/mirrors.dat | tail -1`

	if [ -z "${MIRRORSVERSION}" ]; then
		display --to LOG --type INFO MIRRORS_NO_VERSION "${DB_PATH}/mirrors.dat"
		MIRRORSVERSION="Version:0000000000"
	fi


	#
	# Next get the remaining mirrors.
	#

	OTHERMIRRORS=`egrep -i '^(local|remote|mirror)=' ${DB_PATH}/mirrors.dat | grep -v "^${MIRROR}\$"`


	#
	# We need to get a temporary file name to use.
	#

	get_temp_file "${RKHTMPDIR}/mirrors.dat"
	MIRRORS_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${MIRRORS_FILE}"


	#
	# Output to the temporary file the mirrors version, the other
	# mirrors, and finally the mirror we are about to use.
	#

	echo "${MIRRORSVERSION}" >${MIRRORS_FILE}

	for RKHM in ${OTHERMIRRORS}; do
		echo "${RKHM}" >>${MIRRORS_FILE}
	done;

	echo "${MIRROR}" >>${MIRRORS_FILE}

	MIRROR=`echo "${MIRROR}" | cut -d= -f2-`


	#
	# Move the new file into place, and delete the temporary file.
	#

	cat ${MIRRORS_FILE} >${DB_PATH}/mirrors.dat

	rm -f ${MIRRORS_FILE} >/dev/null 2>&1

	display --to LOG --type INFO MIRRORS_ROTATED "${DB_PATH}/mirrors.dat"

	return
}


download_file() {

	#
	# This function downloads a specified file. It takes three parameters:
	#     1=mirror, 2=url, 3=output file
	#
	# The URL is just the filename portion. The user will supply the
	# full URL, less the filename, to where the files are stored on
	# the local or remote server. For the SourceForge mirrors we will
	# provide the URL.
	#
	# The function sets a return code (DNLOADERR).
	#

	#
	# We loop round through the mirrors until the file is downloaded.
	# We do this by first seeing how many mirrors are available. Then
	# we call a function to get the next mirror, which also rotates
	# the mirror file. If a mirror has already been set, then that
	# mirror is used. That way, in effect, once we find a good mirror
	# then it will be used for all the downloads.
	#

	MIRROR=$1
	URL=$2
	OUTPUT_FILE=$3

	DNLOADERR=0
	MIRROR_COUNT=0
	TOTAL_MIRRORS=0

	if [ -f "${DB_PATH}/mirrors.dat" ]; then
		#
		# The version check will use both the
		# SF mirrors and remote mirrors.
		#

		case $MIRRORS_MODE in
		0)
			MIRROR_COUNT=`egrep -i '^(local|remote|mirror)=' ${DB_PATH}/mirrors.dat | wc -l | tr -d ' '`
			;;
		1)
			MIRROR_COUNT=`grep -i '^local=' ${DB_PATH}/mirrors.dat | wc -l | tr -d ' '`
			;;
		2)
			MIRROR_COUNT=`grep -i '^remote=' ${DB_PATH}/mirrors.dat | wc -l | tr -d ' '`
			;;
		esac

		test -z "${MIRROR_COUNT}" && MIRROR_COUNT=0
	fi

	test $MIRROR_COUNT -eq 0 && MIRROR_COUNT=1

	TOTAL_MIRRORS=$MIRROR_COUNT


	while test $MIRROR_COUNT -gt 0; do
		MIRROR_COUNT=`expr $MIRROR_COUNT - 1`

		if [ -z "${MIRROR}" ]; then
			get_next_mirror

			if [ -z "${MIRROR}" ]; then
				if [ $MIRRORS_MODE -eq 0 ]; then
					MIRROR="http://rkhunter.sourceforge.net"
					display --to LOG --type INFO MIRRORS_SF_DEFAULT "${MIRROR}"
				else
					DNLOADERR=1
					break
				fi
			fi


			#
			# For the SF mirrors add on the final
			# part of the mirror URL.
			#

			if [ "${MIRROR}" = "http://rkhunter.sourceforge.net" ]; then
				MIRROR="${MIRROR}/1.3"
			fi
		fi


		#
		# Now we can download the data into the temporary file.
		#

		# uns - WGET_CMD (cmd, version tested, comments):
		#       wget, *, none.
		#       bget, 1.2, appends output.
		#       curl, 7.15.3: none.
		#       links/elinks, 0.4.2, decompresses output.
		#       lynx, 2.8.5dev.7, decompresses output.

		CMD=""
		DNLOADERR=0

		rm -f ${OUTPUT_FILE} >/dev/null 2>&1

		case "${RKHWEBCMD_BASE}" in
		wget)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} -q -O ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
			;;
		curl)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} --fail --output ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
			;;
		bget)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} --out ${OUTPUT_FILE} ${MIRROR}${URL} 2>/dev/null"
			;;
		links|elinks)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} -no-home 1 -source ${MIRROR}${URL} >${OUTPUT_FILE} 2>/dev/null"
			;;
		lynx)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} -source ${MIRROR}${URL} >${OUTPUT_FILE} 2>/dev/null"
			;;
		GET)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} ${MIRROR}${URL} >${OUTPUT_FILE} 2>/dev/null"
			;;
		*)
			CMD="${RKHWEBCMD} ${RKHWEBCMD_OPTS} ${MIRROR}${URL} >${OUTPUT_FILE} 2>/dev/null"
			;;
		esac

		display --to LOG --type INFO DOWNLOAD_CMD "${CMD}"

		eval ${CMD}
		DNLOADERR=$?

		test $DNLOADERR -gt 1 && DNLOADERR=1


		#
		# Some of these commands do not set the return code. As such we
		# need to look in the output file to see if an error occurred.
		#

		if [ $DNLOADERR -eq 0 ]; then
			if [ -n "`echo \"${URL}\" | grep '/i18n\.ver$'`" ]; then
				#
				# The i18n.ver file is of a different
				# format from the other files.
				#

				:
			elif [ -n "`echo \"${URL}\" | grep '/rkhunter_latest\.dat$'`" ]; then
				#
				# The versioncheck file should just be a version number.
				#

				if [ -z "`grep '^[0-9][0-9]*\.[0-9][.0-9]*$' ${OUTPUT_FILE}`" ]; then
					DNLOADERR=1
				fi
			else
				#
				# All other files should have a normal
				# version number as the first line in them.
				#

				if [ -z "`grep '^[Vv]ersion:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${OUTPUT_FILE}`" ]; then
					DNLOADERR=1
				fi
			fi
		fi

		test ! -s "${OUTPUT_FILE}" && DNLOADERR=1

		if [ $DNLOADERR -eq 0 ]; then
			break
		elif [ $MIRROR_COUNT -gt 0 ]; then
			MIRROR=""
			display --to LOG --type INFO DOWNLOAD_FAIL $MIRROR_COUNT
		fi
	done

	return $DNLOADERR
}


do_i18n_update() {

	#
	# This function updates the i18n language files.
	#
	# We do not know which i18n files should be checked until we
	# have downloaded the i18n/i18n.ver file. This file will tell
	# us which i18n files are available, and their latest version
	# number. We loop through the files, and check each version
	# number against the installed file.
	#

	download_file "${MIRROR}" "/i18n/${PROGRAM_version}/i18n.ver" "${RKHUPD_FILE}"
	ERRCODE=$?

	if [ $ERRCODE -eq 0 ]; then
		#
		# Check that we have some version numbers. There
		# should always be at least one, for the English
		# language! Once we have the list of files, we can
		# remove the temporary file and re-use it when
		# downloading the language files.
		#

		FOUNDFILES=`grep '^[a-zA-Z][a-zA-Z0-9._-]*:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${RKHUPD_FILE}`

		rm -f ${RKHUPD_FILE} >/dev/null 2>&1

		if [ -z "${FOUNDFILES}" ]; then
			RET_CODE=1
			UPD_ERROR=1

			display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n versions"

			display --to LOG --type WARNING UPDATE_I18N_NO_VERS

			return
		fi


		#
		# Now loop through the language files checking their
		# version numbers.
		#

		for FNAME in ${FOUNDFILES}; do
			LANGFILE=`echo "${FNAME}" | cut -d: -f1`
			LATEST_VERS=`echo "${FNAME}" | cut -d: -f2`

			#
			# Only update the language files the user has asked for.
			#

			if [ -n "${UPDATE_LANG}" ]; then
				if [ -z "`echo \" ${UPDATE_LANG} \" | grep \" ${LANGFILE} \"`" ]; then
					display --to LOG --type INFO UPDATE_SKIPPED
					display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color YELLOW --result SKIPPED UPDATE_CHECKING_FILE "i18n/${LANGFILE}"

					continue
				fi
			fi

			if [ -s "${DB_PATH}/i18n/${LANGFILE}" ]; then
				PROG_VERS=`grep '^[Vv]ersion:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${DB_PATH}/i18n/${LANGFILE} 2>/dev/null | tail -1 | cut -d: -f2`

				if [ -z "${PROG_VERS}" ]; then
					PROG_VERS=0
					display --to LOG --type INFO UPDATE_FILE_NO_VERS "${DB_PATH}/i18n/${LANGFILE}"
				fi
			else
				PROG_VERS=0

				touch ${DB_PATH}/i18n/${LANGFILE} >/dev/null 2>&1
				chmod 640 ${DB_PATH}/i18n/${LANGFILE} >/dev/null 2>&1

				display --to LOG --type INFO UPDATE_FILE_MISSING "${DB_PATH}/i18n/${LANGFILE}"
			fi


			display --to LOG --type INFO VERSIONCHECK_CURRENT "${PROG_VERS}"
			display --to LOG --type INFO VERSIONCHECK_LATEST "${LATEST_VERS}"


			if [ $PROG_VERS -lt $LATEST_VERS ]; then
				download_file "${MIRROR}" "/i18n/${PROGRAM_version}/${LANGFILE}" "${RKHUPD_FILE}"
				ERRCODE=$?

				if [ $ERRCODE -eq 0 ]; then
					test $RET_CODE -eq 0 && RET_CODE=2

					cat ${RKHUPD_FILE} >${DB_PATH}/i18n/${LANGFILE}

					display --to LOG --type INFO VERSIONCHECK_UPDT_AVAIL
					display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result UPD UPDATE_CHECKING_FILE "i18n/${LANGFILE}"
				else
					RET_CODE=1
					UPD_ERROR=1

					display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "i18n/${LANGFILE}"
					display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n/${LANGFILE}"
				fi

				rm -f ${RKHUPD_FILE} >/dev/null 2>&1
			else
				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result NO_UPD UPDATE_CHECKING_FILE "i18n/${LANGFILE}"
			fi
		done
	else
		RET_CODE=1
		UPD_ERROR=1

		display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "i18n versions"

		display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "i18n.ver"
	fi


	rm -f ${RKHUPD_FILE} >/dev/null 2>&1

	return
}


do_update() {

	#
	# This function checks to see if any of the supplied RKH
	# *.dat and i18n files needs updating. If it does, then the
	# file is overwritten with the new version.
	#

	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl UPDATE_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${RKHTMPDIR}/rkhunter.upd"
	RKHUPD_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHUPD_FILE}"


	#
	# Now we loop round through the files we need to check. Each file
	# will use the first mirror, and if necessary loop through the
	# remaining mirrors until the file is downloaded. In theory this
	# could take some time if the mirror sites are all experiencing
	# problems and this is affecting all the files.
	#
	# For each file we look at the current version number. If there
	# is a problem doing this, then we just try and download a new
	# copy of the file. If the version number is okay, then we
	# download the file to find the latest version number. If
	# that is successful, we then update the file if necessary.
	#

	UPD_ERROR=0
	MIRROR=""

	for UPDFILE in mirrors.dat programs_bad.dat backdoorports.dat suspscan.dat; do
		if [ $UPDATE_MIRRORS -eq 0 -a "${UPDFILE}" = "mirrors.dat" ]; then
			display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result SKIPPED UPDATE_CHECKING_FILE "${UPDFILE}"
			continue
		fi


		LATEST_VERS=0

		if [ -s "${DB_PATH}/${UPDFILE}" ]; then
			PROG_VERS=`grep '^[Vv]ersion:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${DB_PATH}/${UPDFILE} | tail -1 | cut -d: -f2`

			if [ -z "${PROG_VERS}" ]; then
				PROG_VERS=0
				display --to LOG --type INFO UPDATE_FILE_NO_VERS "${UPDFILE}"
			fi
		else
			PROG_VERS=0

			touch ${DB_PATH}/${UPDFILE} >/dev/null 2>&1
			chmod 640 ${DB_PATH}/${UPDFILE} >/dev/null 2>&1

			display --to LOG --type INFO UPDATE_FILE_MISSING "${UPDFILE}"
		fi


		#
		# Now download the file.
		#
		# Note: To avoid any backward incompatability we
		# get the files from a specific directory which
		# previous versions do not use.
		#

		download_file "${MIRROR}" "/${UPDFILE}" "${RKHUPD_FILE}"
		ERRCODE=$?


		#
		# Next we compare the current and downloaded
		# file version numbers.
		#

		if [ $ERRCODE -eq 0 ]; then
			LATEST_VERS=`grep '^[Vv]ersion:[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$' ${RKHUPD_FILE} | tail -1 | cut -d: -f2`

			if [ -z "${LATEST_VERS}" ]; then
				LATEST_VERS=0
			elif [ -z "`echo \"${LATEST_VERS}\" | grep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$'`" ]; then
				LATEST_VERS=0
			fi


			display --to LOG --type INFO VERSIONCHECK_CURRENT "${PROG_VERS}"
			display --to LOG --type INFO VERSIONCHECK_LATEST "${LATEST_VERS}"

			if [ $LATEST_VERS -eq 0 ]; then
				RET_CODE=1
				UPD_ERROR=1

				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result VCHK_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"

				LATEST_VERS=`head -n 1 ${RKHUPD_FILE}`

				display --to LOG --type WARNING VERSIONCHECK_CONV_FAIL "${PROG_VERS}" "${LATEST_VERS}"
			elif [ $PROG_VERS -lt $LATEST_VERS ]; then
				test $RET_CODE -eq 0 && RET_CODE=2

				display --to LOG --type INFO VERSIONCHECK_UPDT_AVAIL

				cat ${RKHUPD_FILE} >${DB_PATH}/${UPDFILE}

				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result UPD UPDATE_CHECKING_FILE "${UPDFILE}"
			else
				display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color GREEN --result NO_UPD UPDATE_CHECKING_FILE "${UPDFILE}"
			fi
		else
			RET_CODE=1
			UPD_ERROR=1

			display --to LOG --type WARNING UPDATE_DOWNLOAD_FAIL "${UPDFILE}"
			display --to SCREEN+LOG --type PLAIN --screen-indent 2 --color RED --result UPD_FAILED UPDATE_CHECKING_FILE "${UPDFILE}"
		fi

		rm -f ${RKHUPD_FILE} >/dev/null 2>&1
	done


	#
	# We now need to update the i18n files. Since this is a little
	# more complicated, it is handled in a separate function.
	#

	do_i18n_update


	if [ $UPD_ERROR -eq 1 ]; then
		if [ $NOLOG -eq 1 ]; then
			display --to SCREEN --type PLAIN --nl --nl-after CHECK_WARNINGS_FOUND_RERUN
		else
			display --to SCREEN --type PLAIN --nl --nl-after CHECK_WARNINGS_FOUND_CHK_LOG "${RKHLOGFILE}"
		fi
	fi

	return
}


do_versioncheck() {

	#
	# This function performs a program version check.
	#
	# It will set the return code in some instances:
	#       0 - (implied) no error, no new version available
	#	1 - a download (of the version number) error occurred
	#	2 - no error occurred, but a new version is available
	#

	MIRROR=""
	LATESTVERSION=""

	display --to SCREEN+LOG --type PLAIN --color YELLOW --nl VERSIONCHECK_START


	#
	# First we need to get a temporary file name to use.
	#

	get_temp_file "${RKHTMPDIR}/rkhunter.vc"
	RKHVC_FILE=$TEMPFILE

	display --to LOG --type INFO CREATED_TEMP_FILE "${RKHVC_FILE}"


	#
	# Next we get the current program version number.
	#

	PROG_VERS=`echo "${PROGRAM_version}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`

	test -z "${PROG_VERS}" && PROG_VERS=0

	display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_CURRENT "${PROGRAM_version}"


	#
	# Download the file, and then compare the current value
	# with the downloaded one.
	#

	download_file "${MIRROR}" "/rkhunter_latest.dat" "${RKHVC_FILE}"
	ERRCODE=$?

	if [ $ERRCODE -eq 0 ]; then
		LATESTVERSION=`cat ${RKHVC_FILE} 2>/dev/null`

		#
		# Convert the version string to zero-spaced numbers.
		# This allows us to numerically compare the versions,
		# even when the numbers go above ten.
		#
		# E.g. '1.2.10' => 10210,   '1.3.2' => 10302.
		#

		LATEST_VERS=`echo "${LATESTVERSION}" | cut -d. -f1-3 | sed -e 's/\.\([0-9]\)\./.0\1./' | sed -e 's/\.\([0-9]\)$/.0\1/' | tr -d '.'`

		test -z "${LATEST_VERS}" && LATEST_VERS=0

		display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_LATEST "${LATESTVERSION}"

		if [ $LATEST_VERS -eq 0 ]; then
			RET_CODE=1
			display --to SCREEN+LOG --type WARNING --screen-indent 2 VERSIONCHECK_CONV_FAIL "${PROGRAM_version}" "${LATESTVERSION}"
		elif [ $PROG_VERS -lt $LATEST_VERS ]; then
			test $RET_CODE -eq 0 && RET_CODE=2
			display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_UPDT_AVAIL
		fi
	else
		RET_CODE=1

		display --to LOG --type WARNING VERSIONCHECK_FAIL_ALL
		display --to SCREEN+LOG --type PLAIN --screen-indent 2 VERSIONCHECK_LATEST_FAIL
	fi

	rm -f ${RKHVC_FILE} >/dev/null 2>&1

	return
}


do_system_check_initialisation() {

	#
	# This function simply initialises the default rootkit
	# files and directories.
	#


	# 55808 Variant A
	W55808A_FILES="${RKHROOTDIR}/tmp/.../r
		       ${RKHROOTDIR}/tmp/.../a"
	W55808A_DIRS=
	W55808A_KSYMS=


	# Adore Rootkit. OK, nobody calls it that but basically it uses Adore.
	# In one commercial AV vendors naming scheme it's called Dextenea.
	AKIT_FILES="${RKHROOTDIR}/usr/secure
		    ${RKHROOTDIR}/usr/doc/sys/qrt
		    ${RKHROOTDIR}/usr/doc/sys/run
		    ${RKHROOTDIR}/usr/doc/sys/crond
		    ${RKHROOTDIR}/usr/sbin/kfd
		    ${RKHROOTDIR}/usr/doc/kern/var
		    ${RKHROOTDIR}/usr/doc/kern/string.o
		    ${RKHROOTDIR}/usr/doc/kern/ava
		    ${RKHROOTDIR}/usr/doc/kern/adore.o
		    ${RKHROOTDIR}/var/log/ssh/old"
	AKIT_DIRS="${RKHROOTDIR}/lib/security/.config/ssh
		   ${RKHROOTDIR}/usr/doc/kern
		   ${RKHROOTDIR}/usr/doc/backup
		   ${RKHROOTDIR}/usr/doc/backup/txt
		   ${RKHROOTDIR}/lib/backup
		   ${RKHROOTDIR}/lib/backup/txt
		   ${RKHROOTDIR}/usr/doc/work
		   ${RKHROOTDIR}/usr/doc/sys
		   ${RKHROOTDIR}/var/log/ssh
		   ${RKHROOTDIR}/usr/doc/.spool
		   ${RKHROOTDIR}/usr/lib/kterm"
	AKIT_KSYMS=


	# AjaKit Rootkit
	AJAKIT_FILES="${RKHROOTDIR}/dev/tux/.addr
		      ${RKHROOTDIR}/dev/tux/.proc
		      ${RKHROOTDIR}/dev/tux/.file
		      ${RKHROOTDIR}/lib/.libgh-gh/cleaner
		      ${RKHROOTDIR}/lib/.libgh-gh/Patch/patch
		      ${RKHROOTDIR}/lib/.libgh-gh/sb0k"
	AJAKIT_DIRS="${RKHROOTDIR}/dev/tux
		     ${RKHROOTDIR}/lib/.libgh-gh"
	AJAKIT_KSYMS=


	# aPa Kit Rootkit
	APAKIT_FILES="${RKHROOTDIR}/usr/share/.aPa"
	APAKIT_DIRS=
	APAKIT_KSYMS=


	# Apache Worm
	APACHEWORM_FILES="${RKHROOTDIR}/bin/.log"
	APACHEWORM_DIRS=
	APACHEWORM_KSYMS=


	# Ambient (ark) Rootkit
	ARK_FILES="${RKHROOTDIR}/usr/lib/.ark?
		   ${RKHROOTDIR}/dev/ptyxx/.log
		   ${RKHROOTDIR}/dev/ptyxx/.file
		   ${RKHROOTDIR}/dev/ptyxx/.proc
		   ${RKHROOTDIR}/dev/ptyxx/.addr"
	ARK_DIRS="${RKHROOTDIR}/dev/ptyxx"
	ARK_KSYMS=


	# Balaur Rootkit 2.0 (LRK5 based)
	BALAUR_FILES="${RKHROOTDIR}/usr/lib/liblog.o"
	BALAUR_DIRS="${RKHROOTDIR}/usr/lib/.kinetic
		     ${RKHROOTDIR}/usr/lib/.egcs
		     ${RKHROOTDIR}/usr/lib/.wormie"
	BALAUR_KSYMS=


	# Beastkit Rootkit
	BEASTKIT_FILES="${RKHROOTDIR}/usr/sbin/arobia
			${RKHROOTDIR}/usr/sbin/idrun
			${RKHROOTDIR}/usr/lib/elm/arobia/elm
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/hk
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/hk.pub
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/sc
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/sd.pp
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/sdco
			${RKHROOTDIR}/usr/lib/elm/arobia/elm/srsd"
	BEASTKIT_DIRS="${RKHROOTDIR}/lib/ldd.so/bktools"
	BEASTKIT_KSYMS=


	# beX2 Rootkit
	BEX_FILES="${RKHROOTDIR}/usr/info/termcap.info-5.gz
		   ${RKHROOTDIR}/usr/bin/sshd2"
	BEX_DIRS="${RKHROOTDIR}/usr/include/bex"
	BEX_KSYMS=


	# BOBkit Rootkit
	BOBKIT_FILES="${RKHROOTDIR}/usr/sbin/ntpsx
		      ${RKHROOTDIR}/usr/sbin/.../bkit-ava
		      ${RKHROOTDIR}/usr/sbin/.../bkit-d
		      ${RKHROOTDIR}/usr/sbin/.../bkit-shd
		      ${RKHROOTDIR}/usr/sbin/.../bkit-f
		      ${RKHROOTDIR}/usr/include/.../proc.h
		      ${RKHROOTDIR}/usr/include/.../.bash_history
		      ${RKHROOTDIR}/usr/include/.../bkit-get
		      ${RKHROOTDIR}/usr/include/.../bkit-dl
		      ${RKHROOTDIR}/usr/include/.../bkit-screen
		      ${RKHROOTDIR}/usr/include/.../bkit-sleep
		      ${RKHROOTDIR}/usr/lib/.../bkit-adore.o
		      ${RKHROOTDIR}/usr/lib/.../ls
		      ${RKHROOTDIR}/usr/lib/.../netstat
		      ${RKHROOTDIR}/usr/lib/.../lsof
		      ${RKHROOTDIR}/usr/lib/.../bkit-ssh/bkit-shdcfg
		      ${RKHROOTDIR}/usr/lib/.../bkit-ssh/bkit-shhk
		      ${RKHROOTDIR}/usr/lib/.../bkit-ssh/bkit-pw
		      ${RKHROOTDIR}/usr/lib/.../bkit-ssh/bkit-shrs
		      ${RKHROOTDIR}/usr/lib/.../bkit-ssh/bkit-mots
		      ${RKHROOTDIR}/usr/lib/.../uconf.inv
		      ${RKHROOTDIR}/usr/lib/.../psr
		      ${RKHROOTDIR}/usr/lib/.../find
		      ${RKHROOTDIR}/usr/lib/.../pstree
		      ${RKHROOTDIR}/usr/lib/.../slocate
		      ${RKHROOTDIR}/usr/lib/.../du
		      ${RKHROOTDIR}/usr/lib/.../top"
	BOBKIT_DIRS="${RKHROOTDIR}/usr/sbin/...
		     ${RKHROOTDIR}/usr/include/...
		     ${RKHROOTDIR}/usr/include/.../.tmp
		     ${RKHROOTDIR}/usr/lib/...
		     ${RKHROOTDIR}/usr/lib/.../.ssh
		     ${RKHROOTDIR}/usr/lib/.../bkit-ssh
		     ${RKHROOTDIR}/usr/lib/.bkit-
		     ${RKHROOTDIR}/tmp/.bkp"
	BOBKIT_KSYMS=

	# Boxer-0.99b3

	# cb Rootkit (w00tkit by ZeeN) 
	# The '%' character represents a space.
	# xC.o = Adore LKM
	CB_FILES="${RKHROOTDIR}/dev/srd0
		  ${RKHROOTDIR}/lib/libproc.so.2.0.6
		  ${RKHROOTDIR}/dev/mounnt
		  ${RKHROOTDIR}/etc/rc.d/init.d/init
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/cl
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/.x.tgz
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/statdx
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/wted
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/write
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/scan
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/sc
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/sl2
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/wroot
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/wscan
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/wu
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/v
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/read
		  ${RKHROOTDIR}/usr/lib/sshrc
		  ${RKHROOTDIR}/usr/lib/ssh_host_key
		  ${RKHROOTDIR}/usr/lib/ssh_host_key.pub
		  ${RKHROOTDIR}/usr/lib/ssh_random_seed
		  ${RKHROOTDIR}/usr/lib/sshd_config
		  ${RKHROOTDIR}/usr/lib/shosts.equiv
		  ${RKHROOTDIR}/usr/lib/ssh_known_hosts
		  ${RKHROOTDIR}/u/zappa/.ssh/pid
		  ${RKHROOTDIR}/usr/bin/.system/..%/tcp.log
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/curatare/attrib
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/curatare/chattr
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/curatare/ps
		  ${RKHROOTDIR}/usr/bin/.zeen/..%/curatare/pstree
		  ${RKHROOTDIR}/usr/bin/.system/..%/.x/xC.o"
	CB_DIRS="${RKHROOTDIR}/usr/bin/.zeen
		 ${RKHROOTDIR}/usr/bin/.zeen/..%/curatare
		 ${RKHROOTDIR}/usr/bin/.zeen/..%/scan
		 ${RKHROOTDIR}/usr/bin/.system/..%"
	CB_KSYMS=


	# CiNIK Worm (Slapper.B variant)
	CINIK_FILES="${RKHROOTDIR}/tmp/.cinik"
	CINIK_DIRS="${RKHROOTDIR}/tmp/.font-unix/.cinik"
	CINIK_KSYMS=


	# CX Rootkit
	CXKIT_FILES="${RKHROOTDIR}/usr/lib/ldlibso
		     ${RKHROOTDIR}/usr/lib/configlibso
		     ${RKHROOTDIR}/usr/lib/shklibso
		     ${RKHROOTDIR}/usr/lib/randomlibso
		     ${RKHROOTDIR}/usr/lib/ldlibstrings.so
		     ${RKHROOTDIR}/usr/lib/ldlibdu.so
		     ${RKHROOTDIR}/usr/lib/ldlibns.so
		     ${RKHROOTDIR}/usr/include/db"
	CXKIT_DIRS="${RKHROOTDIR}/usr/include/cxk"
	CXKIT_KSYMS=


	# Danny-Boy's Abuse Kit
	DANNYBOYS_FILES="${RKHROOTDIR}/dev/mdev
			 ${RKHROOTDIR}/usr/lib/libX.a"
	DANNYBOYS_DIRS=
	DANNYBOYS_KSYMS=


	# Devil Rootkit
	DEVIL_FILES="${RKHROOTDIR}/var/lib/games/.src
		     ${RKHROOTDIR}/dev/dsx
		     ${RKHROOTDIR}/dev/caca
		     ${RKHROOTDIR}/dev/pro
		     ${RKHROOTDIR}/bin/bye
		     ${RKHROOTDIR}/bin/homedir
		     ${RKHROOTDIR}/usr/bin/xfss
		     ${RKHROOTDIR}/usr/sbin/tzava
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/holber
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/sense
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/clear
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/tzava
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/citeste
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/killrk
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/searchlog
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/gaoaza
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/cleaner
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/shk
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/srs
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/utile.tgz
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/webpage
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/getpsy
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/getbnc
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/getemech
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/localroot.sh
		     ${RKHROOTDIR}/usr/doc/tar/.../.dracusor/stuff/old/sense"
	DEVIL_DIRS="${RKHROOTDIR}/usr/doc/tar/.../.dracusor"
	DEVIL_KSYMS=


	# Dica-Kit (T0rn variant) Rootkit
	DICA_FILES="${RKHROOTDIR}/lib/.sso
		    ${RKHROOTDIR}/lib/.so
		    ${RKHROOTDIR}/var/run/...dica/clean
		    ${RKHROOTDIR}/var/run/...dica/dxr
		    ${RKHROOTDIR}/var/run/...dica/read
		    ${RKHROOTDIR}/var/run/...dica/write
		    ${RKHROOTDIR}/var/run/...dica/lf
		    ${RKHROOTDIR}/var/run/...dica/xl
		    ${RKHROOTDIR}/var/run/...dica/xdr
		    ${RKHROOTDIR}/var/run/...dica/psg
		    ${RKHROOTDIR}/var/run/...dica/secure
		    ${RKHROOTDIR}/var/run/...dica/rdx
		    ${RKHROOTDIR}/var/run/...dica/va
		    ${RKHROOTDIR}/var/run/...dica/cl.sh
		    ${RKHROOTDIR}/var/run/...dica/last.log
		    ${RKHROOTDIR}/usr/bin/.etc
		    ${RKHROOTDIR}/etc/sshd_config
		    ${RKHROOTDIR}/etc/ssh_host_key
		    ${RKHROOTDIR}/etc/ssh_random_seed"
	DICA_DIRS="${RKHROOTDIR}/var/run/...dica
		   ${RKHROOTDIR}/var/run/...dica/mh
		   ${RKHROOTDIR}/var/run/...dica/scan"
	DICA_KSYMS=


	# Dreams Rootkit
	DREAMS_FILES="${RKHROOTDIR}/dev/ttyoa
		      ${RKHROOTDIR}/dev/ttyof
		      ${RKHROOTDIR}/dev/ttyop
		      ${RKHROOTDIR}/usr/bin/sense
		      ${RKHROOTDIR}/usr/bin/sl2
		      ${RKHROOTDIR}/usr/bin/logclear
		      ${RKHROOTDIR}/usr/bin/(swapd)
		      ${RKHROOTDIR}/usr/bin/initrd
		      ${RKHROOTDIR}/usr/bin/crontabs
		      ${RKHROOTDIR}/usr/bin/snfs
		      ${RKHROOTDIR}/usr/lib/libsss
		      ${RKHROOTDIR}/usr/lib/libsnf.log
		      ${RKHROOTDIR}/usr/lib/libshtift/top
		      ${RKHROOTDIR}/usr/lib/libshtift/ps
		      ${RKHROOTDIR}/usr/lib/libshtift/netstat
		      ${RKHROOTDIR}/usr/lib/libshtift/ls
		      ${RKHROOTDIR}/usr/lib/libshtift/ifconfig
		      ${RKHROOTDIR}/usr/include/linseed.h
		      ${RKHROOTDIR}/usr/include/linpid.h
		      ${RKHROOTDIR}/usr/include/linkey.h
		      ${RKHROOTDIR}/usr/include/linconf.h
		      ${RKHROOTDIR}/usr/include/iceseed.h
		      ${RKHROOTDIR}/usr/include/icepid.h
		      ${RKHROOTDIR}/usr/include/icekey.h
		      ${RKHROOTDIR}/usr/include/iceconf.h" 
	DREAMS_DIRS="${RKHROOTDIR}/dev/ida/.hpd
		     ${RKHROOTDIR}/usr/lib/libshtift"
	DREAMS_KSYMS=


	# Duarawkz Rootkit
	DUARAWKZ_FILES="${RKHROOTDIR}/usr/bin/duarawkz/loginpass"
	DUARAWKZ_DIRS="${RKHROOTDIR}/usr/bin/duarawkz"
	DUARAWKZ_KSYMS=


	# ENYE LKM v1.1, v1.2
	# Installer default.
	ENYELKM_FILES="${RKHROOTDIR}/etc/.enyelkmHIDE^IT.ko
		       ${RKHROOTDIR}/etc/.enyelkmOCULTAR.ko"
	ENYELKM_DIRS=
	ENYELKM_KSYMS=


	# Flea Linux Rootkit
	FLEA_FILES="${RKHROOTDIR}/etc/ld.so.hash
		    ${RKHROOTDIR}/lib/security/.config/ssh/sshd_config
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key.pub
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_random_seed
		    ${RKHROOTDIR}/usr/bin/ssh2d
		    ${RKHROOTDIR}/usr/lib/ldlibns.so
		    ${RKHROOTDIR}/usr/lib/ldlibps.so
		    ${RKHROOTDIR}/usr/lib/ldlibpst.so
		    ${RKHROOTDIR}/usr/lib/ldlibdu.so
		    ${RKHROOTDIR}/usr/lib/ldlibct.so"
	FLEA_DIRS="${RKHROOTDIR}/lib/security/.config/ssh
		   ${RKHROOTDIR}/dev/..0
		   ${RKHROOTDIR}/dev/..0/backup"
	FLEA_KSYMS=


	# FreeBSD Rootkit (FBRK) catering to versions and compile-time defaults used by: 
	# 1.0 (1997, Method), 1.2 (1997, Method), "ImperialS-FBRK 1.0" (2001, Nyo)
	FREEBSD_RK_FILES="${RKHROOTDIR}/dev/ptyp
			  ${RKHROOTDIR}/dev/ptyq
			  ${RKHROOTDIR}/dev/ptyr
			  ${RKHROOTDIR}/dev/ptys
			  ${RKHROOTDIR}/dev/ptyt
			  ${RKHROOTDIR}/dev/fd/.88/freshb-bsd
			  ${RKHROOTDIR}/dev/fd/.88/fresht
			  ${RKHROOTDIR}/dev/fd/.88/zxsniff
			  ${RKHROOTDIR}/dev/fd/.88/zxsniff.log
			  ${RKHROOTDIR}/dev/fd/.99/.ttyf00
			  ${RKHROOTDIR}/dev/fd/.99/.ttyp00
			  ${RKHROOTDIR}/dev/fd/.99/.ttyq00
			  ${RKHROOTDIR}/dev/fd/.99/.ttys00
			  ${RKHROOTDIR}/dev/fd/.99/.pwsx00
			  ${RKHROOTDIR}/etc/.acid
			  ${RKHROOTDIR}/usr/lib/.fx/sched_host.2
			  ${RKHROOTDIR}/usr/lib/.fx/random_d.2
			  ${RKHROOTDIR}/usr/lib/.fx/set_pid.2
			  ${RKHROOTDIR}/usr/lib/.fx/setrgrp.2
			  ${RKHROOTDIR}/usr/lib/.fx/TOHIDE
			  ${RKHROOTDIR}/usr/lib/.fx/cons.saver
			  ${RKHROOTDIR}/usr/lib/.fx/adore/ava/ava
			  ${RKHROOTDIR}/usr/lib/.fx/adore/adore/adore.ko
			  ${RKHROOTDIR}/bin/sysback
			  ${RKHROOTDIR}/usr/local/bin/sysback"
	FREEBSD_RK_DIRS="${RKHROOTDIR}/dev/fd/.88
			 ${RKHROOTDIR}/dev/fd/.99
			 ${RKHROOTDIR}/usr/lib/.fx
			 ${RKHROOTDIR}/usr/lib/.fx/adore"
	FREEBSD_RK_KSYMS=


	# Fu Rootkit
	FU_FILES="${RKHROOTDIR}/sbin/xc
		  ${RKHROOTDIR}/usr/include/ivtype.h
		  ${RKHROOTDIR}/bin/.lib"
	FU_DIRS=
	FU_KSYMS=


	# Fuckit Rootkit
	FUCKIT_FILES="${RKHROOTDIR}/lib/libproc.so.2.0.7
		      ${RKHROOTDIR}/dev/proc/.bash_profile
		      ${RKHROOTDIR}/dev/proc/.bashrc
		      ${RKHROOTDIR}/dev/proc/.cshrc
		      ${RKHROOTDIR}/dev/proc/fuckit/hax0r
		      ${RKHROOTDIR}/dev/proc/fuckit/hax0rshell
		      ${RKHROOTDIR}/dev/proc/fuckit/config/lports
		      ${RKHROOTDIR}/dev/proc/fuckit/config/rports
		      ${RKHROOTDIR}/dev/proc/fuckit/config/rkconf
		      ${RKHROOTDIR}/dev/proc/fuckit/config/password
		      ${RKHROOTDIR}/dev/proc/fuckit/config/progs
		      ${RKHROOTDIR}/dev/proc/fuckit/system-bins/init
		      ${RKHROOTDIR}/usr/lib/libcps.a
		      ${RKHROOTDIR}/usr/lib/libtty.a"
	FUCKIT_DIRS="${RKHROOTDIR}/dev/proc
		     ${RKHROOTDIR}/dev/proc/fuckit
		     ${RKHROOTDIR}/dev/proc/fuckit/system-bins
		     ${RKHROOTDIR}/dev/proc/toolz"
	FUCKIT_KSYMS=


	# GasKit Rootkit
	GASKIT_FILES="${RKHROOTDIR}/dev/dev/gaskit/sshd/sshdd"
	GASKIT_DIRS="${RKHROOTDIR}/dev/dev
		     ${RKHROOTDIR}/dev/dev/gaskit
		     ${RKHROOTDIR}/dev/dev/gaskit/sshd"
	GASKIT_KSYMS=


	# Heroin LKM
	HEROIN_FILES=
	HEROIN_DIRS=
	HEROIN_KSYMS="heroin"


	# HjC Kit Rootkit
	HJCKIT_FILES=
	HJCKIT_DIRS="${RKHROOTDIR}/dev/.hijackerz"
	HJCKIT_KSYMS=


	# ignoKit Rootkit
	IGNOKIT_FILES="${RKHROOTDIR}/lib/defs/p
		       ${RKHROOTDIR}/lib/defs/q
		       ${RKHROOTDIR}/lib/defs/r
		       ${RKHROOTDIR}/lib/defs/s
		       ${RKHROOTDIR}/lib/defs/t
		       ${RKHROOTDIR}/usr/lib/defs/p
		       ${RKHROOTDIR}/usr/lib/defs/q
		       ${RKHROOTDIR}/usr/lib/defs/r
		       ${RKHROOTDIR}/usr/lib/defs/s
		       ${RKHROOTDIR}/usr/lib/defs/t
		       ${RKHROOTDIR}/usr/lib/.libigno/pkunsec
		       ${RKHROOTDIR}/usr/lib/.libigno/.igno/psybnc/psybnc"
	IGNOKIT_DIRS="${RKHROOTDIR}/usr/lib/.libigno
		      ${RKHROOTDIR}/usr/lib/.libigno/.igno"
	IGNOKIT_KSYMS=


	# iLLogiC Rootkit (SunOS Rootkit variant)
	ILLOGIC_FILES="${RKHROOTDIR}/dev/kmod
		       ${RKHROOTDIR}/dev/dos
		       ${RKHROOTDIR}/usr/lib/crth.o
		       ${RKHROOTDIR}/usr/lib/crtz.o
		       ${RKHROOTDIR}/etc/ld.so.hash
		       ${RKHROOTDIR}/usr/bin/sia
		       ${RKHROOTDIR}/usr/bin/ssh2d
		       ${RKHROOTDIR}/lib/security/.config/sn
		       ${RKHROOTDIR}/lib/security/.config/iver
		       ${RKHROOTDIR}/lib/security/.config/uconf.inv
		       ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key
		       ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key.pub
		       ${RKHROOTDIR}/lib/security/.config/ssh/sshport
		       ${RKHROOTDIR}/lib/security/.config/ssh/ssh_random_seed
		       ${RKHROOTDIR}/lib/security/.config/ava
		       ${RKHROOTDIR}/lib/security/.config/cleaner
		       ${RKHROOTDIR}/lib/security/.config/lpsched
		       ${RKHROOTDIR}/lib/security/.config/sz
		       ${RKHROOTDIR}/lib/security/.config/rcp
		       ${RKHROOTDIR}/lib/security/.config/patcher
		       ${RKHROOTDIR}/lib/security/.config/pg
		       ${RKHROOTDIR}/lib/security/.config/crypt
		       ${RKHROOTDIR}/lib/security/.config/utime
		       ${RKHROOTDIR}/lib/security/.config/wget
		       ${RKHROOTDIR}/lib/security/.config/instmod
		       ${RKHROOTDIR}/lib/security/.config/bin/find
		       ${RKHROOTDIR}/lib/security/.config/bin/du
		       ${RKHROOTDIR}/lib/security/.config/bin/ls
		       ${RKHROOTDIR}/lib/security/.config/bin/psr
		       ${RKHROOTDIR}/lib/security/.config/bin/netstat
		       ${RKHROOTDIR}/lib/security/.config/bin/su
		       ${RKHROOTDIR}/lib/security/.config/bin/ping
		       ${RKHROOTDIR}/lib/security/.config/bin/passwd"
	ILLOGIC_DIRS="${RKHROOTDIR}/lib/security/.config
		      ${RKHROOTDIR}/lib/security/.config/ssh
		      ${RKHROOTDIR}/lib/security/.config/bin
		      ${RKHROOTDIR}/lib/security/.config/backup
		      ${RKHROOTDIR}/root/%%%/.dir
		      ${RKHROOTDIR}/root/%%%/.dir/mass-scan
		      ${RKHROOTDIR}/root/%%%/.dir/flood"
	ILLOGIC_KSYMS=


	# IntoXonia-NG Rootkit
	INTOXONIA_FILES=
	INTOXONIA_DIRS=
	INTOXONIA_KSYMS="funces
			ixinit
			tricks
			kernel_unlink
			rootme
			hide_module
			find_sys_call_tbl"


	# Irix Rootkit (for Irix 6.x)
	IRIXRK_FILES=
	IRIXRK_DIRS="${RKHROOTDIR}/dev/pts/01
		     ${RKHROOTDIR}/dev/pts/01/backup
		     ${RKHROOTDIR}/dev/pts/01/etc
		     ${RKHROOTDIR}/dev/pts/01/tmp"
	IRIXRK_KSYMS=


	# Kitko Rootkit
	KITKO_FILES=
	KITKO_DIRS="${RKHROOTDIR}/usr/src/redhat/SRPMS/..."
	KITKO_KSYMS=


	# Knark Rootkit
	KNARK_FILES="${RKHROOTDIR}/proc/knark/pids"
	KNARK_DIRS="${RKHROOTDIR}/proc/knark"
	KNARK_KSYMS=


	# ld-linuxv.so (LD_PRELOAD shared library rootkit)
	LINUXV_FILES="${RKHROOTDIR}/lib/ld-linuxv.so.1"
	LINUXV_DIRS="${RKHROOTDIR}/var/opt/_so_cache
		     ${RKHROOTDIR}/var/opt/_so_cache/ld
		     ${RKHROOTDIR}/var/opt/_so_cache/lc"
	LINUXV_KSYMS=

	# Lion Worm
	LION_FILES="${RKHROOTDIR}/bin/in.telnetd
		    ${RKHROOTDIR}/bin/mjy
		    ${RKHROOTDIR}/usr/man/man1/man1/lib/.lib/mjy
		    ${RKHROOTDIR}/usr/man/man1/man1/lib/.lib/in.telnetd
		    ${RKHROOTDIR}/usr/man/man1/man1/lib/.lib/.x
		    ${RKHROOTDIR}/dev/.lib/lib/scan/1i0n.sh
		    ${RKHROOTDIR}/dev/.lib/lib/scan/hack.sh
		    ${RKHROOTDIR}/dev/.lib/lib/scan/bind
		    ${RKHROOTDIR}/dev/.lib/lib/scan/randb
		    ${RKHROOTDIR}/dev/.lib/lib/scan/scan.sh
		    ${RKHROOTDIR}/dev/.lib/lib/scan/pscan
		    ${RKHROOTDIR}/dev/.lib/lib/scan/star.sh
		    ${RKHROOTDIR}/dev/.lib/lib/scan/bindx.sh
		    ${RKHROOTDIR}/dev/.lib/lib/scan/bindname.log
		    ${RKHROOTDIR}/dev/.lib/lib/1i0n.sh
		    ${RKHROOTDIR}/dev/.lib/lib/lib/netstat
		    ${RKHROOTDIR}/dev/.lib/lib/lib/dev/.1addr
		    ${RKHROOTDIR}/dev/.lib/lib/lib/dev/.1logz
		    ${RKHROOTDIR}/dev/.lib/lib/lib/dev/.1proc
		    ${RKHROOTDIR}/dev/.lib/lib/lib/dev/.1file"
	LION_DIRS=
	LION_KSYMS=

	# LKH-1.1

	# Lockit (a.k.a. LJK2) Rootkit
	LOCKIT_FILES="${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_config
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_host_key.pub
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/ssh_random_seed*
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/sshd_config
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backdoor/RK1bd
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/du
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ifconfig
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/inetd.conf
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/locate
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/login
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ls
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/netstat
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/ps
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/pstree
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/rc.sysinit
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/syslogd
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/tcpd
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/backup/top
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1sauber
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/clean/RK1wted
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1parse
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hack/RK1sniff
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1addr
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1dir
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1log
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/.RK1proc
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/hide/RK1phidemod.c
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/README.modules
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1hidem.c
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/modules/RK1phide
		      ${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2/sshconfig/RK1ssh"
	LOCKIT_DIRS="${RKHROOTDIR}/usr/lib/libmen.oo/.LJK2"
	LOCKIT_KSYMS=


	# MRK (MiCrobul?) RootKit (based on Devil RootKit, also see Xzibit)
	MRK_FILES="${RKHROOTDIR}/dev/ida/.inet/pid
		   ${RKHROOTDIR}/dev/ida/.inet/ssh_host_key
		   ${RKHROOTDIR}/dev/ida/.inet/ssh_random_seed
		   ${RKHROOTDIR}/dev/ida/.inet/tcp.log"
	MRK_DIRS="${RKHROOTDIR}/dev/ida/.inet
		  ${RKHROOTDIR}/var/spool/cron/.sh"
	MRK_KSYMS=


	# Mood-NT Rootkit
	# Binary is by default called "mood-nt" but can be anywhere.
	# Here we look for collaterals, from include/prefs.h defaults
	# until sig-based dirscan() is added.
	MOODNT_FILES="${RKHROOTDIR}/sbin/init__mood-nt-_-_cthulhu
		      ${RKHROOTDIR}/_cthulhu/mood-nt.init
		      ${RKHROOTDIR}/_cthulhu/mood-nt.conf
		      ${RKHROOTDIR}/_cthulhu/mood-nt.sniff"
	MOODNT_DIRS="${RKHROOTDIR}/_cthulhu"
	MOODNT_KSYMS=


	# Ni0 Rootkit
	NIO_FILES="${RKHROOTDIR}/var/lock/subsys/...datafile.../...net...
		   ${RKHROOTDIR}/var/lock/subsys/...datafile.../...port...
		   ${RKHROOTDIR}/var/lock/subsys/...datafile.../...ps...
		   ${RKHROOTDIR}/var/lock/subsys/...datafile.../...file..."
	NIO_DIRS="${RKHROOTDIR}/tmp/waza
		  ${RKHROOTDIR}/var/lock/subsys/...datafile...
		  ${RKHROOTDIR}/usr/sbin/es"
	NIO_KSYMS=


	# Ohhara Rootkit
	OHHARA_FILES="${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile.../in.smbd.log"
	OHHARA_DIRS="${RKHROOTDIR}/var/lock/subsys/...datafile...
		     ${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile...
		     ${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile.../bin
		     ${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/bin
		     ${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile.../usr/sbin
		     ${RKHROOTDIR}/var/lock/subsys/...datafile.../...datafile.../lib/security"
	OHHARA_KSYMS=


	# Optic Kit (Tux variant) Rootkit
	OPTICKIT_FILES=
	OPTICKIT_DIRS="${RKHROOTDIR}/dev/tux
		       ${RKHROOTDIR}/usr/bin/xchk
		       ${RKHROOTDIR}/usr/bin/xsf
		       ${RKHROOTDIR}/usr/bin/ssh2d"
	OPTICKIT_KSYMS=


	# OSX Rootkit 0.2.1
	OSXRK_FILES="${RKHROOTDIR}/dev/.rk/nc
		     ${RKHROOTDIR}/dev/.rk/diepu
		     ${RKHROOTDIR}/dev/.rk/backd"
	OSXRK_DIRS="${RKHROOTDIR}/dev/.rk
		    ${RKHROOTDIR}/users/LDAP-daemon
		    ${RKHROOTDIR}/tmp/.work
		    ${RKHROOTDIR}/Library/StartupItems/opener"
	OSXRK_KSYMS=


	# Oz Rootkit
	OZ_FILES="${RKHROOTDIR}/dev/.oz/.nap/rkit/terror"
	OZ_DIRS="${RKHROOTDIR}/dev/.oz"
	OZ_KSYMS=


	# Phalanx Rootkit
	PHALANX_FILES="${RKHROOTDIR}/uNFuNF
		       ${RKHROOTDIR}/etc/host.ph1
		       ${RKHROOTDIR}/bin/host.ph1
		       ${RKHROOTDIR}/usr/share/.home.ph1/phalanx
		       ${RKHROOTDIR}/usr/share/.home.ph1/cb
		       ${RKHROOTDIR}/usr/share/.home.ph1/kebab"
	PHALANX_DIRS="${RKHROOTDIR}/usr/share/.home.ph1
		      ${RKHROOTDIR}/usr/share/.home.ph1/tty"
	PHALANX_KSYMS=


	# Phalanx2 Rootkit
	PHALANX2_FILES="${RKHROOTDIR}/etc/khubd.p2/.p2rc
		        ${RKHROOTDIR}/etc/khubd.p2/.phalanx2
		        ${RKHROOTDIR}/etc/khubd.p2/.sniff
		        ${RKHROOTDIR}/etc/khubd.p2/sshgrab.py
		        ${RKHROOTDIR}/etc/lolzz.p2/.p2rc
		        ${RKHROOTDIR}/etc/lolzz.p2/.phalanx2
		        ${RKHROOTDIR}/etc/lolzz.p2/.sniff
		        ${RKHROOTDIR}/etc/lolzz.p2/sshgrab.py
			${RKHROOTDIR}/etc/cron.d/zupzzplaceholder
			${RKHROOTDIR}/usr/lib/zupzz.p2/.p-2.3d
			${RKHROOTDIR}/usr/lib/zupzz.p2/.p2rc"
	PHALANX2_DIRS="${RKHROOTDIR}/etc/khubd.p2
		       ${RKHROOTDIR}/etc/lolzz.p2
		       ${RKHROOTDIR}/usr/lib/zupzz.p2"
	PHALANX2_KSYMS=

	# Portacelo Rootkit
	PORTACELO_FILES="${RKHROOTDIR}/var/lib/.../.ak
			 ${RKHROOTDIR}/var/lib/.../.hk
			 ${RKHROOTDIR}/var/lib/.../.rs
			 ${RKHROOTDIR}/var/lib/.../.p
			 ${RKHROOTDIR}/var/lib/.../getty
			 ${RKHROOTDIR}/var/lib/.../lkt.o
			 ${RKHROOTDIR}/var/lib/.../show
			 ${RKHROOTDIR}/var/lib/.../nlkt.o
			 ${RKHROOTDIR}/var/lib/.../ssshrc
			 ${RKHROOTDIR}/var/lib/.../sssh_equiv
			 ${RKHROOTDIR}/var/lib/.../sssh_known_hosts
			 ${RKHROOTDIR}/var/lib/.../sssh_pid ~/.sssh/known_hosts"
	PORTACELO_DIRS=
	PORTACELO_KSYMS=


	# R3dstorm Toolkit
	REDSTORM_FILES="${RKHROOTDIR}/var/log/tk02/see_all
			${RKHROOTDIR}/var/log/tk02/.scris
			${RKHROOTDIR}/bin/.../sshd/sbin/sshd1
			${RKHROOTDIR}/bin/.../hate/sk
			${RKHROOTDIR}/bin/.../see_all"
	REDSTORM_DIRS="${RKHROOTDIR}/var/log/tk02
		       ${RKHROOTDIR}/var/log/tk02/old
		       ${RKHROOTDIR}/bin/..."
	REDSTORM_KSYMS=


	# RH-Sharpe's Rootkit
	RHSHARPES_FILES="${RKHROOTDIR}/bin/lps
			 ${RKHROOTDIR}/usr/bin/lpstree
			 ${RKHROOTDIR}/usr/bin/ltop
			 ${RKHROOTDIR}/usr/bin/lkillall
			 ${RKHROOTDIR}/usr/bin/ldu
			 ${RKHROOTDIR}/usr/bin/lnetstat
			 ${RKHROOTDIR}/usr/bin/wp
			 ${RKHROOTDIR}/usr/bin/shad
			 ${RKHROOTDIR}/usr/bin/vadim
			 ${RKHROOTDIR}/usr/bin/slice
			 ${RKHROOTDIR}/usr/bin/cleaner
			 ${RKHROOTDIR}/usr/include/rpcsvc/du"
	RHSHARPES_DIRS=
	RHSHARPES_KSYMS=


	# RSHA's Rootkit
	RSHA_FILES="${RKHROOTDIR}/bin/kr4p
		    ${RKHROOTDIR}/usr/bin/n3tstat
		    ${RKHROOTDIR}/usr/bin/chsh2
		    ${RKHROOTDIR}/usr/bin/slice2
		    ${RKHROOTDIR}/usr/src/linux/arch/alpha/lib/.lib/.1proc
		    ${RKHROOTDIR}/etc/rc.d/arch/alpha/lib/.lib/.1addr"
	RSHA_DIRS="${RKHROOTDIR}/etc/rc.d/rsha
		   ${RKHROOTDIR}/etc/rc.d/arch/alpha/lib/.lib"
	RSHA_KSYMS=


	# Shutdown Rootkit
	# The '%' character represents a space.
	SHUTDOWN_FILES="${RKHROOTDIR}/usr/man/man5/..%/.dir/scannah/asus
			${RKHROOTDIR}/usr/man/man5/..%/.dir/see
			${RKHROOTDIR}/usr/man/man5/..%/.dir/nscd
			${RKHROOTDIR}/usr/man/man5/..%/.dir/alpd
			${RKHROOTDIR}/etc/rc.d/rc.local%"
	SHUTDOWN_DIRS="${RKHROOTDIR}/usr/man/man5/..%/.dir
		       ${RKHROOTDIR}/usr/man/man5/..%/.dir/scannah
		       ${RKHROOTDIR}/etc/rc.d/rc0.d/..%/.dir"
	SHUTDOWN_KSYMS=


	# Scalper (FreeBSD.Scalper.Worm) Worm
	SCALPER_FILES="${RKHROOTDIR}/tmp/.a
		       ${RKHROOTDIR}/tmp/.uua"
	SCALPER_DIRS=
	SCALPER_KSYMS=


	# SHV4 Rootkit
	SHV4_FILES="${RKHROOTDIR}/etc/ld.so.hash
		    ${RKHROOTDIR}/lib/libext-2.so.7
		    ${RKHROOTDIR}/lib/lidps1.so
		    ${RKHROOTDIR}/lib/libproc.a
		    ${RKHROOTDIR}/lib/libproc.so.2.0.6
		    ${RKHROOTDIR}/lib/ldd.so/tks
		    ${RKHROOTDIR}/lib/ldd.so/tkp
		    ${RKHROOTDIR}/lib/ldd.so/tksb
		    ${RKHROOTDIR}/lib/security/.config/sshd
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_host_key.pub
		    ${RKHROOTDIR}/lib/security/.config/ssh/ssh_random_seed
		    ${RKHROOTDIR}/usr/include/file.h
		    ${RKHROOTDIR}/usr/include/hosts.h
		    ${RKHROOTDIR}/usr/include/lidps1.so
		    ${RKHROOTDIR}/usr/include/log.h
		    ${RKHROOTDIR}/usr/include/proc.h
		    ${RKHROOTDIR}/usr/sbin/xntps
		    ${RKHROOTDIR}/dev/srd0"
	SHV4_DIRS="${RKHROOTDIR}/lib/ldd.so
		   ${RKHROOTDIR}/lib/security/.config
		   ${RKHROOTDIR}/lib/security/.config/ssh"
	SHV4_KSYMS=


	# SHV5 Rootkit
	SHV5_FILES="${RKHROOTDIR}/etc/sh.conf
		    ${RKHROOTDIR}/lib/libproc.a
		    ${RKHROOTDIR}/lib/libproc.so.2.0.6
		    ${RKHROOTDIR}/lib/lidps1.so
		    ${RKHROOTDIR}/lib/libsh.so/bash
		    ${RKHROOTDIR}/usr/include/file.h
		    ${RKHROOTDIR}/usr/include/hosts.h
		    ${RKHROOTDIR}/usr/include/log.h
		    ${RKHROOTDIR}/usr/include/proc.h
		    ${RKHROOTDIR}/lib/libsh.so/shdcf2
		    ${RKHROOTDIR}/lib/libsh.so/shhk
		    ${RKHROOTDIR}/lib/libsh.so/shhk.pub
		    ${RKHROOTDIR}/lib/libsh.so/shrs
		    ${RKHROOTDIR}/usr/lib/libsh/.bashrc
		    ${RKHROOTDIR}/usr/lib/libsh/shsb
		    ${RKHROOTDIR}/usr/lib/libsh/hide
		    ${RKHROOTDIR}/usr/lib/libsh/.sniff/shsniff
		    ${RKHROOTDIR}/usr/lib/libsh/.sniff/shp
		    ${RKHROOTDIR}/dev/srd0"
	SHV5_DIRS="${RKHROOTDIR}/lib/libsh.so
		   ${RKHROOTDIR}/usr/lib/libsh
		   ${RKHROOTDIR}/usr/lib/libsh/utilz
		   ${RKHROOTDIR}/usr/lib/libsh/.backup"
	SHV5_KSYMS=


	# Sin Rootkit
	SINROOTKIT_FILES="${RKHROOTDIR}/dev/.haos/haos1/.f/Denyed
			  ${RKHROOTDIR}/dev/ttyoa
			  ${RKHROOTDIR}/dev/ttyof
			  ${RKHROOTDIR}/dev/ttyop
			  ${RKHROOTDIR}/dev/ttyos
			  ${RKHROOTDIR}/usr/lib/.lib
			  ${RKHROOTDIR}/usr/lib/sn/.X
			  ${RKHROOTDIR}/usr/lib/sn/.sys
			  ${RKHROOTDIR}/usr/lib/ld/.X
			  ${RKHROOTDIR}/usr/man/man1/...
			  ${RKHROOTDIR}/usr/man/man1/.../.m
			  ${RKHROOTDIR}/usr/man/man1/.../.w"
	SINROOTKIT_DIRS="${RKHROOTDIR}/usr/lib/sn
			 ${RKHROOTDIR}/usr/lib/man1/...
			 ${RKHROOTDIR}/dev/.haos"
	SINROOTKIT_KSYMS=


	# Slapper Worm
	SLAPPER_FILES="${RKHROOTDIR}/tmp/.bugtraq
		       ${RKHROOTDIR}/tmp/.uubugtraq
		       ${RKHROOTDIR}/tmp/.bugtraq.c
		       ${RKHROOTDIR}/tmp/httpd
		       ${RKHROOTDIR}/tmp/.unlock
		       ${RKHROOTDIR}/tmp/update
		       ${RKHROOTDIR}/tmp/.cinik
		       ${RKHROOTDIR}/tmp/.b"
	SLAPPER_DIRS=
	SLAPPER_KSYMS=


	# Sneakin Rootkit
	SNEAKIN_FILES=
	SNEAKIN_DIRS="${RKHROOTDIR}/tmp/.X11-unix/.../rk"
	SNEAKIN_KSYMS=


	# 'Spanish' Rootkit
	SPANISH_FILES="${RKHROOTDIR}/dev/ptyq
		       ${RKHROOTDIR}/bin/ad
		       ${RKHROOTDIR}/bin/ava
		       ${RKHROOTDIR}/bin/server
		       ${RKHROOTDIR}/usr/sbin/rescue
		       ${RKHROOTDIR}/usr/share/.../chrps
		       ${RKHROOTDIR}/usr/share/.../chrifconfig
		       ${RKHROOTDIR}/usr/share/.../netstat
		       ${RKHROOTDIR}/usr/share/.../linsniffer
		       ${RKHROOTDIR}/usr/share/.../charbd
		       ${RKHROOTDIR}/usr/share/.../charbd2
		       ${RKHROOTDIR}/usr/share/.../charbd3
		       ${RKHROOTDIR}/usr/share/.../charbd4
		       ${RKHROOTDIR}/usr/man/tmp/update.tgz
		       ${RKHROOTDIR}/var/lib/rpm/db.rpm
		       ${RKHROOTDIR}/var/cache/man/.cat
		       ${RKHROOTDIR}/var/spool/lpd/remote/.lpq"
	SPANISH_DIRS="${RKHROOTDIR}/usr/share/..."
	SPANISH_KSYMS= 


	# Suckit Rootkit
	SUCKIT_FILES="${RKHROOTDIR}/sbin/initsk12
		      ${RKHROOTDIR}/sbin/initxrk
		      ${RKHROOTDIR}/usr/bin/null
		      ${RKHROOTDIR}/usr/share/locale/sk/.sk12/sk
		      ${RKHROOTDIR}/etc/rc.d/rc0.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc1.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc2.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc3.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc4.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc5.d/S23kmdac
		      ${RKHROOTDIR}/etc/rc.d/rc6.d/S23kmdac"
	SUCKIT_DIRS="${RKHROOTDIR}/dev/sdhu0/tehdrakg
		     ${RKHROOTDIR}/etc/.MG
		     ${RKHROOTDIR}/usr/share/locale/sk/.sk12
		     ${RKHROOTDIR}/usr/lib/perl5/site_perl/i386-linux/auto/TimeDate/.packlist"
	SUCKIT_KSYMS=


	# SunOS / NSDAP Rootkit
	NSDAP_FILES="${RKHROOTDIR}/dev/pts/01/55su
		     ${RKHROOTDIR}/dev/pts/01/55ps
		     ${RKHROOTDIR}/dev/pts/01/55ping
		     ${RKHROOTDIR}/dev/pts/01/55login
		     ${RKHROOTDIR}/dev/pts/01/PATCHER_COMPLETED
		     ${RKHROOTDIR}/dev/prom/sn.l
		     ${RKHROOTDIR}/dev/prom/dos
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/.kit
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/defines
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/patcher
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/pg
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/cleaner
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/utime
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/crypt
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/findkit
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/sn2
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/sniffload
		     ${RKHROOTDIR}/usr/lib/vold/nsdap/runsniff
		     ${RKHROOTDIR}/usr/lib/lpset
		     ${RKHROOTDIR}/usr/lib/lpstart
		     ${RKHROOTDIR}/usr/bin/mc68000
		     ${RKHROOTDIR}/usr/bin/mc68010
		     ${RKHROOTDIR}/usr/bin/mc68020
		     ${RKHROOTDIR}/usr/ucb/bin/ps
		     ${RKHROOTDIR}/usr/bin/m68k
		     ${RKHROOTDIR}/usr/bin/sun2
		     ${RKHROOTDIR}/usr/bin/mc68030
		     ${RKHROOTDIR}/usr/bin/mc68040
		     ${RKHROOTDIR}/usr/bin/sun3
		     ${RKHROOTDIR}/usr/bin/sun3x
		     ${RKHROOTDIR}/usr/bin/lso
		     ${RKHROOTDIR}/usr/bin/u370"
	NSDAP_DIRS="${RKHROOTDIR}/dev/pts/01
		    ${RKHROOTDIR}/dev/prom
		    ${RKHROOTDIR}/usr/lib/vold/nsdap
		    ${RKHROOTDIR}/.pat"
	NSDAP_KSYMS=


	# SunOS Rootkit
	SUNOSROOTKIT_FILES="${RKHROOTDIR}/etc/ld.so.hash
			    ${RKHROOTDIR}/lib/libext-2.so.7
			    ${RKHROOTDIR}/usr/bin/ssh2d
			    ${RKHROOTDIR}/bin/xlogin
			    ${RKHROOTDIR}/usr/lib/crth.o
			    ${RKHROOTDIR}/usr/lib/crtz.o
			    ${RKHROOTDIR}/sbin/login
			    ${RKHROOTDIR}/lib/security/.config/sn
			    ${RKHROOTDIR}/lib/security/.config/lpsched
			    ${RKHROOTDIR}/dev/kmod
			    ${RKHROOTDIR}/dev/dos"
	SUNOSROOTKIT_DIRS=
	SUNOSROOTKIT_KSYMS=


	# Superkit Rootkit (Suckit 1.3b-based)
	SUPERKIT_FILES="${RKHROOTDIR}/usr/man/.sman/sk/backsh
			${RKHROOTDIR}/usr/man/.sman/sk/izbtrag
			${RKHROOTDIR}/usr/man/.sman/sk/sksniff
			${RKHROOTDIR}/var/www/cgi-bin/cgiback.cgi"
	SUPERKIT_DIRS="${RKHROOTDIR}/usr/man/.sman/sk"
	SUPERKIT_KSYMS=


	# Telnet Backdoor
	TBD_FILES="${RKHROOTDIR}/usr/lib/.tbd"
	TBD_DIRS=
	TBD_KSYMS=


	# TeLeKiT Rootkit
	TELEKIT_FILES="${RKHROOTDIR}/usr/man/man3/.../TeLeKiT/bin/sniff
		       ${RKHROOTDIR}/usr/man/man3/.../TeLeKiT/bin/telnetd
		       ${RKHROOTDIR}/usr/man/man3/.../TeLeKiT/bin/teleulo
		       ${RKHROOTDIR}/usr/man/man3/.../cl
		       ${RKHROOTDIR}/dev/ptyr
		       ${RKHROOTDIR}/dev/ptyp
		       ${RKHROOTDIR}/dev/ptyq
		       ${RKHROOTDIR}/dev/hda06
		       ${RKHROOTDIR}/usr/info/libc1.so"
	TELEKIT_DIRS="${RKHROOTDIR}/usr/man/man3/...
		      ${RKHROOTDIR}/usr/man/man3/.../lsniff
		      ${RKHROOTDIR}/usr/man/man3/.../TeLeKiT"
	TELEKIT_KSYMS=


	# T0rn (and misc) Rootkit
	TORN_FILES="${RKHROOTDIR}/dev/.lib/lib/lib/t0rns
		    ${RKHROOTDIR}/dev/.lib/lib/lib/du
		    ${RKHROOTDIR}/dev/.lib/lib/lib/ls
		    ${RKHROOTDIR}/dev/.lib/lib/lib/t0rnsb
		    ${RKHROOTDIR}/dev/.lib/lib/lib/ps
		    ${RKHROOTDIR}/dev/.lib/lib/lib/t0rnp
		    ${RKHROOTDIR}/dev/.lib/lib/lib/find
		    ${RKHROOTDIR}/dev/.lib/lib/lib/ifconfig
		    ${RKHROOTDIR}/dev/.lib/lib/lib/pg
		    ${RKHROOTDIR}/dev/.lib/lib/lib/ssh.tgz
		    ${RKHROOTDIR}/dev/.lib/lib/lib/top
		    ${RKHROOTDIR}/dev/.lib/lib/lib/sz
		    ${RKHROOTDIR}/dev/.lib/lib/lib/login
		    ${RKHROOTDIR}/dev/.lib/lib/lib/in.fingerd
		    ${RKHROOTDIR}/dev/.lib/lib/lib/1i0n.sh
		    ${RKHROOTDIR}/dev/.lib/lib/lib/pstree
		    ${RKHROOTDIR}/dev/.lib/lib/lib/in.telnetd
		    ${RKHROOTDIR}/dev/.lib/lib/lib/mjy
		    ${RKHROOTDIR}/dev/.lib/lib/lib/sush
		    ${RKHROOTDIR}/dev/.lib/lib/lib/tfn
		    ${RKHROOTDIR}/dev/.lib/lib/lib/name
		    ${RKHROOTDIR}/dev/.lib/lib/lib/getip.sh
		    ${RKHROOTDIR}/usr/info/.torn/sh*
		    ${RKHROOTDIR}/usr/src/.puta/.1addr
		    ${RKHROOTDIR}/usr/src/.puta/.1file
		    ${RKHROOTDIR}/usr/src/.puta/.1proc
		    ${RKHROOTDIR}/usr/src/.puta/.1logz
		    ${RKHROOTDIR}/usr/info/.t0rn"
	TORN_DIRS="${RKHROOTDIR}/dev/.lib
		   ${RKHROOTDIR}/dev/.lib/lib
		   ${RKHROOTDIR}/dev/.lib/lib/lib
		   ${RKHROOTDIR}/dev/.lib/lib/lib/dev
		   ${RKHROOTDIR}/dev/.lib/lib/scan
		   ${RKHROOTDIR}/usr/src/.puta
		   ${RKHROOTDIR}/usr/man/man1/man1
		   ${RKHROOTDIR}/usr/man/man1/man1/lib
		   ${RKHROOTDIR}/usr/man/man1/man1/lib/.lib
		   ${RKHROOTDIR}/usr/man/man1/man1/lib/.lib/.backup"
	TORN_KSYMS=


	# trNkit Rootkit
	TRNKIT_FILES="${RKHROOTDIR}/usr/lib/libbins.la
		      ${RKHROOTDIR}/usr/lib/libtcs.so
		      ${RKHROOTDIR}/dev/.ttpy/ulogin.sh
		      ${RKHROOTDIR}/dev/.ttpy/tcpshell.sh
		      ${RKHROOTDIR}/dev/.ttpy/bupdu
		      ${RKHROOTDIR}/dev/.ttpy/buloc
		      ${RKHROOTDIR}/dev/.ttpy/buloc1
		      ${RKHROOTDIR}/dev/.ttpy/buloc2
		      ${RKHROOTDIR}/dev/.ttpy/stat
		      ${RKHROOTDIR}/dev/.ttpy/backps
		      ${RKHROOTDIR}/dev/.ttpy/tree
		      ${RKHROOTDIR}/dev/.ttpy/topk
		      ${RKHROOTDIR}/dev/.ttpy/wold
		      ${RKHROOTDIR}/dev/.ttpy/whoold
		      ${RKHROOTDIR}/dev/.ttpy/backdoors"
	TRNKIT_DIRS=
	TRNKIT_KSYMS=


	# Trojanit Kit Rootkit
	TROJANIT_FILES="${RKHROOTDIR}/bin/.ls
			${RKHROOTDIR}/bin/.ps
			${RKHROOTDIR}/bin/.netstat
			${RKHROOTDIR}/usr/bin/.nop
			${RKHROOTDIR}/usr/bin/.who"
	TROJANIT_DIRS=
	TROJANIT_KSYMS=


	# Tuxtendo (Tuxkit) Rootkit
	TUXTENDO_FILES="${RKHROOTDIR}/lib/libproc.so.2.0.7
			${RKHROOTDIR}/usr/bin/xchk
			${RKHROOTDIR}/usr/bin/xsf
			${RKHROOTDIR}/dev/tux/suidsh
			${RKHROOTDIR}/dev/tux/.addr
			${RKHROOTDIR}/dev/tux/.cron
			${RKHROOTDIR}/dev/tux/.file
			${RKHROOTDIR}/dev/tux/.log
			${RKHROOTDIR}/dev/tux/.proc
			${RKHROOTDIR}/dev/tux/.iface
			${RKHROOTDIR}/dev/tux/.pw
			${RKHROOTDIR}/dev/tux/.df
			${RKHROOTDIR}/dev/tux/.ssh
			${RKHROOTDIR}/dev/tux/.tux
			${RKHROOTDIR}/dev/tux/ssh2/sshd2_config
			${RKHROOTDIR}/dev/tux/ssh2/hostkey
			${RKHROOTDIR}/dev/tux/ssh2/hostkey.pub
			${RKHROOTDIR}/dev/tux/ssh2/logo
			${RKHROOTDIR}/dev/tux/ssh2/random_seed
			${RKHROOTDIR}/dev/tux/backup/crontab
			${RKHROOTDIR}/dev/tux/backup/df
			${RKHROOTDIR}/dev/tux/backup/dir
			${RKHROOTDIR}/dev/tux/backup/find
			${RKHROOTDIR}/dev/tux/backup/ifconfig
			${RKHROOTDIR}/dev/tux/backup/locate
			${RKHROOTDIR}/dev/tux/backup/netstat
			${RKHROOTDIR}/dev/tux/backup/ps
			${RKHROOTDIR}/dev/tux/backup/pstree
			${RKHROOTDIR}/dev/tux/backup/syslogd
			${RKHROOTDIR}/dev/tux/backup/tcpd
			${RKHROOTDIR}/dev/tux/backup/top
			${RKHROOTDIR}/dev/tux/backup/updatedb
			${RKHROOTDIR}/dev/tux/backup/vdir"
	TUXTENDO_DIRS="${RKHROOTDIR}/dev/tux
		       ${RKHROOTDIR}/dev/tux/ssh2
		       ${RKHROOTDIR}/dev/tux/backup"
	TUXTENDO_KSYMS=


	# Universal Rootkit by K2 (URK) Release 0.9.8
	URK_FILES="${RKHROOTDIR}/dev/prom/sn.l
		   ${RKHROOTDIR}/usr/lib/ldlibps.so
		   ${RKHROOTDIR}/usr/lib/ldlibnet.so
		   ${RKHROOTDIR}/dev/pts/01/uconf.inv
		   ${RKHROOTDIR}/dev/pts/01/cleaner
		   ${RKHROOTDIR}/dev/pts/01/bin/psniff
		   ${RKHROOTDIR}/dev/pts/01/bin/du
		   ${RKHROOTDIR}/dev/pts/01/bin/ls
		   ${RKHROOTDIR}/dev/pts/01/bin/passwd
		   ${RKHROOTDIR}/dev/pts/01/bin/ps
		   ${RKHROOTDIR}/dev/pts/01/bin/psr
		   ${RKHROOTDIR}/dev/pts/01/bin/su
		   ${RKHROOTDIR}/dev/pts/01/bin/find
		   ${RKHROOTDIR}/dev/pts/01/bin/netstat
		   ${RKHROOTDIR}/dev/pts/01/bin/ping
		   ${RKHROOTDIR}/dev/pts/01/bin/strings
		   ${RKHROOTDIR}/dev/pts/01/bin/bash
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/du
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/ls
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/passwd
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/ps
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/psr
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/su
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/find
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/netstat
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/ping
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/strings
		   ${RKHROOTDIR}/usr/man/man1/xxxxxxbin/bash
		   ${RKHROOTDIR}/tmp/conf.inv"
	URK_DIRS="${RKHROOTDIR}/dev/prom
		  ${RKHROOTDIR}/dev/pts/01
		  ${RKHROOTDIR}/dev/pts/01/bin
		  ${RKHROOTDIR}/usr/man/man1/xxxxxxbin"
	URK_KSYMS=
	# Also-see: /usr/lib/lpset (esniff), /var/lp/lpacct/ (files), /usr/lib/bnclp, /usr/lib/lpsys (identd),
	# Also-see: /usr/lib/lptd (backdoor?), /sbin/rc2 and /sbin/rc3 containing string "/usr/lib/lpstart",
	# Also-see: dos, psbnc, lpacct, USER, lp,
	# Also see: /etc/lpconfig vs /etc/ttyhash, uconv.inv vs urk.conf.


	# VcKit Rootkit
	VCKIT_FILES=
	VCKIT_DIRS="${RKHROOTDIR}/usr/include/linux/modules/lib.so
		    ${RKHROOTDIR}/usr/include/linux/modules/lib.so/bin"
	VCKIT_KSYMS=


	# Vampire Rootkit
	VAMPIRE_FILES=
	VAMPIRE_DIRS=
	VAMPIRE_KSYMS="new_getdents
			old_getdents
			should_hide_file_name
			should_hide_task_name"	


	# Volc Rootkit
	# Omit listing system binaries that should be picked up by changed hashes.
	VOLC_FILES="${RKHROOTDIR}/usr/bin/volc
		    ${RKHROOTDIR}/usr/lib/volc/backdoor/divine
		    ${RKHROOTDIR}/usr/lib/volc/linsniff
		    ${RKHROOTDIR}/etc/rc.d/rc1.d/S25sysconf
		    ${RKHROOTDIR}/etc/rc.d/rc2.d/S25sysconf
		    ${RKHROOTDIR}/etc/rc.d/rc3.d/S25sysconf
		    ${RKHROOTDIR}/etc/rc.d/rc4.d/S25sysconf
		    ${RKHROOTDIR}/etc/rc.d/rc5.d/S25sysconf"
	VOLC_DIRS="${RKHROOTDIR}/var/spool/.recent
		   ${RKHROOTDIR}/var/spool/.recent/.files
		   ${RKHROOTDIR}/usr/lib/volc
		   ${RKHROOTDIR}/usr/lib/volc/backup"
	VOLC_KSYMS=


	# weaponX 0.1
	WEAPONX_FILES="${RKHROOTDIR}/System/Library/Extensions/WeaponX.kext"
	WEAPONX_DIRS="${RKHROOTDIR}/tmp/..."
	WEAPONX_KSYMS=


	# WMKR26 2.0, WindEX, XND Crew, LKM for kernel 2.6
	# (2.6.12 -  2.6.19.2, i[456]86 and x86_64)
	# These files don't exist and can't be seen:
	# /proc/qwerty
	# /proc/givemeroot
	# /proc/hide+[PID]
	# /proc/hide-[PID]
	# /proc/active-
	# /proc/module_hide+
	# /proc/module_hide-
	# /proc/givemeinfo


	# Xzibit Rootkit (also see MRK (MiCrobul?) RootKit)
	XZIBIT_FILES="${RKHROOTDIR}/dev/dsx
		      ${RKHROOTDIR}/dev/caca
		      ${RKHROOTDIR}/dev/ida/.inet/linsniffer
		      ${RKHROOTDIR}/dev/ida/.inet/logclear
		      ${RKHROOTDIR}/dev/ida/.inet/sense
		      ${RKHROOTDIR}/dev/ida/.inet/sl2
		      ${RKHROOTDIR}/dev/ida/.inet/sshdu
		      ${RKHROOTDIR}/dev/ida/.inet/s
		      ${RKHROOTDIR}/dev/ida/.inet/ssh_host_key
		      ${RKHROOTDIR}/dev/ida/.inet/ssh_random_seed
		      ${RKHROOTDIR}/dev/ida/.inet/sl2new.c
		      ${RKHROOTDIR}/dev/ida/.inet/tcp.log
		      ${RKHROOTDIR}/home/httpd/cgi-bin/becys.cgi
		      ${RKHROOTDIR}/usr/local/httpd/cgi-bin/becys.cgi
		      ${RKHROOTDIR}/usr/local/apache/cgi-bin/becys.cgi
		      ${RKHROOTDIR}/www/httpd/cgi-bin/becys.cgi
		      ${RKHROOTDIR}/www/cgi-bin/becys.cgi"
	XZIBIT_DIRS="${RKHROOTDIR}/dev/ida/.inet"
	XZIBIT_KSYMS=


	# X-Org SunOS Rootkit
	XORGSUNOS_FILES="${RKHROOTDIR}/usr/lib/libX.a/bin/tmpfl
			 ${RKHROOTDIR}/usr/lib/libX.a/bin/rps
			 ${RKHROOTDIR}/usr/bin/srload
			 ${RKHROOTDIR}/usr/lib/libX.a/bin/sparcv7/rps
			 ${RKHROOTDIR}/usr/sbin/modcheck"
	XORGSUNOS_DIRS="${RKHROOTDIR}/usr/lib/libX.a
			${RKHROOTDIR}/usr/lib/libX.a/bin
			${RKHROOTDIR}/usr/lib/libX.a/bin/sparcv7
			${RKHROOTDIR}/usr/share/man..."
	XORGSUNOS_KSYMS=


	# zaRwT.KiT Rootkit
	ZARWT_FILES="${RKHROOTDIR}/dev/rd/s/sendmeil
		     ${RKHROOTDIR}/dev/ttyf
		     ${RKHROOTDIR}/dev/ttyp
		     ${RKHROOTDIR}/dev/ttyn
		     ${RKHROOTDIR}/rk/tulz"
	ZARWT_DIRS="${RKHROOTDIR}/rk
		    ${RKHROOTDIR}/dev/rd/s"
	ZARWT_KSYMS=


	# ZK Rootkit
	ZK_FILES="${RKHROOTDIR}/usr/share/.zk/zk
		  ${RKHROOTDIR}/usr/X11R6/.zk/xfs
		  ${RKHROOTDIR}/usr/X11R6/.zk/echo
		  ${RKHROOTDIR}/etc/1ssue.net
		  ${RKHROOTDIR}/etc/sysconfig/console/load.zk"
	ZK_DIRS="${RKHROOTDIR}/usr/share/.zk
		 ${RKHROOTDIR}/usr/X11R6/.zk"
	ZK_KSYMS=


	# Miscellaneous login backdoors
	LOGIN_BACKDOOR_FILES="${RKHROOTDIR}/bin/.login
			      ${RKHROOTDIR}/sbin/.login"


	# Suspicious directories
	SUSPICIOUS_DIRS="${RKHROOTDIR}/usr/X11R6/bin/.,/copy
			 ${RKHROOTDIR}/dev/rd/cdb"


	# Evil strings
	STRINGSCAN="crond:LOGNAME=root:Illogic Rootkit
		    hostname:phalanx:Phalanx Rootkit
		    init:/dev/proc/fuckit:Fuckit Rootkit
		    init:FUCK:Possible Suckit Rootkit found
		    init:backdoor:Possible backdoored init file (Suckit)
		    init:/usr/bin/rcpc:Portacelo Rootkit
		    init:/usr/sbin/login:trNkit ulogin
		    killall:/dev/ptyxx/.proc:Ambient (ark) Rootkit
		    login:vt200:Possible Linux Rootkit (LRK4)
		    login:/usr/bin/xstat:Possible Linux Rootkit (LRK4)
		    login:/bin/envpc:Possible Linux Rootkit (LRK4)
		    login:L4m3r0x:Possible Linux Rootkit (LRK4)
		    login:/lib/libext:SHV4 Rootkit
		    login:/usr/sbin/login:Flea Linux Rootkit
		    login:/usr/lib/.tbd:TBD Rootkit
		    login:sendmail:Ambient (ark) Rootkit
		    login:cocacola:cb Rootkit
		    login:joao:Spanish Rootkit
		    ls:/dev/ptyxx/.file:Dica-Kit Rootkit
		    ls:/dev/ptyxx/.file:Ambient (ark) Rootkit
		    ls:/dev/sgk:Possible Linux Rootkit (LRK4)
		    ls:/var/lock/subsys/...datafile...:Ohhara Rootkit
		    ls:/usr/lib/.tbd:TBD Rootkit
		    netstat:/dev/proc/fuckit:Fuckit Rootkit
		    netstat:/lib/.sso:Dica-Kit Rootkit
		    netstat:/var/lock/subsys/...datafile...:Ohhara Rootkit
		    netstat:/dev/caca:MRK Rootkit
		    netstat:/dev/ttyoa:Sin Rootkit
		    netstat:/usr/lib/ldlibns.so:Flea Linux Rootkit
		    netstat:/dev/ptyxx/.addr:Ambient (ark) Rootkit
		    netstat:syg:Possible trojaned netstat
		    nscd:sshd_config:Possible backdoor shell installed (SSH)
                    ps:/var/lock/subsys/...datafile...:Ohhara Rootkit or Ni0 Rootkit
		    ps:/dev/pts/01:Universal Rootkit (URK)
		    ps:tw33dl3:SunOS Rootkit
		    ps:psniff:SunOS Rootkit
		    ps:uconf.inv:Universal Rootkit (URK)
		    ps:lib/ldlibps.so:Flea Linux Rootkit or Universal Rootkit (URK)
		    pstree:/usr/lib/ldlibpst.so:Flea Linux Rootkit
		    ps:/var/lock/subsys/...datafile...:Ohhara Rootkit or Ni0 Rootkit
		    ps:libproc.so.2.0.7:Fuckit Rootkit
		    ps:/dev/ptyxx/.proc:Ambient (ark) Rootkit
		    pstree:/dev/ptyxx/.proc:Ambient (ark) Rootkit
		    pgrep:libproc.so.2.0.7:Fuckit Rootkit
		    pkill:libproc.so.2.0.7:Fuckit Rootkit
		    ping:/bin/bash:Ping rootkit or other backdoor
		    rpc.nfsd:cant open log:Possible sniffer installed
		    rpc.nfsd:sniff.pid:Possible sniffer installed
		    rpc.nfsd:tcp.log:Possible sniffer installed
		    sshd:/dev/ptyxx:OpenBSD Rootkit
		    sshd:/.config:SHV4 Rootkit
		    sshd:+\\$.*\\$\!.*\!\!\\$:Possible backdoored ssh daemon installed
		    xntps:/.config:SHV4 Rootkit
		    syslogd:promiscuous:Possible sniffer installed
		    syslogd:/usr/lib/.tbd:TBD Rootkit
		    syslogd:/dev/ptyxx/.log:Ambient (ark) Rootkit
		    tcpd:/dev/xdta:Dica-Kit Rootkit
		    top:/usr/lib/.tbd:TBD Rootkit
		    top:/dev/ptyxx/.proc:Ambient (ark) Rootkit
		    xtty:/bin/sh:Possible backdoor shell installed
		    ttymon:fucknut:SHV5 Rootkit
		    ttymon:lamersucks:SHV5 Rootkit
		    ttymon:skillz:SHV5 Rootkit
		    ttyload:/sbin/ttyload:SHV5 Rootkit
		    ttyload:/sbin/ttymon:SHV5 Rootkit
		    ttyload:propert of SH:SHV5 Rootkit
		    rcfile:in.inetd:SHV4 Rootkit
		    rcfile:+#<HIDE_.*>:Enye LKM
		    rcfile:bin/xchk:Optic Kit (Tux) Worm
		    rcfile:bin/xsf:Optic Kit (Tux) Worm
		    rcfile:/usr/bin/ssh2d:Flea Linux Rootkit or Optic Kit (Tux variant) Rootkit or SunOS Rootkit 
		    rcfile:/usr/sbin/xntps:SHV4 Rootkit
		    rcfile:ttyload:Possible SHV5 Rootkit
		    rcfile:/etc/rc.d/init.d/init:cb Rootkit or w00tkit Rootkit
		    rcfile:usr/bin/xfss:Devil Rootkit
		    rcfile:/usr/sbin/rpc.netinet:FreeBSD (FBRK) Rootkit
		    rcfile:/usr/lib/.fx/cons.saver:FreeBSD (FBRK) Rootkit
		    rcfile:/usr/lib/.fx/xs:FreeBSD (FBRK) Rootkit
		    rcfile:/ssh2d:Illogic Rootkit or SunOS Rootkit
		    rcfile:/dev/kmod:Illogic Rootkit or SunOS Rootkit
		    rcfile:/crth.o:Illogic Rootkit or SunOS Rootkit
		    rcfile:/crtz.o:Illogic Rootkit or SunOS Rootkit
		    rcfile:/dev/dos:Illogic Rootkit or SunOS Rootkit
		    rcfile:/lpq:Illogic Rootkit or SunOS Rootkit
		    rcfile:/usr/sbin/rescue:Spanish Rootkit
		    rcfile:/usr/lib/lpstart:SunOS NSDAP Rootkit or Universal Rootkit (URK)
		    rcfile:/volc:Volc Rootkit
		    rcfile:sourcemask:Possible rootkit component
		    rcfile:/bin/vobiscum:Possible rootkit component
		    rcfile:/usr/sbin/in.telnet:Possible rootkit component
		    rcfile:hdparm:Xzibit Rootkit
		    ssh:/lib/ldd.so/tkps:SHV4 Rootkit
		    ssh1:/lib/ldd.so/tkps:SHV4 Rootkit
		    ssh:t0rnkit:Possible T0rn Rootkit
		    ssh:/dev/proc/fuckit:Fuckit Rootkit
		    skill:libproc.so.2.0.7:Fuckit Rootkit
		    snice:libproc.so.2.0.7:Fuckit Rootkit
		    top:libproc.so.2.0.7:Fuckit Rootkit
		    slocate:/usr/lib/ldlibct.so:Flea Linux Rootkit
		    locate:/usr/lib/ldlibct.so:Flea Linux Rootkit
		    du:/usr/lib/ldlibdu.so:Flea Linux Rootkit
		    du:/dev/ptyxx/.file:Ambient (ark) Rootkit
		    w:libproc.so.2.0.7:Fuckit Rootkit
		    xlogin:/lib/libext:SHV4 Rootkit
		    hdparm:/dev/ida/.inet:Xzibit Rootkit"


	# Possible rootkit files and directories
	FILESCAN="file:${RKHROOTDIR}/dev/sdr0:Possible T0rn Rootkit MD5 hash database
		  file:${RKHROOTDIR}/dev/pisu:Possible rootkit component
		  file:${RKHROOTDIR}/dev/xdta:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/dev/saux:Trojaned SSH daemon sniffer log
		  file:${RKHROOTDIR}/dev/hdx:Possible Linux.RST.B infection
		  file:${RKHROOTDIR}/dev/hdx1:Possible Linux.RST.B infection
		  file:${RKHROOTDIR}/dev/hdx2:Possible Linux.RST.B infection
		  file:${RKHROOTDIR}/dev/ptyy:Possible rootkit component
		  file:${RKHROOTDIR}/dev/ptyu:Possible rootkit component
		  file:${RKHROOTDIR}/dev/ptyv:Possible rootkit component
		  file:${RKHROOTDIR}/dev/hdbb:Possible rootkit component
		  file:${RKHROOTDIR}/tmp/.syshackfile:Trojaned syslog daemon
		  file:${RKHROOTDIR}/tmp/.bash_history:Possible Lite5-r Rootkit
		  file:${RKHROOTDIR}/usr/info/.clib:Possible backdoor
		  file:${RKHROOTDIR}/usr/sbin/tcp.log:Possible sniffer log
		  file:${RKHROOTDIR}/usr/bin/take/pid:Trojaned SSH daemon
		  file:${RKHROOTDIR}/sbin/create:MzOzD Local backdoor
		  file:${RKHROOTDIR}/dev/ttypz:spwn login backdoor
		  file:${RKHROOTDIR}/var/log/tcp.log:Possible beX2 Rootkit component
		  file:${RKHROOTDIR}/usr/include/audit.h:Possible beX2 Rootkit component
		  file:${RKHROOTDIR}/usr/bin/sourcemask:Possible rootkit component
		  file:${RKHROOTDIR}/usr/bin/ras2xm:Possible rootkit component
		  file:${RKHROOTDIR}/dev/xmx:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/usr/sbin/gpm.root:Possible rootkit component
		  file:${RKHROOTDIR}/bin/vobiscum:Possible rootkit component
		  file:${RKHROOTDIR}/bin/psr:Possible rootkit component
		  file:${RKHROOTDIR}/dev/kdx:Possible rootkit component
		  file:${RKHROOTDIR}/dev/dkx:Possible rootkit component
		  file:${RKHROOTDIR}/usr/sbin/sshd3:Possible rootkit component
		  file:${RKHROOTDIR}/usr/sbin/jcd:Possible rootkit component
		  file:${RKHROOTDIR}/etc/rc.d/init.d/jcd:Possible rootkit component
		  file:${RKHROOTDIR}/usr/sbin/atd2:Possible rootkit component
		  file:${RKHROOTDIR}/home/httpd/cgi-bin/linux.cgi:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/home/httpd/cgi-bin/psid:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/home/httpd/cgi-bin/void.cgi:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/etc/rc.d/init.d/system:Possible rootkit component
		  file:${RKHROOTDIR}/etc/rc.d/rc3.d/S93users:Possible rootkit component
		  file:${RKHROOTDIR}/tmp/.ush:Dica-Kit Rootkit
		  file:${RKHROOTDIR}/usr/lib/libhidefile.so:HIDEFILE envvar filehiding library
		  file:${RKHROOTDIR}/etc/cron.d/kmod:Illogic Rootkit
		  file:${RKHROOTDIR}/usr/lib/dmis/dmisd:Trojaned SSH daemon
		  file:${RKHROOTDIR}/lib/secure/libhij.so:Solaris Trojaned SSH daemon
		  file:${RKHROOTDIR}/usr/sbin/sshd3:Possible rootkit component
		  file:${RKHROOTDIR}/etc/rc.d/init.d/crontab:Possible rootkit component
		  file:${RKHROOTDIR}/etc/rc.d/init.d/jcd:Possible rootkit component
		  file:${RKHROOTDIR}/usr/sbin/atd2:Possible rootkit component
		  file:${RKHROOTDIR}/etc/rc.d/rc5.d/S93users:Possible rootkit component
		  dir:${RKHROOTDIR}/dev/ptyas:Langsuir installation directory
		  dir:${RKHROOTDIR}/usr/bin/take:Trojaned SSH daemon
		  dir:${RKHROOTDIR}/usr/src/.lib:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/share/man/man1/.1c:Possible Eggdrop installed
		  dir:${RKHROOTDIR}/lib/lblip.tk:Possible T0rn Rootkit directory with backdoored SSH-configuration
		  dir:${RKHROOTDIR}/usr/sbin/...:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/share/.gun:Possible rootkit component
		  dir:${RKHROOTDIR}/unde/vrei/tu/sa/te/ascunzi/in/server:Unknown rootkit
		  dir:${RKHROOTDIR}/usr/man/man1/..  /.dir:Unknown rootkit
		  dir:${RKHROOTDIR}/usr/X11R6/include/X11/...:Unknown rootkit
		  dir:${RKHROOTDIR}/usr/X11R6/lib/X11/.fonts/misc/...:Unknown rootkit
		  dir:${RKHROOTDIR}/tmp/.sys:Possible rootkit component
		  dir:${RKHROOTDIR}/tmp/':Possible rootkit component
		  dir:${RKHROOTDIR}/tmp/.,:Possible rootkit component
		  dir:${RKHROOTDIR}/tmp/,.,:Possible rootkit component
		  dir:${RKHROOTDIR}/dev/shm/emilien:Possible rootkit component
		  dir:${RKHROOTDIR}/var/tmp/.log:Possible rootkit component
		  dir:${RKHROOTDIR}/tmp/zmeu/... :Possible rootkit component
		  dir:${RKHROOTDIR}/var/log/ssh:Possible rootkit component
		  dir:${RKHROOTDIR}/dev/ida:Possible rootkit component
		  dir:${RKHROOTDIR}/lib/java:Possible rootkit component
		  dir:${RKHROOTDIR}/var/lib/games/.src/ssk/shit:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/lib/libshtift:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/src/.poop:Ramen worm
		  dir:${RKHROOTDIR}/dev/wd4:possible IRC bot software
		  dir:${RKHROOTDIR}/var/run/.tmp:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/man/man1/lib/.lib:Possible rootkit component
		  dir:${RKHROOTDIR}/dev/portd:Possible rootkit component
		  dir:${RKHROOTDIR}/dev/...:Possible rootkit component
		  dir:${RKHROOTDIR}/usr/share/man/mansps:Possible rootkit component
		  dir:${RKHROOTDIR}/lib/.so:Possible rootkit component
		  dir:${RKHROOTDIR}/lib/.sso:Possible rootkit component"


	# Evil strings for FreeBSD KLD (Dynamic Kernel Linker modules)
	KLDSTATKEYWORDS="backd00r backdoor darkside nekit rpldev rpldev_mod spapem_core spapem_genr00t"


	# Suspicious startup file strings
	RCLOCAL_STRINGS="/usr/bin/rpc.wall:Possible Linux Rootkit (LRK4)
			 sshdd:Possible GasKit rootkit
			 hidef:Possible part of Knark rootkit
			 /usr/bin/.etc:Dica-Kit Rootkit"


	# Suspicious open files
	SUSP_FILES_INFO="backdoor:Generic backdoor
			 adore.o:Adore kernel module
			 mod_rootme.so:Apache mod_rootme backdoor
			 phide_mod.o:Process hiding kernel module
			 lbk.ko:LBK FreeBSD kernel module
			 vlogger.o:THC-Vlogger kernel module
			 cleaner.o:Adore kernel module
			 cleaner:Possible Adore rootkit component
			 ava:Possible Adore rootkit component
			 tzava:Possible Adore rootkit component
			 mod_klgr.o:klgr, keyboard logger (kernel module)
			 hydra:THC-Hydra (password capture)
			 hydra.restore:THC-Hydra (password capture)
			 ras2xm:Unknown rootkit
			 vobiscum:Unknown rootkit
			 sshd3:Unknown rootkit
			 system:Unknown rootkit
			 t0rnsb:T0rn
			 t0rns:T0rn
			 t0rnp:T0rn
			 rx4u:Unknown rootkit
			 rx2me:Unknown rootkit
			 crontab:Unknown rootkit
			 sshdu:Unknown rootkit
			 glotzer:Unknown rootkit
			 holber:Devil rootkit component
			 xhide:Process hiding software
			 xh:possible XHide alternative name
			 emech:IRC bot software
			 psybnc:IRC bot software
			 mech:possible IRC bot software alternative name
			 httpd.bin:possible IRC bot software alternative name
			 mh:Dica-Kit Rootkit IRC bot software
			 xl:Dica-Kit Rootkit
			 write:Dica-Kit Rootkit
			 Phantasmagoria.o:Process hiding Linux kernel module
			 lkt.o:Portacelo Rootkit
			 nlkt.o:Portacelo Rootkit"


	# System startup file pathnames
	RCLOCATIONS="/etc/rc.d
		     /etc/rc.local
		     /usr/local/etc/rc.d
		     /usr/local/etc/rc.local
		     /etc/conf.d/local.start
		     /etc/init.d
		     /etc/inittab"


	# Integrity tests
	STRINGS_INTEGRITY="${BOBKIT_FILES} ${BOBKIT_DIRS} ${CINIK_FILES}
			   ${CINIK_DIRS} ${DICA_FILES} ${FREEBSD_RK_FILES}
			   ${TBD_FILES} ${TORN_FILES} ${TORN_DIRS}"


	SNIFFER_FILES="${RKHROOTDIR}/usr/lib/libice.log
		       ${RKHROOTDIR}/dev/prom/sn.l
		       ${RKHROOTDIR}/dev/fd/.88/zxsniff.log"


	# Known bad Linux kernel modules
	LKM_BADNAMES="adore.o
		      bkit-adore.o
		      cleaner.o
		      flkm.o
		      knark.o
		      modhide.o
		      mod_klgr.o
		      phide_mod.o
		      vlogger.o
		      p2.ko
		      rpldev.o
		      xC.o
		      strings.o
		      wkmr26.ko"

	return
}


strings_check() {

	#
	# This function carries out the 'strings' command check.
	# It passes specific strings through the strings command to
	# see if they are missing. If so, then it can indicate that
	# the command has been modified to hide information.
	#

	if `check_test strings`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 STRINGS_CHECK_START
		display --to LOG --type INFO STARTING_TEST strings
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST strings
		return
	fi


	#
	# First check to see if we have a 'strings' command.
	#

	if [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 STRINGS_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "strings"
		return
	fi


	#
	# The pathnames to check will have the RKHROOTDIR at
	# the front. We need to strip this off before passing
	# it through the 'strings' command. If we didn't then
	# we would be looking for the wrong pathname.
	#

	STRINGSFAILED=0

	RDIR=`echo "${RKHROOTDIR}" | sed -e 's/\//\\\\\//g'`

	for STRING in ${STRINGS_INTEGRITY}; do
		STRING=`echo "${STRING}" | sed -e "s:^${RDIR}::"`

		STRINGNAME=`echo "${STRING}" | sed -e 's/\./\\\./g'`
		STRING_SEEN=`echo "${STRING}" | ${STRINGS_CMD} | grep "${STRINGNAME}" | tr -d ' '`

		if [ -z "${STRING_SEEN}" ]; then
			STRINGSFAILED=1
			display --to LOG --type WARNING --result WARNING STRINGS_SCANNING_BAD "${STRING}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result OK STRINGS_SCANNING_OK "${STRING}"
		fi
	done


	if [ $STRINGSFAILED -eq 0 ]; then
		RKHTMPVAR="SCREEN"
		test $VERBOSE_LOGGING -eq 0 && RKHTMPVAR="SCREEN+LOG"

		display --to "${RKHTMPVAR}" --type PLAIN --result OK --color GREEN --screen-indent 4 STRINGS_CHECK
	else
		display --to SCREEN --type PLAIN --result WARNING --color RED --screen-indent 4 STRINGS_CHECK
	fi

	return
}


shared_libs_check() {

	#
	# This function checks shared library loading problems.
	# It is part of do_system_commands_checks and should precede or run
	# just after strings_check if enabled.
	#

	#
	# Remarks:
	# Oracle-10.1.0.3 on RHEL3 needs /etc/libcwait.so,
	# F-PROT Antivirus for GNU/Linux needs f-prot.so,
	# AVAYA Labs "stack overflow protection" uses libsafe.
	#

	if `check_test shared_libs`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 SHARED_LIBS_START
		display --to LOG --type INFO STARTING_TEST shared_libs
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST shared_libs
		return
	fi


	#
	# First check for preloading exported variables.
	#

	VARFOUND=""

	for RKHTMPVAR in LD_PRELOAD LD_AOUT_PRELOAD LD_ELF_PRELOAD; do
		RKHTMPVAR_RES=`eval echo "\\$${RKHTMPVAR}"`

		test -n "${RKHTMPVAR_RES}" && VARFOUND="${VARFOUND} ${RKHTMPVAR}"
	done

	if [ -z "${VARFOUND}" ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PRELOAD_VAR
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PRELOAD_VAR
		display --to LOG --type WARNING SHARED_LIBS_PRELOAD_VAR_FOUND "${VARFOUND}"
	fi


	#
	# Next check for a preload file.
	#

	RKHTMPVAR=${RKHROOTDIR}/etc/ld.so.preload

	if [ -s ${RKHTMPVAR} ]; then
		RKHLIBLIST=""

		display --to LOG --type INFO SHARED_LIBS_PRELOAD_FILE_FOUND "${RKHTMPVAR}"

		for FNAME in `cat ${RKHTMPVAR}`; do
			FNAMEGREP=`echo "${FNAME}" | sed -e 's/\./\\\./g'`

			if [ -z "`echo \"${SHARED_LIB_WHITELIST}\" | grep \" ${FNAMEGREP} \"`" ]; then
				RKHLIBLIST="${RKHLIBLIST} ${FNAME}"
			else
				display --to LOG --type INFO SHARED_LIBS_PRELOAD_LIB_WLIST "${FNAME}"
			fi
		done

		if [ -n "${RKHLIBLIST}" ]; then
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PRELOAD_FILE

			for FNAME in ${RKHLIBLIST}; do
				display --to LOG --type WARNING SHARED_LIBS_PRELOAD_LIB_FOUND "${FNAME}"
			done
		else
			display --to SCREEN+LOG --type PLAIN --result WHITELISTED --color GREEN --screen-indent 4 SHARED_LIBS_PRELOAD_FILE
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PRELOAD_FILE
	fi


	#
	# Finally we check the LD_LIBRARY_PATH. This check may be
	# disabled by the user if the 'ldd' command is not available.
	#

	if `check_test shared_libs_path`; then
		display --to LOG --type INFO STARTING_TEST shared_libs_path

		if [ -n "${LDD_CMD}" ]; then
			if [ -n "${LD_LIBRARY_PATH}" ]; then
				LD_LIBR_FAILED=0
				RKHTMPVAR_BIN=""
				LD_LIBRARY_PATH_SAVED="${LD_LIBRARY_PATH}"

				if [ -z "${MD5_CMD}" ]; then
					MD5_CMD=`find_cmd md5sum`
					test -z "${MD5_CMD}" && MD5_CMD=`find_cmd md5`
				fi

				LS_CMD=`find_cmd ls`

				for RKHTMPVAR in FIND PS STRINGS MD5 LS STAT; do
					RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`
					RKHTMPVAR=`echo "${RKHTMPVAR}" | cut -d' ' -f1`

					RKHTMPVAR_BIN="${RKHTMPVAR_BIN} ${RKHTMPVAR}"
				done

				for RKHTMPVAR in ${RKHTMPVAR_BIN}; do
					LD_LIBRARY_PATH="${LD_LIBRARY_PATH_SAVED}"
					export LD_LIBRARY_PATH
					RKHTMPVAR_WITH=`${LDD_CMD} ${RKHTMPVAR} | sed -e 's/(0x[0-9a-f]*)/0xHEX/' 2>&1`

					unset LD_LIBRARY_PATH
					RKHTMPVAR_WITHOUT=`${LDD_CMD} ${RKHTMPVAR} | sed -e 's/(0x[0-9a-f]*)/0xHEX/' 2>&1`

					if [ "${RKHTMPVAR_WITH}" != "${RKHTMPVAR_WITHOUT}" ]; then
						#
						# Testing one command should be "evidence" enough.
						#

						LD_LIBR_FAILED=1
						break
					fi
				done


				#
				# Reset things to the way they were before.
				#

				LD_LIBRARY_PATH="${LD_LIBRARY_PATH_SAVED}"
				export LD_LIBRARY_PATH


				if [ $LD_LIBR_FAILED -eq 0 ]; then
					display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 SHARED_LIBS_PATH
				else
					display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SHARED_LIBS_PATH
					display --to LOG --type WARNING SHARED_LIBS_PATH_BAD "${LD_LIBRARY_PATH}"
				fi
			else
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 SHARED_LIBS_PATH
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 SHARED_LIBS_PATH
			display --to LOG --type INFO NOT_FOUND_CMD "ldd"
		fi
	else
		display --to LOG --type INFO USER_DISABLED_TEST shared_libs_path
	fi

	return
}


file_properties_check() {

	#
	# This function carries out a check of system command property
	# values checked against their previous value, which is stored
	# in the rkhunter.dat file. Other checks work on the current
	# file, and do not use any previously stored value (for example,
	# the immutable-bit check).
	#

	#
	# Each test will set the variable TEST_RESULT, and use it to
	# display the actual result. Typically a null string indicates
	# 'OK', and anything else is a 'Warning'.
	#

	TEST_RESULT=""
	WHITELIST_RESULT=""
	SKIP_ATTR=0; SKIP_HASH=0; SKIP_IMMUT=0; SKIP_SCRIPT=0
	USE_DAT_FILE=1
	SKIP_IMMUT_OS=0
	PROP_FILE_LIST_COUNT=0

	#
	# In order to disable the whole test we have to check if
	# each specific test has been disabled.
	#

	for RKHTMPVAR in attributes hashes immutable scripts; do
		if ! `check_test ${RKHTMPVAR}`; then
			case "${RKHTMPVAR}" in
			attributes)
				SKIP_ATTR=1
				;;
			hashes)
				SKIP_HASH=1
				;;
			immutable)
				SKIP_IMMUT=1
				;;
			scripts)
				SKIP_SCRIPT=1
				;;
			esac
		fi
	done

	#
	# The immutable-bit test is only applicable to Linux and
	# BSD systems. We need to disable the test, but not have
	# it logged as if the user had disabled it (that would be
	# confusing).
	#

	if [ $BSDOS -eq 0 -a "${OPERATING_SYSTEM}" != "Linux" ]; then
		if [ $SKIP_IMMUT -eq 0 ]; then
			SKIP_IMMUT=1
			SKIP_IMMUT_OS=1
		fi
	fi

	if ! `check_test properties`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST properties
		return
	elif [ $SKIP_ATTR -eq 1 -a $SKIP_HASH -eq 1 -a $SKIP_IMMUT -eq 1 -a $SKIP_SCRIPT -eq 1 ]; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST properties
		return
	else
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 FILE_PROP_START
		display --to LOG --type INFO STARTING_TEST properties
	fi


	#
	# If the user wants to skip a test then log it.
	#

	for RKHTMPVAR in attributes hashes immutable scripts; do
		case "${RKHTMPVAR}" in
		attributes)
			TEST_NAME=$SKIP_ATTR
			;;
		hashes)
			TEST_NAME=$SKIP_HASH
			;;
		scripts)
			TEST_NAME=$SKIP_SCRIPT
			;;
		immutable)
			TEST_NAME=0
			test $SKIP_IMMUT_OS -eq 0 && TEST_NAME=$SKIP_IMMUT
			;;
		esac

		test $TEST_NAME -eq 1 && display --to LOG --type INFO USER_DISABLED_TEST ${RKHTMPVAR}
	done


	#
	# The first test we do is on the commands needed to
	# perform all the file checks. If the user has not
	# disabled any test, and a command is missing, then
	# we must let them know that without marking each file
	# test as a 'Warning' (because that could hide a real
	# problem). We include checks on the rkhunter.dat file
	# as well.
	#

	RKHTMPVAR=""

	if [ $SKIP_ATTR -eq 0 -a -z "${STAT_CMD}" ]; then
		SKIP_ATTR=1
		RKHTMPVAR="${RKHTMPVAR} attr"
	fi

	if [ $SKIP_HASH -eq 0 ]; then
		# Not sure about this one...!
		if [ -z "${OLD_PKGMGR}" -a -s ${RKHDAT_FILE} -a "${HASH_FUNC}" != "NONE" -a \( "${OLD_HASH_FUNC}" = "NONE" -o "${OLD_HASH_FUNC}" = "Disabled" -o -z "${OLD_HASH_FUNC}" \) ]; then
			SKIP_HASH=1
			RKHTMPVAR="${RKHTMPVAR} hash"

			if [ -n "${PRELINK_HASH}" ]; then
				HASH_FUNC_ERR="prelink with ${PRELINK_HASH}"
			else
				HASH_FUNC_ERR="${HASH_FUNC}"
			fi

			if [ -z "${OLD_HASH_FUNC}" ]; then
				OLD_HASH_FUNC_ERR="Unset"
			else
				if [ "${OLD_HASH_FUNC}" = "MD5" -o "${OLD_HASH_FUNC}" = "SHA1" ]; then
					OLD_HASH_FUNC_ERR="prelink with ${OLD_HASH_FUNC}"
				else
					OLD_HASH_FUNC_ERR="${OLD_HASH_FUNC}"
				fi
			fi

			if [ -z "${PKGMGR}" ]; then
				PKGMGR_ERR="Unset"
			else
				PKGMGR_ERR="${PKGMGR}"
			fi

			if [ -z "${OLD_PKGMGR}" ]; then
				OLD_PKGMGR_ERR="Unset"
			else
				OLD_PKGMGR_ERR="${OLD_PKGMGR}"
			fi
		fi

		if [ $PRELINKED -eq 1 ]; then
			case $SKIP_HASH_MSG in
			1)
				SKIP_HASH=1
				RKHTMPVAR="${RKHTMPVAR} prelink"
				;;
			2)
				SKIP_HASH=1
				RKHTMPVAR="${RKHTMPVAR} sha1"
				;;
			3)
				SKIP_HASH=1
				RKHTMPVAR="${RKHTMPVAR} libsafe"
				;;
			esac
		fi
	fi

	if [ $SKIP_IMMUT -eq 0 ]; then
		if [ $BSDOS -eq 1 ]; then
			if [ -z "`ls -lno ${CONFIGFILE} 2>/dev/null`" ]; then
				SKIP_IMMUT=1
				RKHTMPVAR="${RKHTMPVAR} immutable-bsd"
			fi
		else
			if [ -z "${LSATTR_CMD}" ]; then
				SKIP_IMMUT=1
				RKHTMPVAR="${RKHTMPVAR} immutable"
			elif [ -z "`${LSATTR_CMD} ${CONFIGFILE} 2>/dev/null`" ]; then
				SKIP_IMMUT=1
				RKHTMPVAR="${RKHTMPVAR} immutable-cmd"
			fi
		fi
	fi

	if [ $SKIP_SCRIPT -eq 0 ]; then
		if [ -z "${FILE_CMD}" ]; then
			SKIP_SCRIPT=1
			RKHTMPVAR="${RKHTMPVAR} script"
		elif [ -z "`${FILE_CMD} ${CONFIGFILE} 2>/dev/null`" ]; then
			SKIP_SCRIPT=1
			RKHTMPVAR="${RKHTMPVAR} script-cmd"
		fi
	fi

	if [ $SKIP_ATTR -eq 0 -o $SKIP_HASH -eq 0 ]; then
		if [ ! -f ${RKHDAT_FILE} ]; then
			SKIP_HASH=1
			SKIP_ATTR=1
			USE_DAT_FILE=0
			RKHTMPVAR="${RKHTMPVAR} missing"
		fi

		if [ $USE_DAT_FILE -eq 1 -a ! -s ${RKHDAT_FILE} ]; then
			SKIP_HASH=1
			SKIP_ATTR=1
			USE_DAT_FILE=0
			RKHTMPVAR="${RKHTMPVAR} empty"
		fi
	else
		#
		# If we are not checking the file attributes or
		# the hash value, then we don't need to look at
		# the rkhunter.dat file. The other tests can be
		# done without the file.
		#

		USE_DAT_FILE=0
	fi

	#
	# If the O/S has changed in some way, and we are not just reporting warnings,
	# and O/S warnings are enabled, then show a warning in the prerequisites test.
	#

	if [ $OS_CHANGED -eq 1 -a $SHOWWARNINGSONLY -eq 0 -a $WARN_ON_OS_CHANGE -eq 1 ]; then
		RKHTMPVAR="${RKHTMPVAR} os_changed"
	fi

	#
	# If all the previous checks have disabled all the tests,
	# then we tell the user and then return.
	#

	if [ $SKIP_ATTR -eq 1 -a $SKIP_HASH -eq 1 -a $SKIP_IMMUT -eq 1 -a $SKIP_SCRIPT -eq 1 ]; then
		RKHTMPVAR="${RKHTMPVAR} notests"
	fi


	#
	# Display the results.
	#

	if [ $SKIP_IMMUT_OS -eq 1 ]; then
		display --to LOG --type INFO FILE_PROP_IMMUT_OS
	fi

	if [ -z "${RKHTMPVAR}" ]; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN FILE_PROP_CMDS
	else
		SUMMARY_PROP_REQCMDS=1

		display --to SCREEN+LOG --type WARNING --screen-indent 4 --result WARNING --color RED FILE_PROP_CMDS


		RKHTMPVAR2=0
		for TEST_RESULT in ${RKHTMPVAR}; do
			case "${TEST_RESULT}" in
			attr)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_ATTR
				;;
			hash|prelink|sha1|libsafe)
				if [ $RKHTMPVAR2 -eq 0 ]; then
					RKHTMPVAR2=1
					display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_HASH
				fi

				case "${TEST_RESULT}" in
				hash)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_FUNC "${HASH_FUNC_ERR}" "${PKGMGR_ERR}" "${OLD_HASH_FUNC_ERR}" "${OLD_PKGMGR_ERR}"
					;;
				prelink)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_PRELINK
					;;
				sha1)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_SHA1
					;;
				libsafe)
					display --to LOG --type PLAIN --log-indent 13 FILE_PROP_SKIP_HASH_LIBSAFE
					;;
				esac
				;;
			immutable)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_IMMUT
				;;
			immutable-bsd)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_IMMUT_CMD "ls -lno"
				;;
			immutable-cmd)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_IMMUT_CMD "lsattr"
				;;
			script)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_SCRIPT
				;;
			script-cmd)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SKIP_FILE_CMD
				;;
			os_changed)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_OS_CHANGED
				;;
			missing)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_DAT_MISSING
				display --to LOG --type INFO FILE_PROP_DAT_MISSING_INFO
				;;
			empty)
				display --to LOG --type PLAIN --log-indent 9 FILE_PROP_DAT_EMPTY
				display --to LOG --type INFO FILE_PROP_DAT_MISSING_INFO
				;;
			esac
		done


		if [ -n "`echo \"${RKHTMPVAR}\" | egrep 'libsafe|missing|empty'`" ]; then
			display --to LOG --type WARNING --nl PROPUPD_WARN
		fi

		if [ -n "`echo \"${RKHTMPVAR}\" | grep 'notests'`" ]; then
			display --to LOG --type WARNING --nl FILE_PROP_SKIP_ALL
			return
		fi
	fi


	#
	# Set up some local variables depending on what
	# commands we have available.
	#

	if [ $SKIP_ATTR -eq 1 ]; then
		SCMD=""
		INODECMD=""
	else
		if [ -n "`echo \"${STAT_CMD}\" | grep '\.pl$'`" ]; then
			SCMD="${STAT_CMD} --modeoct --raw --ino --mode --uid --gid --size --Mtime"
			INODECMD="${STAT_CMD} --modeoct --raw --ino"
		elif [ $BSDOS -eq 1 ]; then
			SCMD="${STAT_CMD} -f '%i %Mp%Lp %u %g %z %m:'"
			INODECMD="${STAT_CMD} -f '%i'"
		else
			SCMD="${STAT_CMD} -c '%i 0%a %u %g %s %Y:'"
			INODECMD="${STAT_CMD} -c '%i'"
		fi
	fi

	if [ $SKIP_HASH -eq 1 ]; then
		HCMD=""
		SYSHASH=""
	else
		HCMD="${HASH_FUNC}"
	fi

	RDIR=`echo "${RKHROOTDIR}" | sed -e 's/\//\\\\\//g'`


	#
	# Set up some whitelist variables. There is no point
	# recalculating the (static) whitelist as we look at
	# each file. We may as well just do it the once here.
	#

	if [ $SKIP_ATTR -eq 0 ]; then
		ATTRWHITELIST=`get_option 1 multi ATTRWHITELIST` || exit 1
		WRITEWHITELIST=`get_option 1 multi WRITEWHITELIST` || exit 1
	fi

	if [ $SKIP_IMMUT -eq 0 ]; then
		IMMUTWHITELIST=`get_option 1 multi IMMUTWHITELIST` || exit 1
	fi

	if [ $SKIP_SCRIPT -eq 0 ]; then
		SCRIPTWHITELIST=`get_option 1 multi SCRIPTWHITELIST` || exit 1
	fi


	#
	# Next we have to recreate the list of pathnames for the
	# file properties checks. We need to recreate it because
	# the root PATH may have changed, and so there may be more
	# directories to be checked. However, if we have just run
	# the '--propupd' option, then we can skip this.
	#

	test $PROP_UPDATE -eq 0 && create_rkh_file_prop_list


	#
	# Now loop through each of the files and
	# perform the tests on each one.
	#

	VERIFIED_PKG_LIST=""

	for FNAME in `cat ${RKH_FILEPROP_LIST}`; do
		FNAMEGREP=""
		TEST_RESULT=""
		WHITELIST_RESULT=""

		NOVRFYFILE=0
		FILE_IS_PKGD=0
		DEPENDENCY_ERR=0
		HASH_TEST_PASSED=0
		SIZE_TEST_PASSED=0


		#
		# We first need to test if the file exists or not,
		# and if the file is listed in the rkhunter.dat
		# file or not. This can indicate files that have
		# appeared on or disappeared from the system.
		#

		if [ -f "${FNAME}" ]; then
			FILE_EXISTS=1
			PROP_FILE_LIST_COUNT=`expr ${PROP_FILE_LIST_COUNT} + 1`
		else
			FILE_EXISTS=0
		fi

		if [ $USE_DAT_FILE -eq 1 ]; then
			#
			# When checking the filename against the rkhunter.dat
			# file, we must use the real filename and not one with
			# the root directory.
			#

			FILENAME=`echo "${FNAME}" | sed -e "s:^${RDIR}::"`

			FNAMEGREP=`echo "${FILENAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

			RKHLINE=`grep "^File:${FNAMEGREP}:" ${RKHDAT_FILE}`

			if [ $FILE_EXISTS -eq 1 -a -z "${RKHLINE}" ]; then
				TEST_RESULT="${TEST_RESULT} norkhline"
			elif [ $FILE_EXISTS -eq 0 ]; then
				if [ -n "${RKHLINE}" ]; then
					PROP_FAILED_COUNT=`expr ${PROP_FAILED_COUNT} + 1`

					display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result WARNING --color RED NAME "${FNAME}"
					display --to LOG --type WARNING FILE_PROP_FILE_NOT_EXIST "${FNAME}"
				fi

				continue
			fi
		elif [ $FILE_EXISTS -eq 1 ]; then
			RKHLINE=""
			FNAMEGREP=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`
		else
			continue
		fi


		#
		# Start the tests.
		#

		if [ $USE_DAT_FILE -eq 1 -a -n "${RKHLINE}" ]; then
			FDATA=""
			RPM_QUERY_RESULT=""
			PKGMGR_VERIFY_RESULT=""

			#
			# See if the file is to be exempt from any package manager verification.
			#

			if [ -n "`echo \"${PKGMGRNOVRFY}\" | grep \" ${FNAMEGREP} \"`" ]; then
				NOVRFYFILE=1
			fi


			#
			# Because the RPM package manager can verify most
			# of the tests we are doing, we obtain the verified
			# data now. The other package managers, at present,
			# only provide the MD5 checksum. As such we simply
			# handle them within the hash test.
			#

			if [ "${PKGMGR}" = "RPM" ]; then
				#
				# First we see if the file is exempt or part of a package.
				#

				if [ $NOVRFYFILE -eq 1 ]; then
					ERRCODE=1
				else
					PKGNAME_ARCH=`${RPM_CMD} -qf ${FILENAME} --queryformat '%{N}-%{V}-%{R}.%{ARCH}\n' 2>/dev/null`
					ERRCODE=$?
				fi

				if [ $ERRCODE -eq 0 ]; then
					#
					# Okay we have a package name. Is it in the list
					# of packages we have already tested as verified?
					#
					# If multiple packages claim the same file, we use
					# 64-bit over 32-bit, or simply the last one.
					#

					FILE_IS_PKGD=1

					PKGNAME=`echo "${PKGNAME_ARCH}" | egrep '\.(x86_64|ia64)$' | tail -1`

					test -z "${PKGNAME}" && PKGNAME=`echo "${PKGNAME_ARCH}" | tail -1`

					RKHTMPVAR=`echo "${PKGNAME}" | sed -e 's/\./\\\./g'`

					if [ -z "`echo \"${VERIFIED_PKG_LIST}\" | grep \" ${RKHTMPVAR} \"`" ]; then
						#
						# No, it isn't in the list. So we verify the package
						# and either add it to the list if it verifies okay,
						# or get the verification result for the file.
						#

						PKGMGR_VERIFY_RESULT=`${RPM_CMD} -V "${PKGNAME}" 2>&1`

						if [ -z "${PKGMGR_VERIFY_RESULT}" ]; then
							VERIFIED_PKG_LIST="${VERIFIED_PKG_LIST} ${PKGNAME} "
						else
							if [ -n "`echo \"${PKGMGR_VERIFY_RESULT}\" | grep \"prelink.* ${FILENAME}.* dependenc\"`" ]; then
								DEPENDENCY_ERR=1
							fi

							PKGMGR_VERIFY_RESULT=`echo "${PKGMGR_VERIFY_RESULT}" | grep " ${FNAMEGREP}\$" | cut -d' ' -f1`
						fi
					fi


					#
					# The package manager check does not verify all the items
					# we check. So we still need to dig out the rest of the
					# information about this file from the package manager database.
					#

					RPM_QUERY_RESULT=`${RPM_CMD} -q --queryformat '[%{FILEMODES:octal}:%{FILEUSERNAME}:%{FILEGROUPNAME}:%{FILESIZES}:%{FILEMTIMES}:%{FILEMD5S}:%{FILENAMES}\n]' "${PKGNAME}" 2>/dev/null | grep ":${FNAMEGREP}\$"`
					ERRCODE=$?

					if [ $ERRCODE -eq 0 ]; then
						RPM_QUERY_RESULT=`echo "${RPM_QUERY_RESULT}" | tail -1`

						FPERM="0`echo \"${RPM_QUERY_RESULT}\" | cut -d: -f1 | cut -c 3-`"
						FPERM=`echo "${FPERM}" | sed -e 's/^00/0/'`

						RKHUID=`echo "${RPM_QUERY_RESULT}" | cut -d: -f2`
						RKHUID=`grep "^${RKHUID}:" /etc/passwd 2>/dev/null | cut -d: -f3`

						RKHGID=`echo "${RPM_QUERY_RESULT}" | cut -d: -f3`
						RKHGID=`grep "^${RKHGID}:" /etc/group 2>/dev/null | cut -d: -f3`

						RKHSIZE=`echo "${RPM_QUERY_RESULT}" | cut -d: -f4`

						RKHDTM=`echo "${RPM_QUERY_RESULT}" | cut -d: -f5`

						FDATA="${FPERM}:${RKHUID}:${RKHGID}:${RKHSIZE}:${RKHDTM}:"
					else
						#
						# If, for some reason, we cannot get the package information,
						# then treat it as if it returned all null values.
						#

						FDATA=":::::"
						display --to LOG --type INFO CMD_ERROR "rpm -qf --queryformat... ${FILENAME}" $ERRCODE
					fi

					#
					# Now get the inode value directly from the disk,
					# but only if prelinking is not being used.
					#

					RKHTMPVAR=""

					test $PRELINKED -eq 0 && RKHTMPVAR=`eval ${INODECMD} ${FNAME} 2>/dev/null | tr -d ' '`

					FDATA="${RKHTMPVAR}:${FDATA}"
				fi
			fi


			#
			# Do the file hash value check.
			#

			if [ $SKIP_HASH -eq 0 ]; then
				#
				# First we get all the package manager results.
				#

				case "${PKGMGR}" in
				RPM)
					;;
				DPKG)
					#
					# First see if the file is exempt or part of a known package.
					#

					if [ $NOVRFYFILE -eq 1 ]; then
						PKGNAME=""
					else
						PKGNAME=`${DPKG_CMD} --search ${FILENAME} 2>/dev/null | cut -d: -f1`
					fi

					if [ -n "${PKGNAME}" -a -f "/var/lib/dpkg/info/${PKGNAME}.md5sums" ]; then
						FNAMEGREP=`echo "${FNAMEGREP}" | sed -e 's:^/::'`

						SYSHASH=`egrep "( |\./)${FNAMEGREP}\$" /var/lib/dpkg/info/${PKGNAME}.md5sums | cut -d' ' -f1`

						if [ -n "${SYSHASH}" ]; then
							FILE_IS_PKGD=1
							RKHTMPVAR=`${PKGMGR_MD5_HASH} ${FNAME} 2>/dev/null | cut -d' ' -f $HASH_FLD_IDX`

							if [ "${RKHTMPVAR}" != "${SYSHASH}" ]; then
								PKGMGR_VERIFY_RESULT="5"

								if [ -n "`${PKGMGR_MD5_HASH} ${FNAME} 2>&1 | egrep 'prelink.* (dependenc|adjusting unfinished)'`" ]; then
									DEPENDENCY_ERR=1
								fi
							fi
						fi
					fi
					;;
				BSD)
					#
					# First see if the file is exempt or part of a known package.
					#

					if [ $NOVRFYFILE -eq 1 ]; then
						PKGNAME=""
					else
						PKGNAME=`${PKG_CMD} -F -e ${FILENAME} 2>/dev/null`
					fi

					if [ -n "${PKGNAME}" ]; then
						#
						# Next strip of the '/usr/pkg' from the
						# pathname, and then get the hash value.
						#

						FNAMEGREP=`echo "${FNAMEGREP}" | sed -e 's:^/usr/pkg/::'`

						SYSHASH=`${PKG_CMD} -v -L ${PKGNAME} 2>/dev/null | grep -A 1 "File: ${FNAMEGREP}\$" | tail -1 | cut -d: -f3`

						if [ -n "${SYSHASH}" ]; then
							FILE_IS_PKGD=1
							RKHTMPVAR=`${PKGMGR_MD5_HASH} ${FNAME} 2>/dev/null | cut -d' ' -f $HASH_FLD_IDX`

							if [ "${RKHTMPVAR}" != "${SYSHASH}" ]; then
								PKGMGR_VERIFY_RESULT="5"

								if [ -n "`${PKGMGR_MD5_HASH} ${FNAME} 2>&1 | egrep 'prelink.* (dependenc|adjusting unfinished)'`" ]; then
									DEPENDENCY_ERR=1
								fi
							fi
						fi
					fi
					;;
				esac


				#
				# Now see if we need to work out the hash value or not.
				#

				RKHHASH=`echo ${RKHLINE} | cut -d: -f3`

				if [ $FILE_IS_PKGD -eq 1 ]; then
					if [ "${RKHHASH}" = "ignore-prelink-dep-err" ]; then
						if [ $DEPENDENCY_ERR -eq 1 ]; then
							DEPENDENCY_ERR=0
							PKGMGR_VERIFY_RESULT=""
							display --to LOG --type INFO FILE_PROP_IGNORE_PRELINK_DEP_ERR "${FNAME}"
						else
							PKGMGR_VERIFY_RESULT="5"
						fi
					fi

					if [ -z "`echo \"${PKGMGR_VERIFY_RESULT}\" | egrep '5|(^..\?)'`" ]; then
						HASH_TEST_PASSED=1
					else
						TEST_RESULT="${TEST_RESULT} verify:hashchanged"
					fi
				else
					#
					# The file is not part of a package. So we need
					# to compare the on-disk hash value against the
					# value in the rkhunter.dat file.
					#
					# First see if we have a stored hash value.
					#

					test -z "${RKHHASH}" && TEST_RESULT="${TEST_RESULT} norkhhash"

					if [ -z "${TEST_RESULT}" ]; then
						if [ "${HCMD}" = "NONE" ]; then
							SYSHASH=""
						else
							SYSHASH=`${HCMD} ${FNAME} 2>/dev/null | cut -d' ' -f $HASH_FLD_IDX`

							if [ -z "${SYSHASH}" ]; then
								if [ -n "`${HCMD} ${FNAME} 2>&1 | egrep 'prelink.* (dependenc|adjusting unfinished)'`" ]; then
									if [ "${RKHHASH}" = "ignore-prelink-dep-err" ]; then
										SYSHASH="${RKHHASH}"
										display --to LOG --type INFO FILE_PROP_IGNORE_PRELINK_DEP_ERR "${FNAME}"
									else
										DEPENDENCY_ERR=1
									fi
								fi
							fi
						fi

						test "${RKHHASH}" != "${SYSHASH}" && TEST_RESULT="${TEST_RESULT} hashchanged"
					fi
				fi


				#
				# Because the BSD and DPKG package managers only provide the
				# MD5 checksum, we can assume that any file which is part of
				# a package after this test must be an RPM file.
				#

				test "${PKGMGR}" != "RPM" && FILE_IS_PKGD=0
			fi


			#
			# Do the file attributes checks.
			#
			# This checks the files permissions, and the uid/gid.
			# The file permissions are also checked to see if 'w'
			# has been allowed for all users. If prelinking is not
			# in use then the inode, file size, and modification
			# date-time are checked as well.
			#

			if [ $SKIP_ATTR -eq 0 ]; then
				#
				# First check to see if the file is whitelisted here,
				# just the once. It is better than checking after
				# each individual attribute test.
				#

				WL_FILE=""

				for WHITELISTFILE in ${ATTRWHITELIST}; do
					if [ "${RKHROOTDIR}${WHITELISTFILE}" = "${FNAME}" ]; then
						WL_FILE="whitelisted"
						WHITELIST_RESULT="${WHITELIST_RESULT} attr"
						break
					fi
				done

				test -z "${FDATA}" && FDATA=`eval ${SCMD} ${FNAME} 2>/dev/null | tr ' ' ':'`

				if [ -z "${WL_FILE}" -a -n "${FDATA}" ]; then
					#
					# Check the file permissions.
					#

					if [ $FILE_IS_PKGD -eq 1 ]; then
						echo "${PKGMGR_VERIFY_RESULT}" | egrep 'M|(^.\?)' >/dev/null && TEST_RESULT="${TEST_RESULT} verify:permchanged"
					else
						RKHPERM=`echo ${RKHLINE} | cut -d: -f5`
						SYSPERM=`echo ${FDATA} | cut -d: -f2`

						if [ -n "${RKHPERM}" ]; then
							test "${RKHPERM}" != "${SYSPERM}" && TEST_RESULT="${TEST_RESULT} permchanged"
						else
							TEST_RESULT="${TEST_RESULT} norkhperm"
						fi
					fi


					#
					# Check the file user-id.
					#

					if [ $FILE_IS_PKGD -eq 1 ]; then
						echo "${PKGMGR_VERIFY_RESULT}" | egrep 'U|(^.....\?)' >/dev/null && TEST_RESULT="${TEST_RESULT} verify:uidchanged"
					else
						RKHUID=`echo ${RKHLINE} | cut -d: -f6`
						SYSUID=`echo ${FDATA} | cut -d: -f3`

						if [ -n "${RKHUID}" ]; then
							test "${RKHUID}" != "${SYSUID}" && TEST_RESULT="${TEST_RESULT} uidchanged"
						else
							TEST_RESULT="${TEST_RESULT} norkhuid"
						fi
					fi


					#
					# Check the file group-id.
					#

					if [ $FILE_IS_PKGD -eq 1 ]; then
						echo "${PKGMGR_VERIFY_RESULT}" | egrep 'G|(^......\?)' >/dev/null && TEST_RESULT="${TEST_RESULT} verify:gidchanged"
					else
						RKHGID=`echo ${RKHLINE} | cut -d: -f7`
						SYSGID=`echo ${FDATA} | cut -d: -f4`

						if [ -n "${RKHGID}" ]; then
							test "${RKHGID}" != "${SYSGID}" && TEST_RESULT="${TEST_RESULT} gidchanged"
						else
							TEST_RESULT="${TEST_RESULT} norkhgid"
						fi
					fi


					#
					# Check the file inode number.
					#

					if [ $PRELINKED -eq 0 ]; then
						RKHINODE=`echo ${RKHLINE} | cut -d: -f4`
						SYSINODE=`echo ${FDATA} | cut -d: -f1`

						if [ -n "${RKHINODE}" ]; then
							test "${RKHINODE}" != "${SYSINODE}" && TEST_RESULT="${TEST_RESULT} inodechanged"
						else
							TEST_RESULT="${TEST_RESULT} norkhinode"
						fi
					fi


					#
					# Check the file size.
					#

					if [ $FILE_IS_PKGD -eq 1 ]; then
						if [ -z "`echo \"${PKGMGR_VERIFY_RESULT}\" | egrep 'S|(^\?)'`" ]; then
							SIZE_TEST_PASSED=1
						else
							TEST_RESULT="${TEST_RESULT} verify:sizechanged"
						fi
					elif [ $PRELINKED -eq 0 -o $FILE_IS_PKGD -eq 0 ]; then
						RKHSIZE=`echo ${RKHLINE} | cut -d: -f8`
						SYSSIZE=`echo ${FDATA} | cut -d: -f5`

						if [ -n "${RKHSIZE}" ]; then
							if [ "${RKHSIZE}" = "${SYSSIZE}" ]; then
								SIZE_TEST_PASSED=1
							else
								TEST_RESULT="${TEST_RESULT} sizechanged"
							fi
						else
							TEST_RESULT="${TEST_RESULT} norkhsize"
						fi
					fi


					#
					# Check the file modification date-time.
					#

					if [ $FILE_IS_PKGD -eq 1 ]; then
						echo "${PKGMGR_VERIFY_RESULT}" | egrep 'T|(^.......\?)' >/dev/null && TEST_RESULT="${TEST_RESULT} verify:dtmchanged"
					elif [ $PRELINKED -eq 0 -o $FILE_IS_PKGD -eq 0 ]; then
						RKHDTM=`echo ${RKHLINE} | cut -d: -f9`
						SYSDTM=`echo ${FDATA} | cut -d: -f6`

						if [ -n "${RKHDTM}" ]; then
							test "${RKHDTM}" != "${SYSDTM}" && TEST_RESULT="${TEST_RESULT} dtmchanged"
						else
							TEST_RESULT="${TEST_RESULT} norkhdtm"
						fi
					fi
				elif [ -z "${WL_FILE}" ]; then
					TEST_RESULT="${TEST_RESULT} sysattrunavail"
				fi


				#
				# Check the file permissions here to see if the 'other' permission
				# contains a 'w'. The check is against the octal value. Symbolic
				# links are ignored.
				#

				if [ ! -h "${FNAME}" -a $FILE_IS_PKGD -eq 0 ]; then
					WL_FILE=""

					for WHITELISTFILE in ${WRITEWHITELIST}; do
						if [ "${RKHROOTDIR}${WHITELISTFILE}" = "${FNAME}" ]; then
							WL_FILE="whitelisted"
							WHITELIST_RESULT="${WHITELIST_RESULT} write"
							break
						fi
					done

					if [ -z "${WL_FILE}" ]; then
						SYSPERM=`echo ${FDATA} | cut -d: -f2`

						if [ -n "`echo ${SYSPERM} | grep '[2367]\$'`" ]; then
							TEST_RESULT="${TEST_RESULT} write"
						elif [ -z "${SYSPERM}" ]; then
							TEST_RESULT="${TEST_RESULT} syspermunavail"
						fi
					fi
				fi
			fi
		fi


		#
		# We can now carry out the tests which do not
		# require the rkhunter.dat file.
		#

		#
		# Do the file immutable-bit check.
		#

		if [ $SKIP_IMMUT -eq 0 ]; then
			#
			# Test if the file is whitelisted.
			#

			WL_FILE=""
			RKHTMPVAR=""

			for WHITELISTFILE in ${IMMUTWHITELIST}; do
				if [ "${RKHROOTDIR}${WHITELISTFILE}" = "${FNAME}" ]; then
					WL_FILE="whitelisted"
					WHITELIST_RESULT="${WHITELIST_RESULT} immutable"
					break
				fi
			done

			if [ -z "${WL_FILE}" ]; then
				if [ $BSDOS -eq 0 ]; then
					if [ ! -h "${FNAME}" ]; then
						RKHTMPVAR=`${LSATTR_CMD} ${FNAME} 2>&1 | cut -d' ' -f1 | grep 'i'`
					fi
				else
					RKHTMPVAR=`ls -lno ${FNAME} 2>&1 | awk '{ print $5 }' | egrep 'uchg|schg|sappnd|uappnd|sunlnk|sunlink|schange|simmutable|sappend|uappend|uchange|uimmutable'`
				fi

				test -n "${RKHTMPVAR}" && TEST_RESULT="${TEST_RESULT} immutable"
			fi
		fi


		#
		# Do the file script replacement check.
		#

		if [ $SKIP_SCRIPT -eq 0 ]; then
			#
			# If we are using a package manager, and both the hash test
			# and the file size test have passed, then we skip the script
			# replacement check. The assumption is that to change a file
			# with one value remaining the same is possible, but to change
			# it such that both are the same is improbable. It would also
			# require the package manager database having being corrupted
			# as well.
			#

			if [ $HASH_TEST_PASSED -eq 0 -o $SIZE_TEST_PASSED -eq 0 ]; then
				#
				# See if the file is whitelisted.
				#

				WL_FILE=""
				SYSSCRIPT=""

				for WHITELISTFILE in ${SCRIPTWHITELIST}; do
					if [ "${RKHROOTDIR}${WHITELISTFILE}" = "${FNAME}" ]; then
						WL_FILE="whitelisted"
						WHITELIST_RESULT="${WHITELIST_RESULT} script"
						break
					fi
				done

				if [ -z "${WL_FILE}" ]; then
					test -n "${BASENAME_CMD}" && RKHTMPVAR=`${BASENAME_CMD} ${FNAME}` || RKHTMPVAR=`echo "${FNAME}" | sed -e 's:^.*/::'`

					if [ "${RKHTMPVAR}" = "rkhunter" ]; then
						SYSSCRIPT=`${FILE_CMD} ${FNAME} 2>&1 | cat -v | egrep -i -v 'shell script( |$)'`
					else
						SYSSCRIPT=`${FILE_CMD} ${FNAME} 2>&1 | cat -v | egrep -i ' script( |$)'`
					fi

					test -n "${SYSSCRIPT}" && TEST_RESULT="${TEST_RESULT} script"
				fi
			fi
		fi


		#
		# Now output the results.
		#

		if [ -z "${TEST_RESULT}" ]; then
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result OK --color GREEN NAME "${FNAME}"
		else
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 --result WARNING --color RED NAME "${FNAME}"

			PROP_FAILED_COUNT=`expr ${PROP_FAILED_COUNT} + 1`

			RKHTMPVAR2=0
			RKHTMPVAR3=0
			for RKHTMPVAR in ${TEST_RESULT}; do
				case "${RKHTMPVAR}" in
				hashchanged|permchanged|uidchanged|gidchanged|inodechanged|sizechanged|dtmchanged)
					if [ $RKHTMPVAR2 -eq 0 ]; then
						RKHTMPVAR2=1
						display --to LOG --type WARNING FILE_PROP_CHANGED
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_CHANGED2 "${FNAME}"
					fi

					case "${RKHTMPVAR}" in
					hashchanged)
						if [ -z "${SYSHASH}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSHASH_UNAVAIL
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSHASH "${SYSHASH}"
						fi

						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_RKHHASH "${RKHHASH}"

						test $DEPENDENCY_ERR -eq 1 && display --to LOG --type PLAIN --log-indent 9 FILE_PROP_NO_SYSHASH_DEPENDENCY "${FNAME}"
						;;
					permchanged)
						if [ -z "${SYSPERM}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_PERM_UNAVAIL "${RKHPERM}"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_PERM "${SYSPERM}" "${RKHPERM}"
						fi
						;;
					uidchanged)
						if [ -z "${SYSUID}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_UID_UNAVAIL "${RKHUID}"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_UID "${SYSUID}" "${RKHUID}"
						fi
						;;
					gidchanged)
						if [ -z "${SYSGID}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_GID_UNAVAIL "${RKHGID}"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_GID "${SYSGID}" "${RKHGID}"
						fi
						;;
					inodechanged)
						if [ -z "${SYSINODE}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_INODE_UNAVAIL "${RKHINODE}"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_INODE "${SYSINODE}" "${RKHINODE}"
						fi
						;;
					sizechanged)
						if [ -z "${SYSSIZE}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SIZE_UNAVAIL "${RKHSIZE}"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SIZE "${SYSSIZE}" "${RKHSIZE}"
						fi
						;;
					dtmchanged)
						if [ -z "${SYSDTM}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSDTM_UNAVAIL
						else
							get_readable_date ${SYSDTM}

							if [ -n "${READABLE_DATE}" ]; then
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSDTM "${SYSDTM} (${READABLE_DATE})"
							else
								display --to LOG --type PLAIN --log-indent 9 FILE_PROP_SYSDTM "${SYSDTM}"
							fi
						fi

						get_readable_date ${RKHDTM}

						if [ -n "${READABLE_DATE}" ]; then
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_RKHDTM "${RKHDTM} (${READABLE_DATE})"
						else
							display --to LOG --type PLAIN --log-indent 9 FILE_PROP_RKHDTM "${RKHDTM}"
						fi
						;;
					esac
					;;
				verify:hashchanged|verify:permchanged|verify:uidchanged|verify:gidchanged|verify:sizechanged|verify:dtmchanged)
					if [ $RKHTMPVAR3 -eq 0 ]; then
						RKHTMPVAR3=1
						display --to LOG --type WARNING FILE_PROP_VRFY
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_CHANGED2 "${FNAME}"

						test $DEPENDENCY_ERR -eq 1 && display --to LOG --type PLAIN --log-indent 9 FILE_PROP_NO_SYSHASH_DEPENDENCY "${FNAME}"
					fi

					case "${RKHTMPVAR}" in
					verify:hashchanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_HASH

						if [ "${RKHHASH}" = "ignore-prelink-dep-err" ]; then
							display --to LOG --type INFO --log-indent 9 FILE_PROP_IGNORE_PRELINK_DEP_ERR "${FNAME}"
						fi
						;;
					verify:permchanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_PERM
						;;
					verify:uidchanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_UID
						;;
					verify:gidchanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_GID
						;;
					verify:sizechanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_SIZE
						;;
					verify:dtmchanged)
						display --to LOG --type PLAIN --log-indent 9 FILE_PROP_VRFY_DTM
						;;
					esac
					;;
				norkhline)
					display --to LOG --type WARNING FILE_PROP_NO_RKH_REC "${FNAME}"
					;;
				norkhhash)
					display --to LOG --type WARNING FILE_PROP_NO_RKHHASH "${FNAME}"
					;;
				norkhperm)
					display --to LOG --type WARNING FILE_PROP_NO_RKHPERM "${FNAME}"
					;;
				norkhuid)
					display --to LOG --type WARNING FILE_PROP_NO_RKHUID "${FNAME}"
					;;
				norkhgid)
					display --to LOG --type WARNING FILE_PROP_NO_RKHGID "${FNAME}"
					;;
				norkhinode)
					display --to LOG --type WARNING FILE_PROP_NO_RKHINODE "${FNAME}"
					;;
				norkhsize)
					display --to LOG --type WARNING FILE_PROP_NO_RKHSIZE "${FNAME}"
					;;
				norkhdtm)
					display --to LOG --type WARNING FILE_PROP_NO_RKHDTM "${FNAME}"
					;;
				sysattrunavail)
					display --to LOG --type WARNING FILE_PROP_NO_SYSATTR "${FNAME}"
					;;
				write)
					display --to LOG --type WARNING FILE_PROP_WRITE "${FNAME}"
					;;
				syspermunavail)
					display --to LOG --type WARNING FILE_PROP_SYSPERM_UNAVAIL "${FNAME}"
					;;
				immutable)
					display --to LOG --type WARNING FILE_PROP_IMMUT "${FNAME}"
					;;
				script)
					test -n "${BASENAME_CMD}" && RKHTMPVAR4=`${BASENAME_CMD} ${FNAME}` || RKHTMPVAR4=`echo "${FNAME}" | sed -e 's:^.*/::'`

					if [ "${RKHTMPVAR4}" = "rkhunter" ]; then
						display --to LOG --type WARNING FILE_PROP_SCRIPT_RKH "${FNAME}" "${SYSSCRIPT}"
					else
						display --to LOG --type WARNING FILE_PROP_SCRIPT "${FNAME}" "${SYSSCRIPT}"
					fi
					;;
				esac
			done
		fi

		if [ -n "${WHITELIST_RESULT}" ]; then
			for WL_FILE in ${WHITELIST_RESULT}; do
				case "${WL_FILE}" in
				hash)
					RKHTMPVAR="file hash"
					;;
				attr)
					RKHTMPVAR="file attributes"
					;;
				write)
					RKHTMPVAR="file write permission"
					;;
				immutable)
					RKHTMPVAR="file immutable-bit"
					;;
				script)
					RKHTMPVAR="script replacement"
					;;
				esac

				display --to LOG --type INFO FILE_PROP_WL "${FNAME}" "${RKHTMPVAR}"
			done
		fi
	done

	return
}


suspscan() {

	#
	# Suspscan content scan using fixed strings.
	# Suspscan is a CPU hog and only useful to some limit.
	# Suspscan should NEVER be enabled by default. 
	#

	if `check_test suspscan`; then
		display --to LOG --type PLAIN --log-indent 2 --nl SUSPSCAN_START
		display --to LOG --type INFO STARTING_TEST suspscan
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST suspscan
		return
	fi


	#
	# First check that we have the commands we need.
	#

	if [ -z "${FILE_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "file"
		return
	elif [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "strings"
		return
	fi

	#
	# Get the directories to scan.
	#

	SUSPSCAN_DIRS=`get_option 2 single SUSPSCAN_DIRS` || exit 1

	if [ -z "${SUSPSCAN_DIRS}" ]; then
		SUSPSCAN_DIRS="/tmp /var/tmp"
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_NO_DIRS "${SUSPSCAN_DIRS}"
	else
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_DIRS "${SUSPSCAN_DIRS}"
	fi

	#
	# Get the tempdir. Should be a /dev/shm type.
	#

	SUSPSCAN_TEMP=`get_option 1 single SUSPSCAN_TEMP` || exit 1

	if [ -z "${SUSPSCAN_TEMP}" ]; then
		SUSPSCAN_TEMP="/dev/shm"
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_NO_TEMP "${SUSPSCAN_TEMP}"
	else
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_TEMP "${SUSPSCAN_TEMP}"
	fi

	if [ ! -d "${SUSPSCAN_TEMP}" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type WARNING SUSPSCAN_TEMP_NOT_EXIST "${SUSPSCAN_TEMP}"
		return
	elif [ ! -w "${SUSPSCAN_TEMP}" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type WARNING SUSPSCAN_TEMP_NO_WRITE "${SUSPSCAN_TEMP}"
		return
	fi

	#
	# Get the max filesize to handle, say 1024000.
	#

	SUSPSCAN_MAXSIZE=`get_option 1 single SUSPSCAN_MAXSIZE` || exit 1

	if [ -z "${SUSPSCAN_MAXSIZE}" ]; then
		SUSPSCAN_MAXSIZE=1024000
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_NO_SIZE "${SUSPSCAN_MAXSIZE}"
	elif [ -z "`echo \"${SUSPSCAN_MAXSIZE}\" | grep '^[1-9][0-9]*$'`" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type WARNING SUSPSCAN_SIZE_INVALID "${SUSPSCAN_MAXSIZE}"
		return
	else
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_SIZE "${SUSPSCAN_MAXSIZE}"
	fi

	#
	# Get the score threshold, 200 seems sensible.
	#

	SUSPSCAN_THRESH=`get_option 1 single SUSPSCAN_THRESH` || exit 1

	if [ -z "${SUSPSCAN_THRESH}" ]; then
		SUSPSCAN_THRESH=200
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_NO_THRESH "${SUSPSCAN_THRESH}"
	elif [ -z "`echo \"${SUSPSCAN_THRESH}\" | grep '^[1-9][0-9]*$'`" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 SUSPSCAN_CHECK
		display --to LOG --type WARNING SUSPSCAN_THRESH_INVALID "${SUSPSCAN_THRESH}"
		return
	else
		display --to LOG --type PLAIN --log-indent 4 SUSPSCAN_THRESH "${SUSPSCAN_THRESH}"
	fi

	#
	# Get the line threshold. This exists purely for performance reasons. 3000 seems sensible as
	# Linux Kernel Modules don't exceed 2000 lines and for example most binaries in /bin don't exceed 3000 lines.
	# Note this configuration option will remain unlisted in both the documentation or configuration file.
	#

	SUSPSCAN_LINETHRESH=`get_option 1 single SUSPSCAN_LINETHRESH` || exit 1
	if [ -z "${SUSPSCAN_LINETHRESH}" ]; then
		SUSPSCAN_LINETHRESH=3000
	fi

	#
	# Start the test.
	#

	FOUND=0
	FOUNDDIRS=""
	FILENAME="${SUSPSCAN_TEMP}/suspscan.$$.strings"

	rm -f "${SUSPSCAN_TEMP}/suspscan.*.strings" >/dev/null 2>&1

	#
	# Set a temporary file to log scan results to.
	#

        get_temp_file "${RKHTMPDIR}/suspscan.tmp"
        SUSPSCAN_TMPFILE=$TEMPFILE


	for DIR in ${SUSPSCAN_DIRS}; do
		SUSPSCAN_DIR="${RKHROOTDIR}${DIR}"

		if [ -d "${SUSPSCAN_DIR}" ]; then
			FOUND=0

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				echo "4 SUSPSCAN_DIR_CHECK "${SUSPSCAN_DIR}"" >> "${SUSPSCAN_TMPFILE}"
			fi

			$FIND_CMD "${SUSPSCAN_DIR}" -type f -o -type l 2>/dev/null | while read SUSPSCAN_ITEM; do
				#
				# Skip the debug file which may well be in one of the default suspscan directories.
				#

				test $DEBUG_OPT -eq 1 -a "${SUSPSCAN_ITEM}" = "${RKHDEBUGFILE}" && continue

				#
				# If the file is a link, then find what it points to.
				#

				if [ -h "${SUSPSCAN_ITEM}" ]; then
					if [ $HAVE_READLINK -eq 1 ]; then
						RKHTMPVAR="${SUSPSCAN_ITEM}"

						SUSPSCAN_ITEM=`${READLINK_CMD} -f ${RKHTMPVAR}`

						if [ $VERBOSE_LOGGING -eq 1 ]; then
							echo "6 SUSPSCAN_FILE_LINK_CHANGE "${RKHTMPVAR}" "${SUSPSCAN_ITEM}"" >> "${SUSPSCAN_TMPFILE}"
						fi
					else
						if [ $VERBOSE_LOGGING -eq 1 ]; then
							echo "6 SUSPSCAN_FILE_SKIPPED_LINK "${SUSPSCAN_ITEM}"" >> "${SUSPSCAN_TMPFILE}"
						fi

						continue
					fi
				fi


				#
				# Next check the size of the file.
				#

				if [ ! -s "${SUSPSCAN_ITEM}" ]; then
					if [ $VERBOSE_LOGGING -eq 1 ]; then
						echo "6 SUSPSCAN_FILE_SKIPPED_EMPTY "${SUSPSCAN_ITEM}"" >> "${SUSPSCAN_TMPFILE}"
					fi

					continue
				elif [ -z "`${FIND_CMD} "${SUSPSCAN_ITEM}" -size -${SUSPSCAN_MAXSIZE}c 2>/dev/null`" ]; then
					if [ $VERBOSE_LOGGING -eq 1 ]; then
						echo "6 SUSPSCAN_FILE_SKIPPED_SIZE "${SUSPSCAN_ITEM}"" >> "${SUSPSCAN_TMPFILE}"
					fi

					continue
				fi


				#
				# Finally, test the file type.
				#

				FTYPE=`${FILE_CMD} "${SUSPSCAN_ITEM}" 2>&1 | cat -v | cut -d' ' -f2-`

				#
				# We need to check errors from the file command, but not
				# if they are caused by the file disappearing beneath us.
				#

				test ! -e "${SUSPSCAN_ITEM}" && continue

				#
				# Adding "text" to the egrep below widens scope at the expense of more false positives and extending running time:
				#

				if [ -n "`echo \"${FTYPE}\" | grep -vi compres | egrep -i 'execu|reloc|shell|libr|data|obj|text'`" ]; then
					FOUND=1
					SUSPSCAN_NUM=1; SUSPSCAN_SCORE=0; SUSPSCAN_HITCOUNT=0
					SUSPSCAN_STRINGS=""

					$STRINGS_CMD -n 4 "${SUSPSCAN_ITEM}" | head -n $SUSPSCAN_LINETHRESH >${FILENAME} 2>&1

					for SUSPSCAN_STRING in `grep -v "^Version" ${DB_PATH}/suspscan.dat | tail -1` ; do

						#
						# Break off if the score already exceeds threshold
						#

						if [ $SUSPSCAN_SCORE -ge $SUSPSCAN_THRESH ]; then
							break
						fi

						SUSPSCAN_TERM="${SUSPSCAN_STRING}"

						#
						# Searchterm with class
						#

						case "${SUSPSCAN_STRING}" in
						[a-z]:*) 
								SUSPSCAN_CLASS=`echo "${SUSPSCAN_STRING}" | cut -d: -f1`
								SUSPSCAN_TERM=`echo "${SUSPSCAN_STRING}" | cut -d: -f2-`
							 	;;
						esac

						#
						# Searchterm with multiplier
						#

						case "${SUSPSCAN_STRING}" in
						*+[0-9][0-9]*) 
							  	SUSPSCAN_TERM=`echo "${SUSPSCAN_TERM}" | cut -d'+' -f1`
							  	SUSPSCAN_MULTIPLIER=`echo "${SUSPSCAN_STRING}" | cut -d'+' -f2`
								;;
						esac

						grep -i ${SUSPSCAN_TERM} ${FILENAME} >/dev/null 2>&1
						ERRCODE=$?

						if [ $ERRCODE -eq 0 ]; then

							if [ "$SUSPSCAN_CLASS" = "$SUSPSCAN_CLASS_PREV" ]; then
								SUSPSCAN_SCORE=`expr ${SUSPSCAN_SCORE} + 10`
							fi

							SUSPSCAN_HITS="$SUSPSCAN_NUM ${SUSPSCAN_HITS}"

							if [ -n "$SUSPSCAN_MULTIPLIER" ]; then
								SUSPSCAN_SCORE=`expr ${SUSPSCAN_SCORE} + ${SUSPSCAN_MULTIPLIER}` 
								unset SUSPSCAN_MULTIPLIER
							else
								SUSPSCAN_SCORE=`expr ${SUSPSCAN_SCORE} + 1`
							fi

							SUSPSCAN_HITCOUNT=`expr $SUSPSCAN_HITCOUNT + 1`

							SUSPSCAN_STRINGS="${SUSPSCAN_STRINGS} ${SUSPSCAN_TERM}"

							SUSPSCAN_CLASS_PREV="$SUSPSCAN_CLASS"
						fi

						SUSPSCAN_NUM=`expr ${SUSPSCAN_NUM} + 1`
					done

					if [ $SUSPSCAN_DEBUG -eq 1 ]; then
						echo "6 SUSPSCAN_FILE_CHECK_DEBUG "${SUSPSCAN_ITEM}" "$SUSPSCAN_SCORE" "$SUSPSCAN_HITCOUNT" "${SUSPSCAN_STRINGS}"" >> "${SUSPSCAN_TMPFILE}"
					else
						if [ $VERBOSE_LOGGING -eq 1 ]; then
							echo "6 SUSPSCAN_FILE_CHECK "${SUSPSCAN_ITEM}" "$SUSPSCAN_SCORE"" >> "${SUSPSCAN_TMPFILE}"
						fi
					fi

					if [ $SUSPSCAN_SCORE -ge $SUSPSCAN_THRESH ]; then
						echo "SUSPSCAN_INSPECT "${SUSPSCAN_ITEM}" "$SUSPSCAN_SCORE"" >> "${SUSPSCAN_TMPFILE}"
					fi

					unset SUSPSCAN_TERM

				#
				# Compressed or obfuscated
				#

				elif [ -n "`echo \"${FTYPE}\" | grep 'corrupted section header size'`" ]; then
					echo "6 SUSPSCAN_FILE_SKIPPED_TYPE "${SUSPSCAN_ITEM}" "Possible UPX-compressed or Dexter01s obfuscated binary"" >> "${SUSPSCAN_TMPFILE}"

				#
				# ELF ultimate compression kit (ELFuck)
				#

				elif [ -n "`echo \"${FTYPE}\" | grep 'invalid class invalid byte order'`" ]; then
					echo "6 SUSPSCAN_FILE_SKIPPED_TYPE "${SUSPSCAN_ITEM}" "Possible ELFuck obfuscated binary"" >> "${SUSPSCAN_TMPFILE}"
				elif [ $VERBOSE_LOGGING -eq 1 ]; then
					echo "6 SUSPSCAN_FILE_SKIPPED_TYPE "${SUSPSCAN_ITEM}" "${FTYPE}"" >> "${SUSPSCAN_TMPFILE}"
				fi
			done

		else
			echo "4 SUSPSCAN_DIR_NOT_EXIST "${SUSPSCAN_DIR}"" >> "${SUSPSCAN_TMPFILE}"
		fi
	done

	rm -f "${SUSPSCAN_TEMP}/suspscan.*.strings" >/dev/null 2>&1


	#
	# Now display the results.
	#
	
	cat "${SUSPSCAN_TMPFILE}" | while read LINE; do
		LOGCHAR=`echo "$LINE" | cut -c 1`
		case "$LOGCHAR" in
			4|6)	LOGTYPE=`echo "$LINE" | cut -d ' ' -f 2`
				case "$LOGTYPE" in
					SUSPSCAN_FILE_SKIPPED_TYPE)
						SUSP_SKIP_ITEM=`echo "$LINE" | cut -d ' ' -f 3`
						SUSP_SKIP_MSG=`echo "$LINE" | cut -d ' ' -f 4-`
						display --to LOG --type PLAIN --log-indent $LOGCHAR $LOGTYPE "${SUSP_SKIP_ITEM}" "${SUSP_SKIP_MSG}"
					;;
					*)
						display --to LOG --type PLAIN --log-indent $LINE
					;;
				esac
			;;
			S)	
				display --to LOG --type WARNING $LINE
			;;
		esac
	done

	FOUNDDIRS=`grep "SUSPSCAN_FILE_CHECK" "${SUSPSCAN_TMPFILE}" | head -n 1`
	if [ -z "${FOUNDDIRS}" ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 SUSPSCAN_CHECK
	else
		# The 'type' here should be PLAIN, but the loop prevents RKH from seeing that a warning has occurred.
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 SUSPSCAN_CHECK
	fi

	rm -f "${SUSPSCAN_TMPFILE}"

	return
}


do_system_commands_checks() {

	#
	# This function carries out a sequence of tests on
	# system commands. These consist of the 'strings' command
	# check, library checks and the file properties checks.
	#

	if `check_test system_commands`; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_SYS_COMMANDS
		display --to LOG --type INFO STARTING_TEST system_commands
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST system_commands
		return
	fi


	strings_check

	shared_libs_check

	file_properties_check

	keypresspause

	return
}


rootkit_file_dir_checks() {

	#
	# This function performs the check for known rootkit
	# files and directories.
	#

	if `check_test known_rkts`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_FILES_DIRS_START
		display --to LOG --type INFO STARTING_TEST known_rkts
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST known_rkts
		return
	fi


	# 55808 Trojan - Variant A

	SCAN_ROOTKIT="55808 Trojan - Variant A"
	SCAN_FILES=${W55808A_FILES}
	SCAN_DIRS=${W55808A_DIRS}
	SCAN_KSYMS=${W55808A_KSYMS}
	scanrootkit

	# ADM Worm

	SCAN_ROOTKIT="ADM Worm"

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi

	if [ -f "${RKHROOTDIR}/etc/passwd" ]; then
		RKHTMPVAR=`grep 'w0rm' ${RKHROOTDIR}/etc/passwd`

		if [ -z "${RKHTMPVAR}" ]; then
			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "w0rm"
			fi

			display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 NAME "${SCAN_ROOTKIT}"
		else
			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_STR "w0rm"
			fi

			display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_STR_FOUND "w0rm" "${RKHROOTDIR}/etc/passwd"
		fi
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
		display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_NOFILE "${RKHROOTDIR}/etc/passwd"
	fi

	# AjaKit Rootkit

	SCAN_ROOTKIT="AjaKit Rootkit"
	SCAN_FILES=${AJAKIT_FILES}
	SCAN_DIRS=${AJAKIT_DIRS}
	SCAN_KSYMS=${AJAKIT_KSYMS}
	scanrootkit

	# "Adore" Rootkit

	SCAN_ROOTKIT="Adore Rootkit"
	SCAN_FILES=${AKIT_FILES}
	SCAN_DIRS=${AKIT_DIRS}
	SCAN_KSYMS=${AKIT_KSYMS}
	scanrootkit

	# aPa Kit

	SCAN_ROOTKIT="aPa Kit"
	SCAN_FILES=${APAKIT_FILES}
	SCAN_DIRS=${APAKIT_DIRS}
	SCAN_KSYMS=${APAKIT_KSYMS}
	scanrootkit

	# Apache worm

	SCAN_ROOTKIT="Apache Worm"
	SCAN_FILES=${APACHEWORM_FILES}
	SCAN_DIRS=${APACHEWORM_DIRS}
	SCAN_KSYMS=${APACHEWORM_KSYMS}
	scanrootkit

	# Ambient (ark) Rootkit

	SCAN_ROOTKIT="Ambient (ark) Rootkit"
	SCAN_FILES=${ARK_FILES}
	SCAN_DIRS=${ARK_DIRS}
	SCAN_KSYMS=${ARK_KSYMS}
	scanrootkit

	# Balaur Rootkit

	SCAN_ROOTKIT="Balaur Rootkit"
	SCAN_FILES=${BALAUR_FILES}
	SCAN_DIRS=${BALAUR_DIRS}
	SCAN_KSYMS=${BALAUR_KSYMS}
	scanrootkit

	# BeastKit Rootkit

	SCAN_ROOTKIT="BeastKit Rootkit"
	SCAN_FILES=${BEASTKIT_FILES}
	SCAN_DIRS=${BEASTKIT_DIRS}
	SCAN_KSYMS=${BEASTKIT_KSYMS}
	scanrootkit

	# beX2 Rootkit

	SCAN_ROOTKIT="beX2 Rootkit"
	SCAN_FILES=${BEX_FILES}
	SCAN_DIRS=${BEX_DIRS}
	SCAN_KSYMS=${BEX_KSYMS}
	scanrootkit

	# BOBKit Rootkit

	SCAN_ROOTKIT="BOBKit Rootkit"
	SCAN_FILES=${BOBKIT_FILES}
	SCAN_DIRS=${BOBKIT_DIRS}
	SCAN_KSYMS=${BOBKIT_KSYMS}
	scanrootkit

	# cb Rootkit
	SCAN_ROOTKIT="cb Rootkit"
	SCAN_FILES=${CB_FILES}
	SCAN_DIRS=${CB_DIRS}
	SCAN_KSYMS=${CB_KSYMS}
	scanrootkit

	# CiNIK Worm (Slapper.B variant)

	SCAN_ROOTKIT="CiNIK Worm (Slapper.B variant)"
	SCAN_FILES=${CINIK_FILES}
	SCAN_DIRS=${CINIK_DIRS}
	SCAN_KSYMS=${CINIK_KSYMS}
	scanrootkit

	# CX Rootkit

	if [ $SUNOS -eq 1 ]; then
		SCAN_ROOTKIT="CX Rootkit"
		SCAN_FILES=${CXKIT_FILES}
		SCAN_DIRS=${CXKIT_DIRS}
		SCAN_KSYMS=${CXKIT_KSYMS}
		scanrootkit
	fi

	# Danny-Boy's Abuse Kit

	SCAN_ROOTKIT="Danny-Boy's Abuse Kit"
	SCAN_FILES=${DANNYBOYS_FILES}
	SCAN_DIRS=${DANNYBOYS_DIRS}
	SCAN_KSYMS=${DANNYBOYS_KSYMS}
	scanrootkit

	# Devil RootKit

	SCAN_ROOTKIT="Devil RootKit"
	SCAN_FILES=${DEVIL_FILES}
	SCAN_DIRS=${DEVIL_DIRS}
	SCAN_KSYMS=${DEVIL_KSYMS}
	scanrootkit

	# Dica-Kit Rootkit

	SCAN_ROOTKIT="Dica-Kit Rootkit"
	SCAN_FILES=${DICA_FILES}
	SCAN_DIRS=${DICA_DIRS}
	SCAN_KSYMS=${DICA_KSYMS}
	scanrootkit

	# Dreams RootKit

	SCAN_ROOTKIT="Dreams Rootkit"
	SCAN_FILES=${DREAMS_FILES}
	SCAN_DIRS=${DREAMS_DIRS}
	SCAN_KSYMS=${DREAMS_KSYMS}
	scanrootkit

	# Duarawkz Rootkit

	SCAN_ROOTKIT="Duarawkz Rootkit"
	SCAN_FILES=${DUARAWKZ_FILES}
	SCAN_DIRS=${DUARAWKZ_DIRS}
	SCAN_KSYMS=${DUARAWKZ_KSYMS}
	scanrootkit

	# Enye LKM

	SCAN_ROOTKIT="Enye LKM"
	SCAN_FILES=${ENYELKM_FILES}
	SCAN_DIRS=${ENYELKM_DIRS}
	SCAN_KSYMS=${ENYELKM_KSYMS}
	scanrootkit

	# Flea Linux Rootkit

	SCAN_ROOTKIT="Flea Linux Rootkit"
	SCAN_FILES=${FLEA_FILES}
	SCAN_DIRS=${FLEA_DIRS}
	SCAN_KSYMS=${FLEA_KSYMS}
	scanrootkit

	# FreeBSD Rootkit

	SCAN_ROOTKIT="FreeBSD Rootkit"
	SCAN_FILES=${FREEBSD_RK_FILES}
	SCAN_DIRS=${FREEBSD_RK_DIRS}
	SCAN_KSYMS=${FREEBSD_RK_KSYMS}
	scanrootkit

	# Fu Rootkit

	SCAN_ROOTKIT="Fu Rootkit"
	SCAN_FILES=${FU_FILES}
	SCAN_DIRS=${FU_DIRS}
	SCAN_KSYMS=${FU_KSYMS}
	scanrootkit

	# Fuck`it Rootkit

	SCAN_ROOTKIT="Fuck\`it Rootkit"
	SCAN_FILES=${FUCKIT_FILES}
	SCAN_DIRS=${FUCKIT_DIRS}
	SCAN_KSYMS=${FUCKIT_KSYMS}
	scanrootkit

	# GasKit Rootkit

	SCAN_ROOTKIT="GasKit Rootkit"
	SCAN_FILES=${GASKIT_FILES}
	SCAN_DIRS=${GASKIT_DIRS}
	SCAN_KSYMS=${GASKIT_KSYMS}
	scanrootkit

	# Heroin LKM

	SCAN_ROOTKIT="Heroin LKM"
	SCAN_FILES=${HEROIN_FILES}
	SCAN_DIRS=${HEROIN_DIRS}
	SCAN_KSYMS=${HEROIN_KSYMS}
	scanrootkit

	# HjC Kit

	SCAN_ROOTKIT="HjC Kit"
	SCAN_FILES=${HJCKIT_FILES}
	SCAN_DIRS=${HJCKIT_DIRS}
	SCAN_KSYMS=${HJCKIT_KSYMS}
	scanrootkit

	# ignoKit Rootkit

	SCAN_ROOTKIT="ignoKit Rootkit"
	SCAN_FILES=${IGNOKIT_FILES}
	SCAN_DIRS=${IGNOKIT_DIRS}
	SCAN_KSYMS=${IGNOKIT_KSYMS}
	scanrootkit

	# iLLogiC Rootkit (SunOS Rootkit variant)
	SCAN_ROOTKIT="iLLogiC Rootkit"
	SCAN_FILES=${ILLOGIC_FILES}
	SCAN_DIRS=${ILLOGIC_DIRS}
	SCAN_KSYMS=${ILLOGIC_KSYMS}
	scanrootkit

	# IntoXonia-NG Rootkit

	SCAN_ROOTKIT="IntoXonia-NG Rootkit"
	SCAN_FILES=${INTOXONIA_FILES}
	SCAN_DIRS=${INTOXONIA_DIRS}
	SCAN_KSYMS=${INTOXONIA_KSYMS}
	scanrootkit

	# Irix Rootkit

	SCAN_ROOTKIT="Irix Rootkit"
	SCAN_FILES=${IRIXRK_FILES}
	SCAN_DIRS=${IRIXRK_DIRS}
	SCAN_KSYMS=${IRIXRK_KSYMS}
	scanrootkit

	# Kitko Rootkit

	SCAN_ROOTKIT="Kitko Rootkit"
	SCAN_FILES=${KITKO_FILES}
	SCAN_DIRS=${KITKO_DIRS}
	SCAN_KSYMS=${KITKO_KSYMS}
	scanrootkit

	# Knark Rootkit

	SCAN_ROOTKIT="Knark Rootkit"
	SCAN_FILES=${KNARK_FILES}
	SCAN_DIRS=${KNARK_DIRS}
	SCAN_KSYMS=${KNARK_KSYMS}
	scanrootkit

	# ld-linuxv.so (LD_PRELOAD shared library rootkit)

	SCAN_ROOTKIT="ld-linuxv.so Rootkit"
	SCAN_FILES=${LINUXV_FILES}
	SCAN_DIRS=${LINUXV_DIRS}
	SCAN_KSYMS=${LINUXV_KSYMS}
	scanrootkit

	# Li0n Worm

	SCAN_ROOTKIT="Li0n Worm"
	SCAN_FILES=${LION_FILES}
	SCAN_DIRS=${LION_DIRS}
	SCAN_KSYMS=${LION_KSYMS}
	scanrootkit

	# Lockit / LJK2 Rootkit

	SCAN_ROOTKIT="Lockit / LJK2 Rootkit"
	SCAN_FILES=${LOCKIT_FILES}
	SCAN_DIRS=${LOCKIT_DIRS}
	SCAN_KSYMS=${LOCKIT_KSYMS}
	scanrootkit

	# Mood-NT Rootkit

	SCAN_ROOTKIT="Mood-NT Rootkit"
	SCAN_FILES=${MOODNT_FILES}
	SCAN_DIRS=${MOODNT_DIRS}
	SCAN_KSYMS=${MOODNT_KSYMS}
	scanrootkit

	# MRK (MiCrobul?) RootKit

	SCAN_ROOTKIT="MRK Rootkit"
	SCAN_FILES=${MRK_FILES}
	SCAN_DIRS=${MRK_DIRS}
	SCAN_KSYMS=${MRK_KSYMS}
	scanrootkit

	# Ni0 Rootkit

	SCAN_ROOTKIT="Ni0 Rootkit"
	SCAN_FILES=${NIO_FILES}
	SCAN_DIRS=${NIO_DIRS}
	SCAN_KSYMS=${NIO_KSYMS}
	scanrootkit

	# Ohhara Rootkit

	SCAN_ROOTKIT="Ohhara Rootkit"
	SCAN_FILES=${OHHARA_FILES}
	SCAN_DIRS=${OHHARA_DIRS}
	SCAN_KSYMS=${OHHARA_KSYMS}
	scanrootkit

	# Optic Kit Worm

	SCAN_ROOTKIT="Optic Kit (Tux) Worm"
	SCAN_FILES=${OPTICKIT_FILES}
	SCAN_DIRS=${OPTICKIT_DIRS}
	SCAN_KSYMS=${OPTICKIT_KSYMS}
	scanrootkit

	# OSX Rootkit 0.2.1

	if [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		SCAN_ROOTKIT="OSX Rootkit"
		SCAN_FILES="${OSXRK_FILES}"
		SCAN_DIRS="${OSXRK_DIRS}"
		SCAN_KSYMS=${OSXRK_KSYMS}
		scanrootkit
	fi

	# Oz Rootkit

	SCAN_ROOTKIT="Oz Rootkit"
	SCAN_FILES=${OZ_FILES}
	SCAN_DIRS=${OZ_DIRS}
	SCAN_KSYMS=${OZ_KSYMS}
	scanrootkit

	# Phalanx Rootkit

	SCAN_ROOTKIT="Phalanx Rootkit"
	SCAN_FILES=${PHALANX_FILES}
	SCAN_DIRS=${PHALANX_DIRS}
	SCAN_KSYMS=${PHALANX_KSYMS}
	scanrootkit

	# Phalanx2 Rootkit (dirs and files)

	SCAN_ROOTKIT="Phalanx2 Rootkit"
	SCAN_FILES=${PHALANX2_FILES}
	SCAN_DIRS=${PHALANX2_DIRS}
	SCAN_KSYMS=${PHALANX2_KSYMS}
	scanrootkit

	# Phalanx2 Rootkit (extended tests)

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		SCAN_ROOTKIT="Phalanx2 Rootkit (extended tests)"

		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		ROOTKIT_PHALANX2_TEST=0

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
		fi

		ROOTKIT_PHALANX2_DIRTESTVAL=`get_option 1 single PHALANX2_DIRTEST` || exit 1

		if [ "${ROOTKIT_PHALANX2_DIRTESTVAL}" = "1" ]; then
			ROOTKIT_PHALANX2_DIRNAMES=`find ${RKHROOTDIR}/etc ${RKHROOTDIR}/usr -type d -iname "*.p2"`
		else
			ROOTKIT_PHALANX2_DIRNAMES="${RKHROOTDIR}/etc/khubd.p2 ${RKHROOTDIR}/etc/lolzz.p2 ${RKHROOTDIR}/usr/lib/zupzz.p2"
		fi

		if [ -n "${ROOTKIT_PHALANX2_DIRNAMES}" ]; then

			for ROOTKIT_PHALANX2_DIRNAME in ${ROOTKIT_PHALANX2_DIRNAMES}; do

				if `cd ${ROOTKIT_PHALANX2_DIRNAME} >/dev/null 2>&1`; then
					ROOTKIT_PHALANX2_TEST=1

					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${ROOTKIT_PHALANX2_DIRNAME}"
					fi

					display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
					display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_DIR_FOUND "${ROOTKIT_PHALANX2_DIRNAME}"
				elif [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "${ROOTKIT_PHALANX2_DIRNAME}"
				fi
			done

		elif [ $VERBOSE_LOGGING -eq 1 -a "${ROOTKIT_PHALANX2_DIRTESTVAL}" = "1" ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_DIR "*.p2"
		fi

		if `grep -q '^/dev/root .* ext[23] ' /proc/mounts 2>/dev/null`; then 
			if [ -n "${STAT_CMD}" ]; then
				if [ -n "`echo \"${STAT_CMD}\" | grep '\.pl$'`" ]; then
					NLINKS1=`${STAT_CMD} --nlink /etc 2>/dev/null`
				else
					NLINKS1=`${STAT_CMD} -c %h /etc 2>/dev/null`
				fi

				NLINKS2=`ls -ld /etc 2>/dev/null | awk -F' ' '/^d/ {print $2}' | head -n 1`

				test -z "${NLINKS1}" && NLINKS1=-1
				test -z "${NLINKS2}" && NLINKS2=-2

				if [ $NLINKS1 -ne $NLINKS2 ]; then
					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result WARNING --log-indent 2 ROOTKIT_LINK_COUNT "/etc"

						if [ $NLINKS1 -eq -1 ]; then
							display --to LOG --type PLAIN --log-indent 4 ROOTKIT_LINK_COUNT_CMDERR "${STAT_CMD}" "/etc"
						fi

						if [ $NLINKS2 -eq -2 ]; then
							display --to LOG --type PLAIN --log-indent 4 ROOTKIT_LINK_COUNT_CMDERR "ls -ld" "/etc"
						fi

						display --to LOG --type PLAIN --log-indent 4 ROOTKIT_LINK_COUNT_FAIL "${STAT_CMD}" "$NLINKS1"
						display --to LOG --type PLAIN --log-indent 4 ROOTKIT_LINK_COUNT_FAIL "ls -ld" "$NLINKS2"
					fi

					if [ $ROOTKIT_PHALANX2_TEST -eq 0 ]; then
						ROOTKIT_PHALANX2_TEST=1
						display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
					fi

					display --to LOG --type PLAIN --log-indent 9 ROOTKIT_PHALANX2_LINK_COUNT_FAIL "/etc"
				elif [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result OK --log-indent 2 ROOTKIT_LINK_COUNT "/etc"
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_LINK_COUNT "/etc"
				display --to LOG --type INFO NOT_FOUND_CMD "stat"
			fi
		fi

		# On Linux 2.6 kernels certain processes are children of the kthread process which itself is a child of init.
		# argv[0] hiding in plain sight works OK (who expects '^ata/0$' processes to be illegal?) but if the parent process Id is not kthread's
		# then suspicion is justified. Like other process listing relying on 'ps' the usual process hiding caveat remains.

		if [ -n "${PGREP_CMD}" ]; then
			if [ -n "`${PGREP_CMD} 'ata/0'`" ]; then
				ROOTKIT_PHALANX2_PROC_KTHREAD_PPID=`${PGREP_CMD} -f '^kthread.?$'`
				ROOTKIT_PHALANX2_PROC_ATA_PPID=`${PS_CMD} --no-headers -C 'ata/0' -oppid 2>/dev/null`

				if [ -n "${ROOTKIT_PHALANX2_PROC_ATA_PPID}" -a -n "${ROOTKIT_PHALANX2_PROC_KTHREAD_PPID}" ]; then
					if [ ${ROOTKIT_PHALANX2_PROC_ATA_PPID} -ne ${ROOTKIT_PHALANX2_PROC_KTHREAD_PPID} ]; then
						if [ $VERBOSE_LOGGING -eq 1 ]; then
							display --to LOG --type PLAIN --result WARNING --log-indent 2 ROOTKIT_PHALANX2_PROC_FOUND
							display --to LOG --type PLAIN --log-indent 4 ROOTKIT_PHALANX2_PROC_PPID "${ROOTKIT_PHALANX2_PROC_KTHREAD_PPID}" "${ROOTKIT_PHALANX2_PROC_ATA_PPID}"
						fi

						if [ $ROOTKIT_PHALANX2_TEST -eq 0 ]; then
							ROOTKIT_PHALANX2_TEST=1
							display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
						fi

						display --to LOG --type PLAIN --log-indent 9 ROOTKIT_PHALANX2_PROC_FOUND
					else
						if [ $VERBOSE_LOGGING -eq 1 ]; then
							display --to LOG --type PLAIN --result OK --log-indent 2 ROOTKIT_PHALANX2_PROC
						fi
					fi

				else # ROOTKIT_PHALANX2_PROC_ATA_PPID ps might not support some cmdline args
					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_PHALANX2_PROC
						display --to LOG --type INFO ROOTKIT_PHALANX2_PROC_PS_ERR
					fi
				fi

			#else # This kernel does not run any 'ata/0' kthread child processes, no warning necessary.
			fi

		else # PGREP_CMD
			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_PHALANX2_PROC
				display --to LOG --type INFO NOT_FOUND_CMD "pgrep"
			fi
		fi

		if [ $ROOTKIT_PHALANX2_TEST -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 NAME "${SCAN_ROOTKIT}"
		else
			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "
		fi

	fi

	# Portacelo Rootkit

	SCAN_ROOTKIT="Portacelo Rootkit"
	SCAN_FILES=${PORTACELO_FILES}
	SCAN_DIRS=${PORTACELO_DIRS}
	SCAN_KSYMS=${PORTACELO_KSYMS}
	scanrootkit

	# R3dstorm Toolkit

	SCAN_ROOTKIT="R3dstorm Toolkit"
	SCAN_FILES=${REDSTORM_FILES}
	SCAN_DIRS=${REDSTORM_DIRS}
	SCAN_KSYMS=${REDSTORM_KSYMS}
	scanrootkit

	# RH-Sharpe's Rootkit

	SCAN_ROOTKIT="RH-Sharpe's Rootkit"
	SCAN_FILES=${RHSHARPES_FILES}
	SCAN_DIRS=${RHSHARPES_DIRS}
	SCAN_KSYMS=${RHSHARPES_KSYMS}
	scanrootkit

	# RSHA's Rootkit

	SCAN_ROOTKIT="RSHA's Rootkit"
	SCAN_FILES=${RSHA_FILES}
	SCAN_DIRS=${RSHA_DIRS}
	SCAN_KSYMS=${RSHA_KSYMS}
	scanrootkit

	# Scalper Worm

	SCAN_ROOTKIT="Scalper Worm"
	SCAN_FILES=${SCALPER_FILES}
	SCAN_DIRS=${SCALPER_DIRS}
	SCAN_KSYMS=${SCALPER_KSYMS}
	scanrootkit

	# Sebek LKM (Honeypot)

	SCAN_ROOTKIT="Sebek LKM"

	ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
	fi

	FOUND=0

	if [ -n "${KSYMS_FILE}" ]; then
		egrep -i 'adore|sebek' ${KSYMS_FILE} >/dev/null 2>&1 && FOUND=1
	fi

	if [ $FOUND -eq 0 ]; then
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			if [ -n "${KSYMS_FILE}" ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
			else
				display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
			fi
		fi

		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 NAME "${SCAN_ROOTKIT}"
	else
		ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
		ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result FOUND --log-indent 2 ROOTKIT_FILES_DIRS_KSYM "adore or sebek"
		fi

		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
		display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_KSYM_FOUND "adore or sebek"
	fi

	# Shutdown Rootkit

	SCAN_ROOTKIT="Shutdown Rootkit"
	SCAN_FILES=${SHUTDOWN_FILES}
	SCAN_DIRS=${SHUTDOWN_DIRS}
	SCAN_KSYMS=${SHUTDOWN_KSYMS}
	scanrootkit

	# SHV4 Rootkit

	SCAN_ROOTKIT="SHV4 Rootkit"
	SCAN_FILES=${SHV4_FILES}
	SCAN_DIRS=${SHV4_DIRS}
	SCAN_KSYMS=${SHV4_KSYMS}
	scanrootkit

	# SHV5 Rootkit

	SCAN_ROOTKIT="SHV5 Rootkit"
	SCAN_FILES=${SHV5_FILES}
	SCAN_DIRS=${SHV5_DIRS}
	SCAN_KSYMS=${SHV5_KSYMS}
	scanrootkit

	# Sin Rootkit

	SCAN_ROOTKIT="Sin Rootkit"
	SCAN_FILES=${SINROOTKIT_FILES}
	SCAN_DIRS=${SINROOTKIT_DIRS}
	SCAN_KSYMS=${SINROOTKIT_KSYMS}
	scanrootkit

	# SInAR Rootkit

	if [ $SUNOS -eq 1 ]; then
		FOUND=0
		SINARFILES=""

		SCAN_ROOTKIT="SInAR Rootkit"

		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl ROOTKIT_FILES_DIRS_NAME_LOG "${SCAN_ROOTKIT}"
		fi

		if [ -n "${FIND_CMD}" ]; then
			for DIR in ${BINPATHS}; do
				test ! -d "${RKHROOTDIR}${DIR}" && continue

				FOUNDINDIR="NOT_FOUND"

				for FNAME in `${FIND_CMD} "${RKHROOTDIR}${DIR}" -type f -name "*[sS][iI][nN][aA][rR]*" 2>/dev/null`; do
					if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${FNAME} \"`" ]; then
						display --to LOG --type INFO FILE_PROP_WL "${FNAME}" rootkit
					elif `grep -i 'sinar' ${FNAME} >/dev/null 2>&1`; then
						FOUND=1
						FOUNDINDIR="FOUND"
						SINARFILES="${SINARFILES} ${FNAME}"
					fi
				done

				if [ $VERBOSE_LOGGING -eq 1 ]; then
					display --to LOG --type PLAIN --result "${FOUNDINDIR}" --log-indent 2 ROOTKIT_FILES_DIRS_SINAR_DIR "${RKHROOTDIR}${DIR}"
				fi
			done


			#
			# Now display the result.
			#

			if [ $FOUND -eq 0 ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --screen-indent 4 NAME "${SCAN_ROOTKIT}"
			else
				ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
				ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${SCAN_ROOTKIT}, "

				display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 NAME "${SCAN_ROOTKIT}"
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_FILES_DIRS_SINAR "${SINARFILES}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 NAME "${SCAN_ROOTKIT}"
			display --to LOG --type INFO NOT_FOUND_CMD "find"
		fi
	fi

	# Slapper Worm

	SCAN_ROOTKIT="Slapper Worm"
	SCAN_FILES=${SLAPPER_FILES}
	SCAN_DIRS=${SLAPPER_DIRS}
	SCAN_KSYMS=${SLAPPER_KSYMS}
	scanrootkit

	# Sneakin Rootkit

	SCAN_ROOTKIT="Sneakin Rootkit"
	SCAN_FILES=${SNEAKIN_FILES}
	SCAN_DIRS=${SNEAKIN_DIRS}
	SCAN_KSYMS=${SNEAKIN_KSYMS}
	scanrootkit

	# 'Spanish' Rootkit

	SCAN_ROOTKIT="'Spanish' Rootkit"
	SCAN_FILES=${SPANISH_FILES}
	SCAN_DIRS=${SPANISH_DIRS}
	SCAN_KSYMS=${SPANISH_KSYMS}
	scanrootkit

	# Suckit Rootkit

	SCAN_ROOTKIT="Suckit Rootkit"
	SCAN_FILES=${SUCKIT_FILES}
	SCAN_DIRS=${SUCKIT_DIRS}
	SCAN_KSYMS=${SUCKIT_KSYMS}
	scanrootkit

	# SunOS Rootkit

	SCAN_ROOTKIT="SunOS Rootkit"
	SCAN_FILES=${SUNOSROOTKIT_FILES}
	SCAN_DIRS=${SUNOSROOTKIT_DIRS}
	SCAN_KSYMS=${SUNOSROOTKIT_KSYMS}
	scanrootkit

	# SunOS / NSDAP Rootkit

	SCAN_ROOTKIT="SunOS / NSDAP Rootkit"
	SCAN_FILES=${NSDAP_FILES}
	SCAN_DIRS=${NSDAP_DIRS}
	SCAN_KSYMS=${NSDAP_KSYMS}
	scanrootkit

	# Superkit Rootkit

	SCAN_ROOTKIT="Superkit Rootkit"
	SCAN_FILES=${SUPERKIT_FILES}
	SCAN_DIRS=${SUPERKIT_DIRS}
	SCAN_KSYMS=${SUPERKIT_KSYMS}
	scanrootkit

	# TBD (Telnet BackDoor)

	SCAN_ROOTKIT="TBD (Telnet BackDoor)"
	SCAN_FILES=${TBD_FILES}
	SCAN_DIRS=${TBD_DIRS}
	SCAN_KSYMS=${TBD_KSYMS}
	scanrootkit

	# TeLeKiT Rootkit

	SCAN_ROOTKIT="TeLeKiT Rootkit"
	SCAN_FILES=${TELEKIT_FILES}
	SCAN_DIRS=${TELEKIT_DIRS}
	SCAN_KSYMS=${TELEKIT_KSYMS}
	scanrootkit


	# T0rn Rootkit

	SCAN_ROOTKIT="T0rn Rootkit"
	SCAN_FILES=${TORN_FILES}
	SCAN_DIRS=${TORN_DIRS}
	SCAN_KSYMS=${TORN_KSYMS}
	scanrootkit

	# TrNkit Rootkit

	SCAN_ROOTKIT="trNkit Rootkit"
	SCAN_FILES=${TRNKIT_FILES}
	SCAN_DIRS=${TRNKIT_DIRS}
	SCAN_KSYMS=${TRNKIT_KSYMS}
	scanrootkit

	# Trojanit Kit

	SCAN_ROOTKIT="Trojanit Kit"
	SCAN_FILES=${TROJANIT_FILES}
	SCAN_DIRS=${TROJANIT_DIRS}
	SCAN_KSYMS=${TROJANIT_KSYMS}
	scanrootkit

	# Tuxtendo Rootkit

	SCAN_ROOTKIT="Tuxtendo Rootkit"
	SCAN_FILES=${TUXTENDO_FILES}
	SCAN_DIRS=${TUXTENDO_DIRS}
	SCAN_KSYMS=${TUXTENDO_KSYMS}
	scanrootkit

	# Universal Rootkit by K2 (URK)

	SCAN_ROOTKIT="URK Rootkit"
	SCAN_FILES=${URK_FILES}
	SCAN_DIRS=${URK_DIRS}
	SCAN_KSYMS=${URK_KSYMS}
	scanrootkit

	# Vampire Rootkit

	SCAN_ROOTKIT="Vampire Rootkit"
	SCAN_FILES=${VAMPIRE_FILES}
	SCAN_DIRS=${VAMPIRE_DIRS}
	SCAN_KSYMS=${VAMPIRE_KSYMS}
	scanrootkit

	# VcKit Rootkit

	SCAN_ROOTKIT="VcKit Rootkit"
	SCAN_FILES=${VCKIT_FILES}
	SCAN_DIRS=${VCKIT_DIRS}
	SCAN_KSYMS=${VCKIT_KSYMS}
	scanrootkit

	# Volc Rootkit

	SCAN_ROOTKIT="Volc Rootkit"
	SCAN_FILES=${VOLC_FILES}
	SCAN_DIRS=${VOLC_DIRS}
	SCAN_KSYMS=${VOLC_KSYMS}
	scanrootkit

	# weaponX Rootkit

	if [ "${OPERATING_SYSTEM}" = "Darwin" ]; then
		SCAN_ROOTKIT="weaponX Rootkit"
		SCAN_FILES=${WEAPONX_FILES}
		SCAN_DIRS=${WEAPONX_DIRS}
		SCAN_KSYMS=${WEAPONX_KSYMS}
		scanrootkit
	fi

	# Xzibit Rootkit

	SCAN_ROOTKIT="Xzibit Rootkit"
	SCAN_FILES=${XZIBIT_FILES}
	SCAN_DIRS=${XZIBIT_DIRS}
	SCAN_KSYMS=${XZIBIT_KSYMS}
	scanrootkit

	# X-Org SunOS Rootkit

	SCAN_ROOTKIT="X-Org SunOS Rootkit"
	SCAN_FILES=${XORGSUNOS_FILES}
	SCAN_DIRS=${XORGSUNOS_DIRS}
	SCAN_KSYMS=${XORGSUNOS_KSYMS}
	scanrootkit

	# zaRwT.KiT Rootkit

	SCAN_ROOTKIT="zaRwT.KiT Rootkit"
	SCAN_FILES=${ZARWT_FILES}
	SCAN_DIRS=${ZARWT_DIRS}
	SCAN_KSYMS=${ZARWT_KSYMS}
	scanrootkit

	# ZK Rootkit

	SCAN_ROOTKIT="ZK Rootkit"
	SCAN_FILES=${ZK_FILES}
	SCAN_DIRS=${ZK_DIRS}
	SCAN_KSYMS=${ZK_KSYMS}
	scanrootkit

	return
}


possible_rootkit_file_dir_checks() {

	#
	# This function performs the check for possible rootkit
	# files and directories.
	#

	if `check_test possible_rkt_files`; then
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_POSS_FILES_DIRS_LOG
		fi

		display --to LOG --type INFO STARTING_TEST possible_rkt_files
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST possible_rkt_files
		return
	fi

	FOUND=0
	FOUNDFILES=""
	FOUNDDIRS=""

	IFS=$IFSNL

	for RKHTMPVAR in ${FILESCAN}; do
		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

		RKHTMPVAR=`echo ${RKHTMPVAR} | sed -e 's/^[ 	]*//'`

		TYPE=`echo ${RKHTMPVAR} | cut -d: -f1`
		FILE=`echo ${RKHTMPVAR} | cut -d: -f2`
		INFO=`echo ${RKHTMPVAR} | cut -d: -f3`

		case "${TYPE}" in
		dir)
			if [ -d "${FILE}" ]; then
				RKHTMPVAR2=`echo "${FILE}" | sed -e 's/\./\\\./g'`

				if [ -n "`echo \"${RTKT_DIR_WHITELIST}\" | grep \" ${RKHTMPVAR2} \"`" ]; then
					display --to LOG --type INFO FILE_PROP_WL_DIR "${FILE}" possible_rkt_files
					test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${FILE}"
				else
					FOUND=1
					FOUNDDIRS="${FOUNDDIRS}%${FILE}:${INFO}"

					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${FILE}"
					fi
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${FILE}"
			fi
			;;
		file)
			if [ -f "${FILE}" ]; then
				RKHTMPVAR2=`echo "${FILE}" | sed -e 's/\./\\\./g'`

				if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR2} \"`" ]; then
					display --to LOG --type INFO FILE_PROP_WL "${FILE}" possible_rkt_files
					test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FILE}"
				else
					FOUND=1
					FOUNDFILES="${FOUNDFILES}%${FILE}:${INFO}"

					if [ $VERBOSE_LOGGING -eq 1 ]; then
						display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FILE}"
					fi
				fi
			elif [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FILE}"
			fi
			;;
		*)
			echo "Error: Unknown file type in possible rootkit check: FILESCAN contains: ${TYPE}"
			;;
		esac
	done

	IFS=$RKHIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_POSS_FILES_DIRS
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_POSS_FILES_DIRS

		IFS="%"

		for RKHTMPVAR in ${FOUNDFILES}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f2`

			test -z "${FILE}" && continue

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_FILES_FILE_FOUND "${FILE}" "${INFO}"
		done

		for RKHTMPVAR in ${FOUNDDIRS}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f2`

			test -z "${FILE}" && continue

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_FILES_DIR_FOUND "${FILE}" "${INFO}"
		done

		IFS=$RKHIFS
	fi

	return
}


get_rc_paths() {

	#
	# This function gets a list of the system startup files.
	# Directories are searched for files.
	#
	# This functions will set the variable RC_PATHS.
	#

	RC_PATHS=""
	RKHTMPVAR2=""

	if [ -n "${STARTUP_PATHS}" ]; then
		RKHTMPVAR="${STARTUP_PATHS}"
	else
		RKHTMPVAR="${RCLOCATIONS}"
	fi


	for DIR in ${RKHTMPVAR}; do
		DIR="${RKHROOTDIR}${DIR}"

		test -h "${DIR}" && continue

		if [ -f "${DIR}" ]; then
			RC_PATHS="${RC_PATHS}
${DIR}"
			RKHTMPVAR2="${RKHTMPVAR2} ${DIR}"
		elif [ -d "${DIR}" ]; then
			RKHTMPVAR2="${RKHTMPVAR2} ${DIR}"

			if [ -n "${FIND_CMD}" ]; then
				for FNAME in `${FIND_CMD} ${DIR} -type f -a ! -type l 2>/dev/null`; do
					RC_PATHS="${RC_PATHS}
${FNAME}"
				done
			else
				for FNAME in ${DIR}/*; do
					test -f "${FNAME}" -a ! -h "${FNAME}" && RC_PATHS="${RC_PATHS}
${FNAME}"
				done
			fi
		fi
	done

	if [ $STARTUP_PATHS_LOGGED -eq 0 ]; then
		STARTUP_PATHS_LOGGED=1

		test -z "${RKHTMPVAR2}" && RKHTMPVAR2="${RKHTMPVAR}"

		RKHTMPVAR2=`echo ${RKHTMPVAR2}`
		display --to LOG --type INFO CONFIG_STARTUP_PATHS "${RKHTMPVAR2}"
	fi

	return
}


possible_rootkit_string_checks() {

	#
	# This function performs the check for possible rootkit
	# strings in files.
	#

	if `check_test possible_rkt_strings`; then
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_POSS_STRINGS_LOG
		fi

		display --to LOG --type INFO STARTING_TEST possible_rkt_strings
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST possible_rkt_strings
		return
	fi

	#
	# First check to see that we can run the test.
	#

	if [ -z "${STRINGS_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --screen-indent 4 ROOTKIT_POSS_STRINGS
		display --to LOG --type INFO NOT_FOUND_CMD "strings"
		return
	elif [ "${STARTUP_PATHS}" = "NONE" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color GREEN --screen-indent 4 ROOTKIT_POSS_STRINGS
		display --to LOG --type INFO STARTUP_NONE_GIVEN
		return
	fi


	#
	# Now get and check that the system startup files are okay.
	#

	get_rc_paths

	if [ -z "${RC_PATHS}" ]; then
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 ROOTKIT_POSS_STRINGS
		display --to LOG --type PLAIN --log-indent 9 STARTUP_CHECK_NO_RC_FILES
		return
	fi


	FOUND=0
	FOUNDFILES=""

	IFS=$IFSNL

	for RKHTMPVAR in ${STRINGSCAN}; do
		FOUNDFILE=0
		STRINGFOUND=0
		FOUNDSTRING=""

		RKHTMPVAR=`echo ${RKHTMPVAR} | sed -e 's/^[ 	]*//'`

		FILE=`echo ${RKHTMPVAR} | cut -d: -f1`
		FILESTRING=`echo ${RKHTMPVAR} | cut -d: -f2`
		if [ `echo ${FILESTRING} | cut -c 1` = "+" ]; then
			STRING=`echo ${FILESTRING} | cut -c 2-`
			FILESTRING="${STRING}"
		else
			STRING=`echo ${FILESTRING} | sed -e 's/\./\\\./g'`
		fi
		INFO=`echo ${RKHTMPVAR} | cut -d: -f3`

		if [ "${FILE}" = "rcfile" ]; then
			FOUNDFILE=1

			for FNAME in ${RC_PATHS}; do
				FOUNDSTRING=`${STRINGS_CMD} -n 3 ${FNAME} | grep "${STRING}"`

				if [ -n "${FOUNDSTRING}" ]; then
					RKHTMPVAR2=`echo "${FNAME}" | sed -e 's/\./\\\./g'`

					if [ -z "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR2} \"`" ]; then
						FOUND=1
						STRINGFOUND=1
						FOUNDSTRINGS="${FOUNDSTRINGS}%${FNAME}:${FILESTRING}:${INFO}"
					else
						display --to LOG --type INFO FILE_PROP_WL "${FNAME}" possible_rkt_strings
					fi
				fi
			done
		else
			#
			# We cannot use the 'find_cmd' function here because we
			# are looking at the command binaries themselves, not
			# executing them as commands from the local system.
			#
			# We need to jiggle with IFS here because we are in
			# two loops which are using different field separators.
			#

			IFS=$RKHIFS

			for DIR in ${BINPATHS}; do
				FILENAME="${RKHROOTDIR}${DIR}/${FILE}"

				if [ -f "${FILENAME}" ]; then
					FOUNDFILE=1
					FOUNDSTRING=`${STRINGS_CMD} -n 3 ${FILENAME} | grep "${STRING}"`

					if [ -n "${FOUNDSTRING}" ]; then
						RKHTMPVAR2=`echo "${FILENAME}" | sed -e 's/\./\\\./g'`

						if [ -z "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR2} \"`" ]; then
							FOUND=1
							STRINGFOUND=1
							FOUNDSTRINGS="${FOUNDSTRINGS}%${FILENAME}:${FILESTRING}:${INFO}"
						else
							display --to LOG --type INFO FILE_PROP_WL "${FILENAME}" possible_rkt_strings
						fi
					fi

					break
				fi
			done
		fi

		if [ $FOUNDFILE -eq 1 ]; then
			ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				if [ $STRINGFOUND -eq 0 ]; then
					display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_STR "${FILESTRING}"
				else
					display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_FILES_DIRS_STR "${FILESTRING}"
				fi
			fi
		fi

		IFS=$IFSNL
	done

	IFS=$RKHIFS


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_POSS_STRINGS
	else
		display --to SCREEN+LOG --type WARNING --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_POSS_STRINGS

		IFS="%"

		for RKHTMPVAR in ${FOUNDSTRINGS}; do
			FILE=`echo "${RKHTMPVAR}" | cut -d: -f1`

			test -z "${FILE}" && continue

			FILESTRING=`echo "${RKHTMPVAR}" | cut -d: -f2`

			if [ `echo ${FILESTRING} | cut -c 1` = "+" ]; then
				FILESTRING=`echo ${FILESTRING} | cut -c 2-`
			fi

			INFO=`echo "${RKHTMPVAR}" | cut -d: -f3`

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_POSS_STRINGS_FOUND "${FILESTRING}" "${FILE}" "${INFO}"
		done

		IFS=$RKHIFS
	fi

	return
}


additional_rootkit_checks() {

	#
	# This function performs additional rootkit checks.
	#

	if `check_test additional_rkts`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_ADD_START
		display --to LOG --type INFO STARTING_TEST additional_rkts
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST additional_rkts
		return
	fi

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		suckit_extra_checks
	fi

	possible_rootkit_file_dir_checks

	possible_rootkit_string_checks

	return
}



malware_checks() {

	#
	# This function performs malware checks.
	#

	if `check_test malware`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_MALWARE_START
		display --to LOG --type INFO STARTING_TEST malware
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST malware
		return
	fi


	#
	# First we check for processes using deleted files.
	#

	if `check_test deleted_files`; then
		display --to LOG --type INFO STARTING_TEST deleted_files

		if [ -n "${LSOF_CMD}" ]; then
			FOUND=0
			WHITEPROC=""; BLACKPROC=""

			DELE_FILES=`${LSOF_CMD} -wnlP ${SOLARISX} | grep '(dele' | head -n 1`

			if [ -n "${DELE_FILES}" ]; then
				PIDLIST=" "

				ALLOWPROCDELFILES=`get_option 1 multi ALLOWPROCDELFILE` || exit 1

				IFS=$IFSNL

				for LINE in `${LSOF_CMD} -wnlP ${SOLARISX} | grep '(dele'`; do
					PROC=""

					PID=`echo "${LINE}" | awk '{ print $2 }'`
					NODE=`echo "${LINE}" | awk '{ print $8 }'`
					FNAME=`echo "${LINE}" | awk '{ print $9 }'`

					#
					# Skip any PID's we have already seen.
					#

					test -n "`echo \"${PIDLIST}\" | grep \" $PID \"`" && continue

					#
					# Try and get the running process name.
					#

					if [ $HAVE_READLINK -eq 1 ]; then
						RKHTMPVAR=""

						if [ $SOL_PROC -eq 1 ]; then
							test -h "/proc/${PID}/path/a.out" && RKHTMPVAR=`${READLINK_CMD} -f /proc/${PID}/path/a.out`
						elif [ $SUNOS -eq 0 -o -h "/proc/${PID}/exe" ]; then
							test -h "/proc/${PID}/exe" && RKHTMPVAR=`${READLINK_CMD} -f /proc/${PID}/exe`
						fi

						test -n "${RKHTMPVAR}" && PROC=`echo "${RKHTMPVAR}" | cut -d' ' -f1`
					fi

					if [ -z "${PROC}" ]; then
						if [ $SUNOS -eq 1 ]; then
							PROC=`${LSOF_CMD} -wnlP -p $PID | grep '[ 	]txt[ 	][ 	]*VREG[ 	]' | head -n 1 | awk '{ print $NF }'`
						else
							PROC=`${LSOF_CMD} -wnlP -p $PID | grep '[ 	]txt[ 	][ 	]*REG[ 	]' | awk '{ print $NF }'`
						fi

						test -z "${PROC}" && PROC=`echo "${LINE}" | awk '{ print $1 }'`
					fi

					#
					# If FNAME is not a pathname then look at the NODE.
					#

					if [ -z "`echo \"${FNAME}\" | grep '^/'`" ]; then
						if [ -n "`echo \"${NODE}\" | grep '^/'`" ]; then
							FNAME="${NODE}"
						fi
					fi

					#
					# Strip anything after the pathname.
					#

					if [ -n "`echo \"${FNAME}\" | grep '^/'`" ]; then
						FNAME=`echo "${FNAME}" | cut -d' ' -f1`
					fi

					#
					# Now see if the process is whitelisted.
					#

					PROCWHITELISTED=0
					PROCDELFILES_GIVEN=0

					for RKHTMPVAR in $ALLOWPROCDELFILES; do
						PROCDELFILES_GIVEN=0

						if [ -n "`echo \"${RKHTMPVAR}\" | grep ':/'`" ]; then
							PROCDELFILES_GIVEN=1
							RKHTMPVAR2=`echo "${RKHTMPVAR}" | cut -d: -f1`
						else
							RKHTMPVAR2="${RKHTMPVAR}"
						fi

						if [ "${PROC}" = "${RKHTMPVAR2}" ]; then
							if [ $PROCDELFILES_GIVEN -eq 1 ]; then
								if [ -n "`echo \"${RKHTMPVAR}:\" | grep \":${FNAME}:\"`" ]; then
									PROCWHITELISTED=1
								fi
							else
								PROCWHITELISTED=1
							fi

							break
						fi
					done

					test $HAVE_READLINK -eq 0 && PROC="\"${PROC}\""

					if [ $PROCWHITELISTED -eq 1 ]; then
						if [ $PROCDELFILES_GIVEN -eq 1 ]; then
							if [ -z "`echo \"${WHITEPROC} \" | grep \"${PROC}:${FNAME} \"`" ]; then
								WHITEPROC="${WHITEPROC} ${PROC}:${FNAME}"
							fi
						elif [ -z "`echo \"${WHITEPROC} \" | grep \"${PROC} \"`" ]; then
							WHITEPROC="${WHITEPROC} ${PROC}"
						fi
					else
						FOUND=1
						BLACKPROC="${BLACKPROC}
${PROC} ${PID} ${FNAME}"
					fi


					#
					# Finally add the PID to the seen PID list.
					#

					PIDLIST="$PIDLIST $PID "
				done
			fi


			#
			# Now display the results.
			#

			if [ $FOUND -eq 0 ]; then
				display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES

				display --to LOG --type WARNING ROOTKIT_MALWARE_DELETED_FILES_FOUND

				for LINE in ${BLACKPROC}; do
					PROC=`echo "$LINE" | cut -d' ' -f1`
					PID=`echo "$LINE" | cut -d' ' -f2`
					FNAME=`echo "$LINE" | cut -d' ' -f3`

					test -z "${PROC}" && continue

					display --to LOG --type PLAIN --log-indent 9 ROOTKIT_MALWARE_DELETED_FILES_FOUND_DATA "${PROC}" "${PID}" "${FNAME}"
				done
			fi

			IFS=$RKHIFS

			for RKHTMPVAR in $WHITEPROC; do
				if [ -n "`echo \"${RKHTMPVAR}\" | grep ':/'`" ]; then
					PROC=`echo "${RKHTMPVAR}" | cut -d: -f1`
					FNAME=`echo "${RKHTMPVAR}" | cut -d: -f2`

					display --to LOG --type INFO ROOTKIT_MALWARE_DELETED_FILES_WL "${PROC}" "${FNAME}"
				else
					display --to LOG --type INFO NETWORK_PACKET_CAP_WL "${RKHTMPVAR}"
				fi
			done
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_DELETED_FILES
			display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST deleted_files
	fi


	#
	# Next we check to see if there any running processes
	# using suspicious files.
	#

	if `check_test running_procs`; then
		display --to LOG --type INFO STARTING_TEST running_procs

		if [ -n "${LSOF_CMD}" ]; then
			SUSP_FILES=""

			IFS=$IFSNL

			for RKHTMPVAR in ${SUSP_FILES_INFO}; do
				RKHTMPVAR=`echo ${RKHTMPVAR} | sed -e 's/^[ 	]*//'`

				FILENAME=`echo ${RKHTMPVAR} | cut -d: -f1 | sed -e 's/\./\\\./g'`
				SUSP_FILES="${SUSP_FILES}|${FILENAME}"
			done

			IFS=$RKHIFS

			SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/^|//'`

			#
			# If we have the 'sort' and 'uniq' commands available,
			# then the output will be less and avoids listing any
			# duplicate processes.
			#

			if [ -n "${SORT_CMD}" -a -n "${UNIQ_CMD}" ]; then
				FILENAME=`${LSOF_CMD} -wnlP -F n | grep '^n/' | sed -e 's/^n//' | ${SORT_CMD} | ${UNIQ_CMD} | egrep "/(${SUSP_FILES})\$"`
			else
				FILENAME=`${LSOF_CMD} -wnlP -F n | grep '^n/' | sed -e 's/^n//' | egrep "/(${SUSP_FILES})\$"`
			fi

			if [ -z "${FILENAME}" ]; then
				display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES
			else
				display --to SCREEN+LOG --type WARNING --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES

				SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/|/, /g'`
				SUSP_FILES=`echo "${SUSP_FILES}" | sed -e 's/\\\././g'`
				display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_SUSP_FILES_FOUND "${SUSP_FILES}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_SUSP_FILES
			display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST running_procs
	fi


	#
	# Next we check for any hidden processes.
	#

	if `check_test hidden_procs`; then
		display --to LOG --type INFO STARTING_TEST hidden_procs

		RKHTMPVAR="unhide"
		UNHIDE_CMD=`find_cmd unhide`

		if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
			if [ -n "`uname -r | grep '^2\.6'`" ]; then
				RKHTMPVAR="unhide-linux26"
				UNHIDE_CMD=`find_cmd unhide-linux26`
			fi
		fi

		if [ -n "${UNHIDE_CMD}" ]; then
			HIDDEN_PROCS=`${UNHIDE_CMD} sys | grep '^F' | awk -F':' '{ print $2 }'`

			if [ -z "${HIDDEN_PROCS}" ]; then
				display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
				display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_HIDDEN_PROCS_FOUND "${HIDDEN_PROCS}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_MALWARE_HIDDEN_PROCS
			display --to LOG --type INFO NOT_FOUND_CMD "${RKHTMPVAR}"
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST hidden_procs
	fi


	# 
	# Next we run the check for suspicious file contents.
	# 

	suspscan


	#
	# We have completed the checks which can be enabled/disabled,
	# but we need to be able to exclude or include the rest of the
	# malware checks. As such we do a simple test for 'other_malware'
	# as a test name, and only proceed if it is enabled.
	#

	if `check_test other_malware`; then
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR_LOG
		fi

		display --to LOG --type INFO STARTING_TEST other_malware
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST other_malware
		return
	fi


	#
	# Next we check for login backdoors.
	#

	FOUND=0
	FOUNDFILES=""

	for FILE in ${LOGIN_BACKDOOR_FILES}; do
		if [ -e "${FILE}" ]; then
			RKHTMPVAR=`echo "${FILE}" | sed -e 's/\./\\\./g'`

			if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR} \"`" ]; then
				display --to LOG --type INFO FILE_PROP_WL "${FILE}" other_malware
			else
				FOUND=1
				FOUNDFILES="${FOUNDFILES} ${FILE}"
			fi

			test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_MALWARE_LOGIN_BDOOR_CHK "${FILE}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_MALWARE_LOGIN_BDOOR_CHK "${FILE}"
		fi
	done


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_LOGIN_BDOOR

		for FILE in ${FOUNDFILES}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_LOGIN_BDOOR_FOUND "${FILE}"
		done
	fi


	#
	# Next check for any suspicious directories.
	#

	FOUND=0
	FOUNDDIRS=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR_LOG
	fi

	for DIR in ${SUSPICIOUS_DIRS}; do
		if [ -d "${DIR}" ]; then
			RKHTMPVAR=`echo "${DIR}" | sed -e 's/\./\\\./g'`

			if [ -n "`echo \"${RTKT_DIR_WHITELIST}\" | grep \" ${RKHTMPVAR} \"`" ]; then
				display --to LOG --type INFO FILE_PROP_WL_DIR "${DIR}" other_malware
			else
				FOUND=1
				FOUNDDIRS="${FOUNDDIRS} ${DIR}"
			fi

			test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${DIR}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_DIR "${DIR}"
		fi
	done


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SUSP_DIR

		for DIR in ${FOUNDDIRS}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_SUSP_DIR_FOUND "${DIR}"
		done
	fi


	#
	# Next we check for any software intrusions.
	#

	TRIPWIREFILE="${RKHROOTDIR}/var/lib/tripwire/`uname -n 2>/dev/null`.twd"

	if [ -f "${TRIPWIREFILE}" ]; then
		if [ -z "`grep 'Tripwire segment-faulted !' ${TRIPWIREFILE}`" ]; then
			display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
			display --to LOG --type WARNING --log-indent 2 ROOTKIT_MALWARE_SFW_INTRUSION_FOUND "${TRIPWIREFILE}" "Tripwire segment-faulted"
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 --log-nl ROOTKIT_MALWARE_SFW_INTRUSION
		display --to LOG --type INFO ROOTKIT_MALWARE_SFW_INTRUSION_SKIP
	fi


	#
	# Next, check for sniffer log files.
	#

	FOUND=0
	FOUNDFILES=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_MALWARE_SNIFFER_LOG
	fi

	for FNAME in ${SNIFFER_FILES}; do
		if [ -f "${FNAME}" ]; then
			RKHTMPVAR=`echo "${FNAME}" | sed -e 's/\./\\\./g'`

			if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR} \"`" ]; then
				display --to LOG --type INFO FILE_PROP_WL "${FNAME}" other_malware
			else
				FOUND=1
				FOUNDFILES="${FOUNDFILES} ${FNAME}"
			fi

			test $VERBOSE_LOGGING -eq 1 && display --to LOG --type PLAIN --result FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FNAME}"
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NOT_FOUND --log-indent 4 ROOTKIT_FILES_DIRS_FILE "${FNAME}"
		fi
	done


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SNIFFER
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_MALWARE_SNIFFER

		for FNAME in ${FOUNDFILES}; do
			display --to LOG --type WARNING ROOTKIT_MALWARE_SNIFFER_FOUND "${FNAME}"
		done
	fi

	return
}


xinetd_include() {

	#
	# This function handles the xinetd 'include' directive.
	# It is also used to initially process the xinetd.conf
	# file, and to process any files within an 'includedir'
	# directory.
	#
	# Any filename containing a dot or ending in a tilde (~)
	# is ignored. Also absolute pathnames must be used.
	#

	test -z "$1" -o ! -f "${RKHROOTDIR}$1" && return
	test -z "`echo \"$1\" | grep '^/'`" && return

	test -n "`echo \"$1\" | grep '/[^/]*\.[^/]*$'`" -a "$1" != "${XINETD_CONF_PATH}" && return
	test -n "`echo \"$1\" | grep '~$'`" && return


	#
	# First see if any services have been enabled.
	#

	if [ -n "`grep '^[ 	]*disable[ 	]*=[ 	]*no' ${RKHROOTDIR}$1`" ]; then
		#
		# See if the file is whitelisted.
		#

		RKHTMPVAR=0

		for FNAME in ${XINETDALLOWEDSVCS}; do
			if [ "${FNAME}" = "$1" ]; then
				RKHTMPVAR=1
				break
			fi
		done

		if [ $RKHTMPVAR -eq 0 ]; then
			FOUND=1
			FOUNDFILES="${FOUNDFILES} ${RKHROOTDIR}$1"

			if [ $VERBOSE_LOGGING -eq 1 ]; then
				display --to LOG --type PLAIN --result WARNING --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${RKHROOTDIR}$1"
			fi
		elif [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --result NONE_FOUND --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${RKHROOTDIR}$1"
			display --to LOG --type INFO ROOTKIT_TROJAN_XINETD_WHITELIST "$1" "xinetd"
		fi
	elif [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --result NONE_FOUND --log-indent 4 ROOTKIT_TROJAN_XINETD_ENABLED "${RKHROOTDIR}$1"
	fi


	#
	# Next we look for any 'include' directives.
	#

	for FNAME in `grep '^[ 	]*include[ 	]' ${RKHROOTDIR}$1 | awk '{ print $2 }'`; do
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 6 ROOTKIT_TROJAN_XINETD_INCLUDE "${FNAME}"
		fi

		xinetd_include "${FNAME}"
	done


	#
	# Finally we look for any 'includedir' directives.
	#

	for DIR in `grep '^[ 	]*includedir[ 	]' ${RKHROOTDIR}$1 | awk '{ print $2 }'`; do
		if [ $VERBOSE_LOGGING -eq 1 ]; then
			display --to LOG --type PLAIN --log-indent 6 ROOTKIT_TROJAN_XINETD_INCLUDEDIR "${DIR}"
		fi

		xinetd_includedir "${DIR}"
	done

	return
}


xinetd_includedir() {

	#
	# This function handles the xinetd 'includedir' directive.
	#
	# Absolute pathnames must be used.
	#

	test -z "$1" -o ! -d "${RKHROOTDIR}$1" && return
	test -z "`echo \"$1\" | grep '^/'`" && return


	for FNAME in `ls ${RKHROOTDIR}$1`; do
		xinetd_include "$1/${FNAME}"
	done

	return
}


sol10_inetd() {

	#
	# This function handles the Solaris 10, and later, inetd
	# configuration. Because the original inetd.conf file may
	# well exist, we look in there as well for any enabled services.
	#
	# This function sets the FOUNDSTRING variable, which will
	# be used later.
	#

	FOUNDSTRING=`${INETADM_CMD} | grep '^enabled' | cut -d: -f2`

	if [ -f "${RKHROOTDIR}${INETD_CONF_PATH}" ]; then
		STR=`grep -v '^#' ${RKHROOTDIR}${INETD_CONF_PATH} | awk '{ print $1 }'`

		#
		# Remove any inetd services which we already know
		# about from inetadm.
		#

		for RKHTMPVAR in ${STR}; do
			if [ -z "`echo \"${FOUNDSTRING}\" | grep \"/${RKHTMPVAR}/\"`" ]; then
				FOUNDSTRING="${FOUNDSTRING} ${RKHTMPVAR}"
			fi
		done
	fi

	return
}


trojan_checks() {

	#
	# This function performs some trojan specific checks.
	#

	if ! `check_test trojans`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST trojans
		return
	fi


	#
	# We first need to see if we are running Solaris 10 or later.
	# Earlier versions of Solaris used the standard inetd configuration
	# file, but later versions use a different mechanism. The 'inetadm'
	# command can be used on these later Solaris versions.
	#

	if [ $SUNOS -eq 1 ]; then
		INETADM_CMD=`find_cmd inetadm`

		test -n "${INETADM_CMD}" && sol10_inetd
	else
		INETADM_CMD=""
	fi


	if [ -f "${RKHROOTDIR}${INETD_CONF_PATH}" -o -f "${RKHROOTDIR}${XINETD_CONF_PATH}" -o -n "${INETADM_CMD}" ]; then
		RKHTMPVAR="SCREEN+LOG"
	else
		RKHTMPVAR="LOG"
	fi

	display --to "${RKHTMPVAR}" --type PLAIN --nl --screen-indent 2 ROOTKIT_TROJAN_START

	display --to LOG --type INFO STARTING_TEST trojans


	#
	# We first check the inetd.conf file. This includes the
	# Solaris 10 inetd services as well.
	#

	if [ -f "${RKHROOTDIR}${INETD_CONF_PATH}" -o -n "${INETADM_CMD}" ]; then
		if [ -z "${INETADM_CMD}" ]; then
			display --to LOG --type INFO CONFIG_XINETD_PATH "inetd" "${INETD_CONF_PATH}"

			FOUNDSTRING=`grep -v '^#' ${RKHROOTDIR}${INETD_CONF_PATH} | awk '{ print $1 }'`
		else
			display --to LOG --type INFO CONFIG_SOL10_INETD
		fi

		#
		# We now need to see if any of the services are whitelisted.
		#

		RKHTMPVAR=""

		for STR in ${FOUNDSTRING}; do
			FOUND=0

			for SVC in ${INETDALLOWEDSVCS}; do
				if [ "${STR}" = "${SVC}" ]; then
					FOUND=1
					display --to LOG --type INFO ROOTKIT_TROJAN_XINETD_WHITELIST "${SVC}" "inetd"
					break
				fi
			done

			if [ $FOUND -eq 0 ]; then
				#
				# We want to change any RPC services into
				# an actual executable name, if we can. The
				# executable is the sixth field. If the
				# sixth field is empty or this is an internal
				# service, then we just use the service name.
				#

				if [ -n "`echo \"${STR}\" | grep '^[0-9/_-]*$'`" ]; then
					EXECNAME=`grep "^${STR}" ${RKHROOTDIR}${INETD_CONF_PATH} | awk '{ print $6 }'`

					test -z "${EXECNAME}" -o "${EXECNAME}" = "internal" && EXECNAME="${STR}"

					STR="${EXECNAME}"


					#
					# Now check if the executable has been whitelisted.
					#

					for SVC in ${INETDALLOWEDSVCS}; do
						if [ "${STR}" = "${SVC}" ]; then
							FOUND=1
							display --to LOG --type INFO ROOTKIT_TROJAN_XINETD_WHITELIST "${SVC}" "inetd"
							break
						fi
					done
				fi

				test $FOUND -eq 0 && RKHTMPVAR="${RKHTMPVAR} ${STR}"
			fi
		done

		FOUNDSTRING="${RKHTMPVAR}"


		#
		# Now display the results.
		#

		if [ -z "${FOUNDSTRING}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --screen-indent 4 --log-indent 2 ROOTKIT_TROJAN_INETD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --screen-indent 4 --log-indent 2 ROOTKIT_TROJAN_INETD

			for STR in ${FOUNDSTRING}; do
				display --to LOG --type WARNING ROOTKIT_TROJAN_INETD_FOUND "${STR}"
			done
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_TROJAN_INETD
		display --to LOG --type INFO ROOTKIT_TROJAN_INETD_SKIP "${RKHROOTDIR}${INETD_CONF_PATH}"
	fi


	#
	# Next we check the xinetd.conf file.
	#

	FOUND=0
	FOUNDFILES=""

	if [ $VERBOSE_LOGGING -eq 1 ]; then
		display --to LOG --type PLAIN --nl --log-indent 2 ROOTKIT_TROJAN_XINETD_LOG
	fi

	if [ -f "${RKHROOTDIR}${XINETD_CONF_PATH}" ]; then
		display --to LOG --type INFO CONFIG_XINETD_PATH "xinetd" "${XINETD_CONF_PATH}"

		xinetd_include "${XINETD_CONF_PATH}"


		#
		# Now display the results.
		#

		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_XINETD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_XINETD

			for FNAME in ${FOUNDFILES}; do
				display --to LOG --type WARNING ROOTKIT_TROJAN_XINETD_ENABLED_FOUND "${FNAME}"
			done
		fi
	else
		display --to LOG --type PLAIN --result SKIPPED --log-indent 2 ROOTKIT_TROJAN_XINETD
		display --to LOG --type INFO ROOTKIT_TROJAN_INETD_SKIP "${RKHROOTDIR}${XINETD_CONF_PATH}"
	fi


	#
	# Finally we check for an Apache backdoor module.
	#

	FOUND=0
	FOUNDFILES=""

	MOD_DIRS="${RKHROOTDIR}/etc/apache2/mods-enabled ${RKHROOTDIR}/etc/httpd/modules ${RKHROOTDIR}/usr/apache/libexec ${RKHROOTDIR}/usr/lib/modules ${RKHROOTDIR}/usr/local/apache/modules"

	HTTPDDIRS="${RKHROOTDIR}/usr/local/apache/conf ${RKHROOTDIR}/usr/local/etc/apache ${RKHROOTDIR}/etc/apache ${RKHROOTDIR}/etc/httpd/conf"

	for DIR in ${MOD_DIRS} ${HTTPDDIRS}; do
		if [ -d "${DIR}" ]; then
			FOUND=1

			test -f "${DIR}/mod_rootme.so" && FOUNDFILES="${FOUNDFILES} ${DIR}/mod_rootme.so"
			test -f "${DIR}/mod_rootme2.so" && FOUNDFILES="${FOUNDFILES} ${DIR}/mod_rootme2.so"

			if [ -f "${DIR}/httpd.conf" ]; then
				if [ -n "`egrep 'mod_rootme2?\.so' ${DIR}/httpd.conf`" ]; then
					FOUNDFILES="${FOUNDFILES} ${DIR}/httpd.conf"
				fi
			fi
		fi
	done


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to LOG --type INFO ROOTKIT_TROJAN_APACHE_SKIPPED
	elif [ -z "${FOUNDFILES}" ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_APACHE
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_TROJAN_APACHE

		for FILE in ${FOUNDFILES}; do
			display --to LOG --type WARNING ROOTKIT_TROJAN_APACHE_FOUND "${FILE}"
		done
	fi

	return
}


bsd_specific_checks() {

	#
	# This function performs tests specific to the BSD O/S.
	#


	SOCKSTAT_CMD=`find_cmd sockstat`

	if [ -n "${SOCKSTAT_CMD}" -a -n "${NETSTAT_CMD}" -a -n "${SORT_CMD}" -a -n "${UNIQ_CMD}" ]; then
		SOCKSTAT_OUTPUT=`${SOCKSTAT_CMD} -n | grep '\*[:.]\*' | cut -c1-55 | grep '\*[:.]' | cut -c39-47 | grep -v '\*' | tr -d ' ' | ${SORT_CMD} | ${UNIQ_CMD}`
		NETSTAT_OUTPUT=`${NETSTAT_CMD} -an | egrep -v 'TIME_WAIT|ESTABLISHED|SYN_SENT|CLOSE_WAIT|LAST_ACK|SYN_RECV|CLOSING' | cut -c1-44 | grep '\*\.' | cut -c24-32 | grep -v '\*' | tr -d ' ' | tr -d '\t' | ${SORT_CMD} | ${UNIQ_CMD}`

		if [ "${SOCKSTAT_OUTPUT}" = "${NETSTAT_OUTPUT}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET

			display --to LOG --type WARNING ROOTKIT_OS_BSD_SOCKNET_FOUND
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_BSD_SOCKNET_OUTPUT "Sockstat" "${SOCKSTAT_OUTPUT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_BSD_SOCKNET_OUTPUT "Netstat" "${NETSTAT_OUTPUT}"
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_BSD_SOCKNET

		test -z "${SOCKSTAT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sockstat"
		test -z "${NETSTAT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "netstat"
		test -z "${SORT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sort"
		test -z "${UNIQ_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "uniq"
	fi

	return
}


freebsd_specific_checks() {

	#
	# This function performs tests specific to the FreeBSD O/S.
	#


	#
	# First we check for KLD backdoors.
	#

	KLDSTAT_CMD=`find_cmd kldstat`

	if [ -n "${KLDSTAT_CMD}" ]; then
		FOUND=0
		FOUNDKEYS=""

		for RKHTMPVAR in ${KLDSTATKEYWORDS}; do
			RKHTMPVAR=`echo ${RKHTMPVAR}`

			KLDKEYWD=`echo ${RKHTMPVAR} | sed -e 's/\./\\\./g'`

			if [ -n "`${KLDSTAT_CMD} -v | grep \"${KLDKEYWD}\"`" ]; then
				FOUND=1
				FOUNDKEYS="${FOUNDKEYS} ${RKHTMPVAR} "
			fi
		done


		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD

			for RKHTMPVAR in ${FOUNDKEYS}; do
				display --to LOG --type WARNING ROOTKIT_OS_FREEBSD_KLD_FOUND "${RKHTMPVAR}"
			done
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_KLD

		display --to LOG --type INFO NOT_FOUND_CMD "kldstat"
	fi


	#
	# Next we check that the package database is okay.
	#

	PKGDB_CMD=`find_cmd pkgdb`

	if [ -n "${PKGDB_CMD}" ]; then
		RKHTMPVAR=`${PKGDB_CMD} -Fa -v | grep 'Skipped\.'`

		if [ -z "${RKHTMPVAR}" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB

			display --to LOG --type WARNING ROOTKIT_OS_FREEBSD_PKGDB_NOTOK
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_FREEBSD_PKGDB

		display --to LOG --type INFO NOT_FOUND_CMD "pkgdb"
	fi

	return
}


linux_loaded_modules() {

	#
	# This test checks the currently loaded kernel modules. It verifies
	# that what is seen by the 'lsmod' command is the same as seen in
	# the /proc/modules directory.
	#

	if ! `check_test loaded_modules`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST loaded_modules
		return
	fi


	if [ ! -f "${RKHROOTDIR}/proc/modules" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

		display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_MOD_MISSING "${RKHROOTDIR}/proc/modules"
	elif [ -z "${LSMOD_CMD}" -o -z "${SORT_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

		test -z "${LSMOD_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "lsmod"
		test -z "${SORT_CMD}" && display --to LOG --type INFO NOT_FOUND_CMD "sort"
	else
		PROC_OUTPUT=`cat ${RKHROOTDIR}/proc/modules | cut -d' ' -f1 | ${SORT_CMD}`
		LSMOD_OUTPUT=`${LSMOD_CMD} | grep -v 'Size *Used *by' | cut -d' ' -f1 | ${SORT_CMD}`


		if [ -n "${PROC_OUTPUT}" -a -n "${LSMOD_OUTPUT}" ]; then
			if [ "${PROC_OUTPUT}" = "${LSMOD_OUTPUT}" ]; then
				display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

				display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_FOUND
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "/proc/modules" "${PROC_OUTPUT}"
				display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "lsmod" "${LSMOD_OUTPUT}"
			fi
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKM

			display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKM_EMPTY
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "/proc/modules" "${PROC_OUTPUT}"
			display --to LOG --type PLAIN --log-indent 9 ROOTKIT_OS_LINUX_LKM_OUTPUT "lsmod" "${LSMOD_OUTPUT}"
		fi
	fi

	return
}


linux_avail_modules() {

	#
	# This test checks the names of the kernel
	# modules that are available on this system.
	#

	if ! `check_test avail_modules`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST avail_modules
		return
	fi


	#
	# First obtain and log where the modules are kept. This can
	# be set in the configuration file, but generally rkhunter
	# will determine the location based on the kernel version.
	# However, in the case of remote diagnostics the diagnosing
	# and diagnosed kernel versions may be different. In this
	# case we simply look in '/lib/modules'.
	#

	FOUND=0
	FOUNDFILES=""
	LKM_PATH=""
	LKM_NAMES=""

	RKHTMPVAR=`get_option 1 single MODULES_DIR` || exit 1

	if [ -n "${RKHTMPVAR}" ]; then
		LKM_PATH="${RKHTMPVAR}"
	elif [ -z "${RKHROOTDIR}" ]; then
		LKM_PATH="/lib/modules/`uname -r 2>/dev/null`"
		test ! -d "${LKM_PATH}" && LKM_PATH="/lib/modules"
	else
		LKM_PATH="${RKHROOTDIR}/lib/modules"
	fi

	display --to LOG --type INFO ROOTKIT_OS_LINUX_LKMNAMES_PATH "${LKM_PATH}"


	#
	# Next, we reformat the LKM names at this point since
	# we only need to do it once.
	#

	for RKHTMPVAR in ${LKM_BADNAMES}; do
		RKHTMPVAR=`echo ${RKHTMPVAR} | sed -e 's/\./\\\./g'`

		LKM_NAMES="${LKM_NAMES} ${RKHTMPVAR}"
	done


	#
	# Now do the test.
	#

	if [ ! -d "${LKM_PATH}" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

		display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKMNAMES_PATH_MISSING "${LKM_PATH}"
	elif [ -z "${FIND_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

		display --to LOG --type INFO NOT_FOUND_CMD "find"
	elif [ -z "`ls -1 ${LKM_PATH} 2>/dev/null`" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

		display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKMNAMES_PATH_MISSING "${LKM_PATH}"
	else
		for FNAME in `${FIND_CMD} ${LKM_PATH} -type f -name "*.o" 2>/dev/null`; do
			for RKHTMPVAR in ${LKM_NAMES}; do
				if [ -n "`echo ${FNAME} | grep \"/${RKHTMPVAR}$\"`" ]; then
					FOUND=1
					FOUNDFILES="${FOUNDFILES} ${RKHTMPVAR}"
				fi
			done
		done


		if [ $FOUND -eq 0 ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ROOTKIT_OS_LINUX_LKMNAMES

			for RKHTMPVAR in ${FOUNDFILES}; do
				RKHTMPVAR=`echo "${RKHTMPVAR}" | sed -e 's/\\\././g'`

				display --to LOG --type WARNING ROOTKIT_OS_LINUX_LKMNAMES_FOUND "${LKM_PATH}" "${RKHTMPVAR}"
			done
		fi
	fi

	return
}


linux_specific_checks() {

	#
	# This function performs tests specific to the Linux O/S.
	#

	linux_loaded_modules

	linux_avail_modules

	return
}


os_specific_checks() {

	#
	# This function performs any O/S specific tests.
	#

	if ! `check_test os_specific`; then
		display --to LOG --type INFO --nl USER_DISABLED_TEST os_specific
		return
	fi


	#
	# Run the relevant O/S specific tests.
	#

	case "${OPERATING_SYSTEM}" in
	OpenBSD)
		#
		# There are no specific tests for OpenBSD at present, so we just
		# return. We do not want to log or display anything.
		#

		return
		;;
	*BSD)
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_OS_START "${OPERATING_SYSTEM}"
		display --to LOG --type INFO STARTING_TEST os_specific

		bsd_specific_checks

		test "${OPERATING_SYSTEM}" = "FreeBSD" && freebsd_specific_checks
		;;
	Linux)
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ROOTKIT_OS_START "${OPERATING_SYSTEM}"
		display --to LOG --type INFO STARTING_TEST os_specific

		linux_specific_checks
		;;
	*)
		display --to LOG --type PLAIN --nl ROOTKIT_OS_START "${OPERATING_SYSTEM}"
		display --to LOG --type INFO STARTING_TEST os_specific

		display --to LOG --type INFO ROOTKIT_OS_SKIPPED
		;;
	esac

	return
}


do_rootkit_checks() {

	#
	# This function carries out a sequence of tests for rootkits.
	# This consists of the default files and directories check,
	# possible rootkit checks, and checks for malware.
	#

	if `check_test rootkits`; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_ROOTKITS
		display --to LOG --type INFO STARTING_TEST rootkits
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST rootkits
		return
	fi


	rootkit_file_dir_checks

	test `check_test known_rkts || check_test all` && keypresspause

	additional_rootkit_checks

	malware_checks

	trojan_checks

	os_specific_checks

	keypresspause

	return
}


do_network_port_checks() {

	#
	# This function will check the network ports to see
	# if any known backdoor ports are being used.
	#

	if `check_test ports`; then
		display --to LOG --type INFO STARTING_TEST ports
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST ports
		return
	fi


	#
	# We must first check to see if we can perform this test.
	#

	if [ -z "${LSOF_CMD}" -a -z "${NETSTAT_CMD}" ]; then
		display --to LOG --type INFO TEST_SKIPPED_OS "network port checks" "lsof or netstat command required"
		return
	fi

	#
	# Systems with a modified kernel must also skip this test.
	#

	test $GRSECINSTALLED -eq 1 && return


	#
	# Next we do some further testing and the initial logging.
	#

	display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_PORTS_START

	if [ ! -s "${DB_PATH}/backdoorports.dat" ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 4 NETWORK_PORTS_FILE_MISSING
		return
	elif [ -z "${LSOF_CMD}" ]; then
		case "${OPERATING_SYSTEM}" in
		*BSD|Linux|AIX|SunOS|Darwin|IRIX*)
			#
			# We can only use pathnames if we have the 'lsof' command.
			#

			PORT_WHITELIST_PATH=""
			PORT_WHITELIST_ALL_TRUSTED=0
			display --to LOG --type INFO NETWORK_PORTS_DISABLE_PATHS
			;;
		*)
			display --to SCREEN+LOG --type WARNING --screen-indent 4 NETWORK_PORTS_UNKNOWN_NETSTAT
			return
			;;
		esac
	fi

	test $PORT_WHITELIST_ALL_TRUSTED -eq 1 && display --to LOG --type INFO NETWORK_PORTS_ENABLE_TRUSTED


	#
	# Now do the test.
	#

	IFS=$IFSNL

	for LINE in `cat ${DB_PATH}/backdoorports.dat`; do
		if [ -n "`echo \"${LINE}\" | egrep '^(#|[Vv]ersion:)'`" ]; then
			continue
		elif [ -z "${LINE}" ]; then
			continue
		fi

		PORT=`echo "${LINE}" | cut -d: -f1`
		DESCRIPTION=`echo "${LINE}" | cut -d: -f2`
		PROTO=`echo "${LINE}" | cut -d: -f3 | tr '[:lower:]' '[:upper:]'`

		if [ -z "`echo \"${PORT}\" | grep '^[1-9][0-9]*$'`" ]; then
			echo "Error: Invalid port in backdoorports.dat file: $LINE"
			continue
		elif [ "${PROTO}" != "UDP" -a "${PROTO}" != "TCP" ]; then
			echo "Error: Invalid protocol in backdoorports.dat file: $LINE"
			continue
		fi

		FNAME=""
		FOUND=""

		if [ -n "${LSOF_CMD}" ]; then
			PID_SEEN=0

			for LSOFLINE in `${LSOF_CMD} -wnlP -i ${PROTO}:${PORT}`; do
				#
				# We must only look at connections using the port on the local host.
				#

				if [ -n "`echo \"${LSOFLINE}\" | grep \" ${PROTO} \*:${PORT} \"`" ]; then
					# Process listening for connections from anywhere.
					PID=`echo "${LSOFLINE}" | awk '{ print $2 }'`
				elif [ -n "`echo \"${LSOFLINE}\" | egrep \" ${PROTO} [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:${PORT}[ -]\"`" ]; then
					# Established or listening process using IPv4 address.
					PID=`echo "${LSOFLINE}" | awk '{ print $2 }'`
				elif [ -n "`echo \"${LSOFLINE}\" | egrep \" ${PROTO} \[[:0-9a-fA-F]+\]:${PORT}[ -]\"`" ]; then
					# Established or listening process using IPv6 address.
					PID=`echo "${LSOFLINE}" | awk '{ print $2 }'`
				else
					# Ignore anything else.
					continue
				fi

				FNAME=""
				PID_SEEN=1

				#
				# Try and get the running process name.
				#

				if [ $HAVE_READLINK -eq 1 ]; then
					RKHTMPVAR=""

					if [ $SOL_PROC -eq 1 ]; then
						test -h "/proc/${PID}/path/a.out" && RKHTMPVAR=`${READLINK_CMD} -f /proc/${PID}/path/a.out`
					elif [ $SUNOS -eq 0 -o -h "/proc/${PID}/exe" ]; then
						test -h "/proc/${PID}/exe" && RKHTMPVAR=`${READLINK_CMD} -f /proc/${PID}/exe`
					fi

					test -n "${RKHTMPVAR}" && FNAME=`echo "${RKHTMPVAR}" | cut -d' ' -f1`
				fi

				if [ -z "${FNAME}" ]; then
					if [ $SUNOS -eq 1 ]; then
						FNAME=`${LSOF_CMD} -wnlP -p $PID | grep '[ 	]txt[ 	][ 	]*VREG[ 	]' | head -n 1 | awk '{ print $NF }'`
					else
						FNAME=`${LSOF_CMD} -wnlP -p $PID | grep '[ 	]txt[ 	][ 	]*REG[ 	]' | awk '{ print $NF }'`
					fi
				fi

				if [ -n "`echo \"${FNAME}\" | grep '^/'`" ]; then
					FOUND="${FNAME}"
					break
				fi
			done

			if [ -z "${FOUND}" -a $PID_SEEN -eq 1 ]; then
				FNAME=""
				FOUND="${PROTO}:${PORT}"
			fi
		else
			case "${OPERATING_SYSTEM}" in
			Linux)
				FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*:${PORT} " | awk '{ print $4 }' | grep ":${PORT}\$"`
				;;
			*BSD|Darwin|IRIX*)
				FOUND=`${NETSTAT_CMD} -an | grep -i "^${PROTO}.*\.${PORT} " | awk '{ print $4 }' | grep "\.${PORT}\$"`
				;;
			AIX)
				if [ "${PROTO}" = "UDP" ]; then
					FOUND=`${NETSTAT_CMD} -an | grep -i "^udp.*\.${PORT} " | awk '{ print $4 }' | grep "\.${PORT}\$"`
				elif [ "${PROTO}" = "TCP" ]; then
					FOUND=`${NETSTAT_CMD} -an | egrep -i "^tcp.*\.${PORT} .*(BOUND|ESTABLISH|LISTEN)" | awk '{ print $4 }' | grep "\.${PORT}\$"`
				fi
				;;
			SunOS)
				if [ "${PROTO}" = "UDP" ]; then
					FOUND=`${NETSTAT_CMD} -an | awk '/^UDP: IPv4/, /^$/ { print $1 }' | grep "\.${PORT}\$"`

					if [ -z "${FOUND}" ]; then
						FOUND=`${NETSTAT_CMD} -an | awk '/^UDP: IPv6/, /^$/ { print $1 }' | grep "\.${PORT}\$"`
					fi
				elif [ "${PROTO}" = "TCP" ]; then
					FOUND=`${NETSTAT_CMD} -an | awk '/^TCP: IPv4/, /^$/ { print $0 }' | egrep 'BOUND|ESTABLISH|LISTEN' | awk '{ print $1 }' | grep "\.${PORT}\$"`

					if [ -z "${FOUND}" ]; then
						FOUND=`${NETSTAT_CMD} -an | awk '/^TCP: IPv6/, /^$/ { print $0 }' | egrep 'BOUND|ESTABLISH|LISTEN' | awk '{ print $1 }' | grep "\.${PORT}\$"`
					fi
				fi
				;;
			esac
		fi


		#
		# If we have found something, then see if it is whitelisted.
		#

		if [ -n "${FOUND}" ]; then
			RKHTMPVAR2=0

			if [ -n "${LSOF_CMD}" ]; then
				if [ -n "${FNAME}" ]; then
					if [ -n "`echo \"${PORT_WHITELIST_PATH}\" | grep \" ${FNAME} \"`" ]; then
						RKHTMPVAR2=1
						FOUND="path_whitelisted"
					elif [ $PORT_WHITELIST_ALL_TRUSTED -eq 1 ]; then
						test -n "${BASENAME_CMD}" && RKHTMPVAR=`${BASENAME_CMD} ${FNAME}` || RKHTMPVAR=`echo "${FNAME}" | sed -e 's:^.*/::'`

						RKHTMPVAR=`IFS=$RKHIFS find_cmd ${RKHTMPVAR}`

						if [ "${RKHTMPVAR}" = "${FNAME}" ]; then
							RKHTMPVAR2=1
							FOUND="trusted_whitelisted"
						fi
					fi
				fi
			fi

			if [ $RKHTMPVAR2 -eq 0 -a -n "`echo \"${PORT_WHITELIST}\" | grep \" ${PROTO}:${PORT} \"`" ]; then
				FOUND="port_whitelisted"
			fi
		fi


		#
		# Now display the result.
		#

		case "${FOUND}" in
		path_whitelisted)
			display --to LOG --type INFO NETWORK_PORTS_PATH_WHITELIST "${PROTO}" "${PORT}" "${FNAME}"
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result WHITELISTED --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
			;;
		trusted_whitelisted)
			display --to LOG --type INFO NETWORK_PORTS_TRUSTED_WHITELIST "${PROTO}" "${PORT}" "${FNAME}"
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result WHITELISTED --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
			;;
		port_whitelisted)
			display --to LOG --type INFO NETWORK_PORTS_PORT_WHITELIST "${PROTO}" "${PORT}"
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result WHITELISTED --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
			;;
		"")
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result NOT_FOUND --color GREEN NETWORK_PORTS "${PROTO}" "${PORT}"
			;;
		*)
			display --to SCREEN+LOG --type PLAIN --log-indent 2 --screen-indent 4 --result WARNING --color RED NETWORK_PORTS "${PROTO}" "${PORT}"

			if [ -n "${FNAME}" ]; then
				display --to LOG --type WARNING NETWORK_PORTS_FOUND "${PROTO}" "${PORT}" " by ${FNAME}" "${DESCRIPTION}"
			else
				display --to LOG --type WARNING NETWORK_PORTS_FOUND "${PROTO}" "${PORT}" "" "${DESCRIPTION}"
			fi
			;;
		esac
	done

	IFS=$RKHIFS

	return
}


do_network_interface_checks() {

	#
	# This function will check the network interfaces to see
	# if any are in promiscuous mode. It will also check to see
	# if there are any applications running which are capturing
	# network interface packets.
	#

	if `check_test promisc`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 NETWORK_INTERFACE_START
		display --to LOG --type INFO STARTING_TEST promisc


		if [ -n "${IFCONFIG_CMD}" ]; then
			PROMISCSCAN1=""; PROMISCSCAN2=""

			IFWLIST=`get_option 2 single ALLOWPROMISCIF` || exit 1

			if [ -n "${IFWLIST}" ]; then
				display --to LOG --type INFO NETWORK_PROMISC_WLIST "${IFWLIST}"

				IFWLIST=`echo "${IFWLIST}" | tr ' ' '|'`
			else
				IFWLIST=" "
			fi

			case "${OPERATING_SYSTEM}" in
			*BSD|AIX)
				PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>&1 | awk 'BEGIN { RS="" }; $1 !~ /pflog/ && $1 !~ /^'"${IFWLIST}"'/ && /PROMISC/ { print }'`
				;;
			SunOS)
				PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>&1 | awk '$1 !~ /^'"${IFWLIST}"'/ && /PROMISC/ { print }'`
				;;
			IRIX*)
				PROMISCSCAN1=`${IFCONFIG_CMD} -a 2>&1 | awk 'BEGIN { RS="" }; $1 !~ /^'"${IFWLIST}"'/ && /PROMISC/ { print }'`
				;;
			*)
				PROMISCSCAN1=`${IFCONFIG_CMD} 2>&1 | awk 'BEGIN { RS="" }; $1 !~ /^'"${IFWLIST}"'/ && /PROMISC/ { print }'`
				;;
			esac

			if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
				if [ -n "${IP_CMD}" ]; then
					PROMISCSCAN2=`${IP_CMD} -s link | grep 'PROMISC'`
				else
					display --to LOG --type INFO NETWORK_PROMISC_NO_IP
				fi
			fi


			#
			# Now show the results of the interface check.
			#

			if [ -z "${PROMISCSCAN1}" -a -z "${PROMISCSCAN2}" ]; then
				display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 NETWORK_PROMISC_CHECK
			else
				display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PROMISC_CHECK

				display --to LOG --type WARNING NETWORK_PROMISC_IF

				display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_1 "${PROMISCSCAN1}"

				if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "${PROMISCSCAN2}" ]; then
					PROMISCSCAN2=`echo "${PROMISCSCAN2}" | cut -d: -f2`

					for IFACE in ${PROMISCSCAN2}; do
						display --to LOG --type PLAIN --log-indent 9 NETWORK_PROMISC_IF_2 "${IFACE}"
					done
				fi
			fi
		else
			display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --screen-indent 4 NETWORK_PROMISC_CHECK
			display --to LOG --type WARNING NETWORK_PROMISC_NO_IFCONFIG
		fi
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST promisc
	fi


	#
	# For the packet capturing check, we must first see if we
	# are able to run the test. We let the user know if the test
	# was disabled, or if the lsof command is not present.
	#

	if [ "${OPERATING_SYSTEM}" != "Linux" ]; then
		display --to LOG --type INFO TEST_SKIPPED_OS 'packet_cap_apps' '/proc/net/packet required'
		return
	fi

	if `check_test packet_cap_apps`; then
		display --to LOG --type INFO STARTING_TEST packet_cap_apps
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST packet_cap_apps
		return
	fi

	if [ ! -f "/proc/net/packet" ]; then
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
		display --to LOG --type WARNING NETWORK_PACKET_CAP_CHECK_NO_FILE "/proc/net/packet"
		return
	elif [ -z "${LSOF_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --result SKIPPED --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "lsof"
		return
	fi


	#
	# Now run the test.
	#

	FOUND=0
	WHITEPROC=""; BLACKPROC=""

	LIBPCAPRES=`egrep -v '^sk|888e' /proc/net/packet | head -n 1`

	if [ -n "${LIBPCAPRES}" ]; then
		#
		# We only need to get the whitelisted processes once.
		#

		ALLOWPROCLISTENERS=`get_option 1 multi ALLOWPROCLISTEN` || exit 1


		INODE_LIST=""

		for INODE in `egrep -v '^sk|888e' /proc/net/packet | awk '{ print $9 }'`; do
			INODE_LIST="${INODE_LIST}|$INODE"
		done

		INODE_LIST=`echo "${INODE_LIST}" | sed -e 's/^|//'`
		test -z "${INODE_LIST}" && INODE_LIST="RKHunterPktCapture"


		for PID in `${LSOF_CMD} -lMnPw -d 1-20 | egrep "[ 	](${INODE_LIST})[ 	]" | awk '{ print $2 }'`; do
			NAME=""

			if [ -h "/proc/$PID/exe" -a $HAVE_READLINK -eq 1 ]; then
				NAME=`${READLINK_CMD} -f /proc/$PID/exe | cut -d' ' -f1`
			elif [ -f "/proc/$PID/status" ]; then
				NAME=`grep '^Name:.' /proc/$PID/status | sed -e 's/^Name:.//'`
			fi


			test -z "${NAME}" && continue

			AMATCH=1

			for RKHTMPVAR in ${ALLOWPROCLISTENERS}; do
				if [ "${NAME}" = "${RKHTMPVAR}" ]; then
					AMATCH=0; break
				fi
			done

			if [ $AMATCH -eq 0 ]; then
				FNAME=`echo "${NAME}" | sed -e 's/\./\\\./g'`

				if [ -z "`echo \"${WHITEPROC} \" | grep \"${FNAME} \"`" ]; then
					WHITEPROC="${WHITEPROC} ${NAME}"
				fi
			else
				FOUND=1
				BLACKPROC="${BLACKPROC}
${NAME} ${PID}"
			fi
		done
	fi


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 NETWORK_PACKET_CAP_CHECK


		IFS=$IFSNL

		for RKHTMPVAR in ${BLACKPROC}; do
			test -z "${RKHTMPVAR}" && continue

			NAME=`echo "${RKHTMPVAR}" | cut -d' ' -f1`
			PID=`echo "${RKHTMPVAR}" | cut -d' ' -f2`

			display --to LOG --type WARNING NETWORK_PACKET_CAP_FOUND "${NAME}" "${PID}"
		done

		IFS=$RKHIFS
	fi

	for NAME in $WHITEPROC; do
		display --to LOG --type INFO NETWORK_PACKET_CAP_WL "${NAME}"
	done

	return
}


do_network_checks() {

	#
	# This function carries out some network checks. This consists
	# of port checks, and some interface checks.
	#

	if `check_test network`; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_NETWORK
		display --to LOG --type INFO STARTING_TEST network
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST network
		return
	fi


	do_network_port_checks

	do_network_interface_checks

	keypresspause

	return
}


do_system_startup_file_checks() {

	#
	# This function carries out checks on the system startup files.
	#

	if `check_test startup_files`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 STARTUP_FILES_START
		display --to LOG --type INFO STARTING_TEST startup_files
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST startup_files
		return
	fi

	#
	# First we check that the local host name has been set.
	#

	if [ -n "${HOST_NAME}" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result FOUND --log-indent 2 --screen-indent 4 STARTUP_HOSTNAME
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 STARTUP_HOSTNAME
		display --to LOG --type WARNING STARTUP_NO_HOSTNAME
	fi


	#
	# Check that the startup file malware checks are to be done.
	#

	if `check_test startup_malware`; then
		display --to LOG --type INFO STARTING_TEST startup_malware
	else
		display --to LOG --type INFO USER_DISABLED_TEST startup_malware
		return
	fi

	#
	# First check to see that we can run the test.
	#

	if [ "${STARTUP_PATHS}" = "NONE" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result SKIPPED --log-indent 2 --screen-indent 4 STARTUP_CHECK_FILES_EXIST
		display --to LOG --type INFO STARTUP_NONE_GIVEN
		return
	fi


	#
	# Now get and check that the system startup files are okay.
	#

	get_rc_paths

	if [ -n "${RC_PATHS}" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result FOUND --log-indent 2 --screen-indent 4 STARTUP_CHECK_FILES_EXIST
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 STARTUP_CHECK_FILES_EXIST
		display --to LOG --type WARNING STARTUP_CHECK_NO_RC_FILES
		return
	fi


	#
	# Next we check all the startup files for any suspicious
	# strings in them.
	#

	FOUND=0
	FOUNDSTRINGS=""

	#
	# Since we are going to be checking a lot of files
	# for strings that are static, we may as well do
	# some pre-processing of the string, and then we
	# only need to spend time if a string is found.
	#

	RCSTRINGS=""

	IFS=$IFSNL

	for RKHTMPVAR in ${RCLOCAL_STRINGS}; do
		RKHTMPVAR=`echo ${RKHTMPVAR} | sed -e 's/^[ 	]*//'`

		STR=`echo ${RKHTMPVAR} | cut -d: -f1`
		STRING=`echo ${STR} | sed -e 's/\./\\\./g'`
		RCSTRINGS="${RCSTRINGS} ${STRING}"
		INFO=`echo ${RKHTMPVAR} | cut -d: -f2`

		ROOTKIT_COUNT=`expr ${ROOTKIT_COUNT} + 1`
	done

	IFS=$RKHIFS

	RCSTRINGS=`echo ${RCSTRINGS}`


	for FNAME in ${RC_PATHS}; do
		for STRING in ${RCSTRINGS}; do
			if [ -n "`grep "${STRING}" ${FNAME} | egrep -v '^[ 	]*#'`" ]; then
				RKHTMPVAR=`echo "${FNAME}" | sed -e 's/\./\\\./g'`

				if [ -n "`echo \"${RTKT_FILE_WHITELIST}\" | grep \" ${RKHTMPVAR} \"`" ]; then
					display --to LOG --type INFO FILE_PROP_WL "${FNAME}" startup_malware
				else
					FOUND=1
					FOUNDSTRINGS="${FOUNDSTRINGS}%${FNAME}:${STR}:${INFO}"
				fi
			fi
		done
	done


	#
	# Now display the results.
	#

	if [ $FOUND -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 STARTUP_CHECK_FILES_MALWARE
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 STARTUP_CHECK_FILES_MALWARE

		IFS="%"

		for RKHTMPVAR in ${FOUNDSTRINGS}; do
			STRING=`echo "${RKHTMPVAR}" | cut -d: -f2`

			test -z "${STRING}" && continue

			FNAME=`echo "${RKHTMPVAR}" | cut -d: -f1`
			INFO=`echo "${RKHTMPVAR}" | cut -d: -f3`

			ROOTKIT_FAILED_COUNT=`expr ${ROOTKIT_FAILED_COUNT} + 1`
			ROOTKIT_FAILED_NAMES="${ROOTKIT_FAILED_NAMES}${INFO}, "

			display --to LOG --type WARNING ROOTKIT_POSS_STRINGS_FOUND "${STRING}" "${FNAME}" "${INFO}"
		done

		IFS=$RKHIFS
	fi

	return
}


pwdgrp_changes() {

	#
	# This function checks the changes made to the passwd and group files.
	#

	FNAME=$1
	LINES=$2

	SEEN_IDS=""

	IFS=$IFSNL

	for LINE in ${LINES}; do
		#
		# First we need to check if we have already dealt with
		# this id. If we have, then just get the next line.
		#

		PWDGRPID=`echo "${LINE}" | cut -d: -f1 | cut -c3-`
		IDGREP=`echo "${PWDGRPID}" | sed -e 's/\./\\\./g'`

		RKHTMPVAR=`echo "${SEEN_IDS}" | grep " ${IDGREP} "`

		test -n "${RKHTMPVAR}" && continue


		#
		# This id hasn't been seen before, so we record it.
		#

		SEEN_IDS="${SEEN_IDS} ${PWDGRPID} "

		#
		# Next we see if the id has just been added or removed.
		# To do this we simply see if it appears more than once.
		#

		RKHTMPVAR=`echo "${LINES}" | grep "^> ${IDGREP}:"`
		RKHTMPVAR2=`echo "${LINES}" | grep "^< ${IDGREP}:"`

		if [ \( -n "${RKHTMPVAR}" -a -z "${RKHTMPVAR2}" \) -o \( -z "${RKHTMPVAR}" -a -n "${RKHTMPVAR2}" \) ]; then
			if [ -n "${RKHTMPVAR}" ]; then
				if [ "${FNAME}" = "passwd" ]; then
					display --to LOG --type WARNING --log-indent 4 PWD_CHANGES_IDREM "${PWDGRPID}"
				else
					display --to LOG --type WARNING --log-indent 4 GROUP_CHANGES_IDREM "${PWDGRPID}"
				fi
			else
				if [ "${FNAME}" = "passwd" ]; then
					display --to LOG --type WARNING --log-indent 4 PWD_CHANGES_IDADD "${PWDGRPID}"
				else
					display --to LOG --type WARNING --log-indent 4 GROUP_CHANGES_IDADD "${PWDGRPID}"
				fi
			fi

			continue
		fi


		#
		# The id has changed in some way. We now need to
		# go through the fields and see what has changed.
		#

		FIELD_IDX=1

		OLD_LINE=`echo "${RKHTMPVAR}" | cut -d: -f2-`
		NEW_LINE=`echo "${RKHTMPVAR2}" | cut -d: -f2-`

		STR=${OLD_LINE}

		if [ "${FNAME}" = "passwd" ]; then
			display --to LOG --type WARNING PWD_CHANGES_FOUND "${PWDGRPID}"
		else
			display --to LOG --type WARNING GROUP_CHANGES_FOUND "${PWDGRPID}"
		fi

		while test -n "${STR}"; do
			OLD_FIELD=`echo "${OLD_LINE}" | cut -d: -f$FIELD_IDX`
			NEW_FIELD=`echo "${NEW_LINE}" | cut -d: -f$FIELD_IDX`

			if [ "${OLD_FIELD}" != "${NEW_FIELD}" ]; then
				if [ "${FNAME}" = "passwd" ]; then
					case $FIELD_IDX in
					1)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_PWD "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					2)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_UID "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					3)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_GID "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					4)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_COMM "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					5)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_HOME "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					6)
						display --to LOG --type PLAIN --log-indent 9 PWD_CHANGES_SHL "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					*)
						display --to LOG --type PLAIN --log-indent 9 PWDGRP_CHANGES_UNK "${FNAME}" "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					esac
				else
					case $FIELD_IDX in
					1)
						display --to LOG --type PLAIN --log-indent 9 GROUP_CHANGES_PWD "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					2)
						display --to LOG --type PLAIN --log-indent 9 GROUP_CHANGES_GID "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					3)
						OLD_GRPUSRS=" `echo ${OLD_FIELD} | tr ',' ' '` "
						NEW_GRPUSRS=" `echo ${NEW_FIELD} | tr ',' ' '` "

						IFS=$RKHIFS

						for GRPUSR in ${OLD_GRPUSRS} ${NEW_GRPUSRS}; do
							RKHTMPVAR=`echo ${GRPUSR} | sed -e 's/\./\\\./g'`
							RKHTMPVAR2=`echo "${OLD_GRPUSRS}" | grep " ${RKHTMPVAR} "`
							RKHTMPVAR3=`echo "${NEW_GRPUSRS}" | grep " ${RKHTMPVAR} "`

							if [ -n "${RKHTMPVAR2}" -a -z "${RKHTMPVAR3}" ]; then
								display --to LOG --type PLAIN --log-indent 9 GROUP_CHANGES_GRPREM "${GRPUSR}"
							elif [ -z "${RKHTMPVAR2}" -a -n "${RKHTMPVAR3}" ]; then
								display --to LOG --type PLAIN --log-indent 9 GROUP_CHANGES_GRPADD "${GRPUSR}"
							fi
						done

						IFS=$IFSNL
						;;
					*)
						display --to LOG --type PLAIN --log-indent 9 PWDGRP_CHANGES_UNK "${FNAME}" "${OLD_FIELD}" "${NEW_FIELD}"
						;;
					esac
				fi
			fi

			FIELD_IDX=`expr $FIELD_IDX + 1`

			RKHTMPVAR=`echo "${STR}" | cut -d: -f2-`

			#
			# For the group file the last field may be
			# empty, so we need to cater for this.
			#

			if [ -z "${RKHTMPVAR}" ]; then
				if [ \( "${FNAME}" = "passwd" -a $FIELD_IDX -eq 6 \) -o \( "${FNAME}" = "group" -a $FIELD_IDX -eq 3 \) ]; then
						STR=""
						RKHTMPVAR="x"
				fi
			fi

			test "${RKHTMPVAR}" = "${STR}" && STR="" || STR=${RKHTMPVAR}
		done
	done

	IFS=$RKHIFS

	return
}


do_group_accounts_check() {

	#
	# This function carries out checks on the /etc/passwd and
	# /etc/group files.
	#

	if `check_test group_accounts`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 ACCOUNTS_START
		display --to LOG --type INFO STARTING_TEST group_accounts
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST group_accounts
		return
	fi

	#
	# First check that /etc/passwd exists.
	#

	if [ -s "${RKHROOTDIR}/etc/passwd" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result FOUND --log-indent 2 --screen-indent 4 ACCOUNTS_PWD_FILE_CHECK
		display --to LOG --type INFO ACCOUNTS_FOUND_PWD_FILE "${RKHROOTDIR}/etc/passwd"
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 ACCOUNTS_PWD_FILE_CHECK
		display --to LOG --type WARNING ACCOUNTS_NO_PWD_FILE "${RKHROOTDIR}/etc/passwd"
	fi


	#
	# Next, check for root equivalent accounts. These will have
	# a UID of zero.
	#

	if [ -s "${RKHROOTDIR}/etc/passwd" ]; then
		#
		# We need to ignore any whitelisted UID 0 accounts.
		#

		UID0_WHITELIST=`get_option 2 single UID0_ACCOUNTS` || exit 1
		UID0_WHITELIST=" root ${UID0_WHITELIST} "

		UID_LIST=""

		IFS=$IFSNL

		for RKHTMPVAR in `grep '^[^:]*:[^:]*:0:' ${RKHROOTDIR}/etc/passwd | cut -d: -f1`; do
			RKHUSERID=`echo "${RKHTMPVAR}" | sed -e 's/\./\\\./g'`

			if [ -z "`echo \"${UID0_WHITELIST}\" | grep \" ${RKHUSERID} \"`" ]; then
				UID_LIST="${UID_LIST}
${RKHTMPVAR}"
			elif [ "${RKHTMPVAR}" != "root" ]; then
				display --to LOG --type INFO ACCOUNTS_UID0_WL "${RKHTMPVAR}"
			fi
		done

		IFS=$RKHIFS


		#
		# Now display the results.
		#

		if [ -z "${UID_LIST}" ]; then
			display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 ACCOUNTS_UID0
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 ACCOUNTS_UID0

			IFS=$IFSNL

			for RKHTMPVAR in ${UID_LIST}; do
				test -z "${RKHTMPVAR}" && continue
				display --to LOG --type WARNING ACCOUNTS_UID0_FOUND "${RKHTMPVAR}"
			done

			IFS=$RKHIFS
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 ACCOUNTS_UID0
		display --to LOG --type INFO ACCOUNTS_NO_PWD_FILE "${RKHROOTDIR}/etc/passwd"
	fi


	#
	# Now check for any passwordless accounts. We do this in two steps.
	# The first is to check the shadow file, and for TCB shadow files we
	# have to loop through all the shadow files in the /etc/tcb directory.
	# Then we check the /etc/passwd file for any passwordless accounts.
	# Finally we display the overall result.
	#

	#
	# We need to ignore any whitelisted passwordless accounts.
	#

	WL_SEEN=""

	PWD_WHITELIST=`get_option 2 single PWDLESS_ACCOUNTS` || exit 1
	PWD_WHITELIST=" ${PWD_WHITELIST} "

	PWD_PWDLESS_LIST=""
	SHAD_PWDLESS_LIST=""


	#
	# Check for passwordless accounts in the shadow file(s).
	#

	if [ -n "${SHADOW_FILE}" -o $HAVE_TCB_SHADOW -eq 1 ]; then
		if [ -n "${SHADOW_FILE}" ]; then
			display --to LOG --type INFO ACCOUNTS_SHADOW_FILE "${SHADOW_FILE}"
		else
			display --to LOG --type INFO ACCOUNTS_SHADOW_TCB "${RKHROOTDIR}/etc/tcb"
		fi

		#
		# We have do a bit of a kludge here. We need a loop in order to
		# cater for TCB shadow files in /etc/tcb. But at the same time
		# we only want to execute the loop once for non-TCB systems. To
		# do this we loop through either /etc or /etc/tcb. However, for
		# /etc we only execute the loop once because the grep statement
		# will have the exact shadow filename in SHADOW_FILE. For TCB
		# systems, SHADOW_FILE is set for each individual shadow file as
		# it pass round the loop.
		#

		if [ $HAVE_TCB_SHADOW -eq 1 ]; then
			RKHTMPVAR2="${RKHROOTDIR}/etc/tcb"
		else
			RKHTMPVAR2="${RKHROOTDIR}/etc"
		fi

		IFS=$IFSNL

		for DIR in ${RKHTMPVAR2}/*; do
			if [ $HAVE_TCB_SHADOW -eq 1 ]; then
				if [ -f "${DIR}/shadow" ]; then
					SHADOW_FILE="${DIR}/shadow"
				else
					continue
				fi
			fi

			for RKHTMPVAR in `grep '^[^:]*::' ${SHADOW_FILE} | cut -d: -f1`; do
				# Ignore any NIS/YP entries
				test "${RKHTMPVAR}" = "+" && continue

				RKHUSERID=`echo "${RKHTMPVAR}" | sed -e 's/\./\\\./g'`

				if [ -z "`echo \"${PWD_WHITELIST}\" | grep \" ${RKHUSERID} \"`" ]; then
					SHAD_PWDLESS_LIST="${SHAD_PWDLESS_LIST}
${RKHTMPVAR}"
					test $HAVE_TCB_SHADOW -eq 1 && SHAD_PWDLESS_LIST="${SHAD_PWDLESS_LIST} (${SHADOW_FILE})"
				else
					WL_SEEN="${WL_SEEN} ${RKHTMPVAR} "

					display --to LOG --type INFO ACCOUNTS_PWDLESS_WL "${RKHTMPVAR}"
				fi
			done

			test $HAVE_TCB_SHADOW -eq 0 && break
		done

		IFS=$RKHIFS
	else
		#
		# No shadow file found.
		#

		SHAD_PWDLESS_LIST="RKH:No shadow file"
	fi


	#
	# Check for passwordless accounts in /etc/passwd.
	#

	if [ -s "${RKHROOTDIR}/etc/passwd" ]; then
		IFS=$IFSNL

		for RKHTMPVAR in `grep '^[^:]*::' ${RKHROOTDIR}/etc/passwd | cut -d: -f1`; do
			RKHUSERID=`echo "${RKHTMPVAR}" | sed -e 's/\./\\\./g'`

			if [ -z "`echo \"${PWD_WHITELIST}\" | grep \" ${RKHUSERID} \"`" ]; then
				PWD_PWDLESS_LIST="${PWD_PWDLESS_LIST}
${RKHTMPVAR}"
			elif [ -z "`echo \"${WL_SEEN}\" | grep \" ${RKHUSERID} \"`" ]; then
				display --to LOG --type INFO ACCOUNTS_PWDLESS_WL "${RKHTMPVAR}"
			fi
		done

		IFS=$RKHIFS
	fi


	#
	# Now display the results.
	#

	if [ -z "${SHAD_PWDLESS_LIST}" -a -z "${PWD_PWDLESS_LIST}" ]; then
		display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 ACCOUNTS_PWDLESS
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 ACCOUNTS_PWDLESS

		#
		# Log the shadow file results.
		#

		if [ "${SHAD_PWDLESS_LIST}" = "RKH:No shadow file" ]; then
			display --to LOG --type WARNING ACCOUNTS_NO_SHADOW_FILE
		else
			IFS=$IFSNL

			for RKHTMPVAR in ${SHAD_PWDLESS_LIST}; do
				test -z "${RKHTMPVAR}" && continue
				display --to LOG --type WARNING ACCOUNTS_PWDLESS_FOUND "shadow" "${RKHTMPVAR}"
			done
		fi

		#
		# Log the passwd file results.
		#

		IFS=$IFSNL

		for RKHTMPVAR in ${PWD_PWDLESS_LIST}; do
			test -z "${RKHTMPVAR}" && continue
			display --to LOG --type WARNING ACCOUNTS_PWDLESS_FOUND "passwd" "${RKHTMPVAR}"
		done

		IFS=$RKHIFS
	fi


	#
	# Now we check for any changes that have occurred to the passwd
	# file since rkhunter was last run.
	#

	DIFF_CMD=`find_cmd diff`

	if `check_test passwd_changes`; then
		RKHTMPVAR=0
		display --to LOG --type INFO STARTING_TEST passwd_changes
	else
		RKHTMPVAR=1
		display --to LOG --type INFO USER_DISABLED_TEST passwd_changes
	fi

	if [ $RKHTMPVAR -eq 1 ]; then
		:
	elif [ ! -f "${RKHROOTDIR}/etc/passwd" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 PASSWD_CHANGES
		display --to LOG --type INFO ACCOUNTS_NO_PWD_FILE "${RKHROOTDIR}/etc/passwd"
	elif [ -z "${DIFF_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 PASSWD_CHANGES
		display --to LOG --type INFO NOT_FOUND_CMD "diff"

		cp -f -p ${RKHROOTDIR}/etc/passwd ${RKHTMPDIR}/passwd
	elif [ ! -f "${RKHTMPDIR}/passwd" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 PASSWD_CHANGES
		display --to LOG --type WARNING PASSWD_CHANGES_NO_TMP

		cp -f -p ${RKHROOTDIR}/etc/passwd ${RKHTMPDIR}/passwd
	else
		DIFFS=`${DIFF_CMD} ${RKHROOTDIR}/etc/passwd ${RKHTMPDIR}/passwd 2>/dev/null | grep '^[<>]'`

		if [ -z "${DIFFS}" ]; then
			display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 PASSWD_CHANGES
		else
			display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 PASSWD_CHANGES

			pwdgrp_changes "passwd" "${DIFFS}"

			#
			# Finally, move the current copy of the passwd file out
			# of the way, and take a new copy of the passwd file.
			# This allows the user to look back to see what the
			# last changes were, even if RKH is run again.
			#

			mv -f ${RKHTMPDIR}/passwd ${RKHTMPDIR}/passwd.old >/dev/null 2>&1
			cp -f -p ${RKHROOTDIR}/etc/passwd ${RKHTMPDIR}/passwd
		fi
	fi


	#
	# Next check for any changes that have occurred to the group
	# file since rkhunter was last run.
	#

	if `check_test group_changes`; then
		RKHTMPVAR=0
		display --to LOG --type INFO STARTING_TEST group_changes
	else
		RKHTMPVAR=1
		display --to LOG --type INFO USER_DISABLED_TEST group_changes
	fi

	if [ $RKHTMPVAR -eq 1 ]; then
		:
	elif [ ! -f "${RKHROOTDIR}/etc/group" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 GROUP_CHANGES
		display --to LOG --type WARNING GROUP_CHANGES_NO_FILE "${RKHROOTDIR}/etc/group"
	elif [ -z "${DIFF_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 GROUP_CHANGES
		display --to LOG --type INFO NOT_FOUND_CMD "diff"

		cp -f -p ${RKHROOTDIR}/etc/group ${RKHTMPDIR}/group
	elif [ ! -f "${RKHTMPDIR}/group" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 GROUP_CHANGES
		display --to LOG --type WARNING GROUP_CHANGES_NO_TMP

		cp -f -p ${RKHROOTDIR}/etc/group ${RKHTMPDIR}/group
	else
		DIFFS=`${DIFF_CMD} ${RKHROOTDIR}/etc/group ${RKHTMPDIR}/group 2>/dev/null | grep '^[<>]'`

		if [ -z "${DIFFS}" ]; then
			display --to SCREEN+LOG --type PLAIN --color GREEN --result NONE_FOUND --log-indent 2 --screen-indent 4 GROUP_CHANGES
		else
			display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 GROUP_CHANGES

			pwdgrp_changes "group" "${DIFFS}"

			#
			# Finally, move the current copy of the group file out
			# of the way, and take a new copy of the group file.
			# This allows the user to look back to see what the
			# last changes were, even if RKH is run again.
			#

			mv -f ${RKHTMPDIR}/group ${RKHTMPDIR}/group.old >/dev/null 2>&1
			cp -f -p ${RKHROOTDIR}/etc/group ${RKHTMPDIR}/group
		fi
	fi


	#
	# Finally we do a check on the root account shell history files.
	# We check for bash, Korn, C-shell and zsh history files.
	#

	FOUND=0
	FOUNDFILES=""

	if [ -f "${RKHROOTDIR}/root/.bash_history" ]; then
		FOUND=1

		if [ -h "${RKHROOTDIR}/root/.bash_history" ]; then
			FOUNDFILES="${FOUNDFILES} bash:${RKHROOTDIR}/root/.bash_history"
		fi
	fi

	if [ -f "${RKHROOTDIR}/root/.sh_history" ]; then
		FOUND=1

		if [ -h "${RKHROOTDIR}/root/.sh_history" ]; then
			FOUNDFILES="${FOUNDFILES} Korn:${RKHROOTDIR}/root/.sh_history"
		fi
	fi

	if [ -f "${RKHROOTDIR}/root/.history" ]; then
		FOUND=1

		if [ -h "${RKHROOTDIR}/root/.history" ]; then
			FOUNDFILES="${FOUNDFILES} C-shell:${RKHROOTDIR}/root/.history"
		fi
	fi

	if [ -f "${RKHROOTDIR}/root/.zhistory" ]; then
		FOUND=1

		if [ -h "${RKHROOTDIR}/root/.zhistory" ]; then
			FOUNDFILES="${FOUNDFILES} zsh:${RKHROOTDIR}/root/.zhistory"
		fi
	fi


	#
	# Now display the results.
	#

	if [ -z "${FOUNDFILES}" ]; then
		test $FOUND -eq 1 && RKHTMPVAR="OK" || RKHTMPVAR="NONE_FOUND"

		display --to SCREEN+LOG --type PLAIN --color GREEN --result ${RKHTMPVAR} --log-indent 2 --screen-indent 4 HISTORY_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --color RED --result WARNING --log-indent 2 --screen-indent 4 HISTORY_CHECK

		for RKHTMPVAR in ${FOUNDFILES}; do
			SHELLNAME=`echo "${RKHTMPVAR}" | cut -d: -f1`
			FILENAME=`echo "${RKHTMPVAR}" | cut -d: -f2`

			display --to LOG --type WARNING HISTORY_CHECK_FOUND "SHELLNAME" "FILENAME"
		done
	fi

	return
}


do_system_config_files_check() {

	#
	# This function carries out checks on some of the system
	# software configurations. At present this checks the SSH
	# and syslog configurations.
	#

	if `check_test system_configs`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 SYSTEM_CONFIGS_START
		display --to LOG --type INFO STARTING_TEST system_configs
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST system_configs
		return
	fi

	#
	# First find out where the SSH configuration file is located.
	#

	SSH_CONFIG_FILE=""

	if [ -n "${SSH_CONFIG_DIR}" ]; then
		RKHTMPVAR="${SSH_CONFIG_DIR}"
	else
		RKHTMPVAR="/etc /etc/ssh /usr/local/etc /usr/local/etc/ssh"
	fi

	for DIR in ${RKHTMPVAR}; do
		if [ -f "${RKHROOTDIR}${DIR}/sshd_config" ]; then
			SSH_CONFIG_FILE="${RKHROOTDIR}${DIR}/sshd_config"
			break
		fi
	done

	if [ -n "${SSH_CONFIG_FILE}" ]; then
		display --to SCREEN+LOG --type PLAIN --result FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "SSH"

		display --to LOG --type INFO SYSTEM_CONFIGS_FILE_FOUND "SSH" "${SSH_CONFIG_FILE}"

		display --to LOG --type INFO CONFIG_SSH_ROOT "${ALLOW_SSH_ROOT_USER}"
		display --to LOG --type INFO CONFIG_SSH_PROTV1 $ALLOW_SSH_PROT_V1


		#
		# Now we check some of the configuration options.
		#
		# First we check for allowed root access.
		#

		RKHTMPVAR=`grep -i '^[ 	]*PermitRootLogin[ 	=]' ${SSH_CONFIG_FILE} | tail -1`

		if [ -n "${RKHTMPVAR}" ]; then
			#
			# Get the value that has been set.
			#

			RKHTMPVAR2=`echo ${RKHTMPVAR} | sed -e 's/^[^ 	=]*[ 	]*=*[ 	]*\([^ 	#]*\).*$/\1/' | tr '[:upper:]' '[:lower:]'`

			if [ "${RKHTMPVAR2}" = "${ALLOW_SSH_ROOT_USER}" ]; then
				test "${RKHTMPVAR2}" = "no" && RKHTMPVAR="NOT_ALLOWED" || RKHTMPVAR="ALLOWED"
				display --to SCREEN+LOG --type PLAIN --result ${RKHTMPVAR} --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_ROOT
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_ROOT

				display --to LOG --type WARNING SYSTEM_CONFIGS_SSH_ROOT_FOUND
				display --to LOG --type PLAIN --log-indent 9 SYSTEM_CONFIGS_SSH_ROOT_FOUND1 "${RKHTMPVAR2}"
				display --to LOG --type PLAIN --log-indent 9 SYSTEM_CONFIGS_SSH_ROOT_FOUND2 "${ALLOW_SSH_ROOT_USER}"
			fi
		elif [ "${ALLOW_SSH_ROOT_USER}" = "yes" ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_ROOT
		elif [ "${ALLOW_SSH_ROOT_USER}" = "unset" ]; then
			display --to SCREEN+LOG --type PLAIN --result UNSET --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_ROOT
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_ROOT
			display --to LOG --type WARNING SYSTEM_CONFIGS_SSH_ROOT_NOTFOUND
		fi


		#
		# Next we check to see if protocol version 1 is allowed.
		#

		RKHTMPVAR=`grep -i '^[ 	]*Protocol[ 	=]' ${SSH_CONFIG_FILE} | tail -1`

		if [ -n "${RKHTMPVAR}" ]; then
			#
			# Get the value that has been set.
			#

			RKHTMPVAR2=`echo ${RKHTMPVAR} | sed -e 's/^[^ 	=]*[ 	]*=*[ 	]*\([^ 	#]*\).*$/\1/' | grep '1'`

			if [ -z "${RKHTMPVAR2}" ]; then
				display --to SCREEN+LOG --type PLAIN --result NOT_ALLOWED --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO
			elif [ $ALLOW_SSH_PROT_V1 -eq 1 ]; then
				display --to SCREEN+LOG --type PLAIN --result ALLOWED --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO
			else
				display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO

				display --to LOG --type WARNING SYSTEM_CONFIGS_SSH_PROTO_FOUND "${SSH_CONFIG_FILE}"
			fi
		elif [ $ALLOW_SSH_PROT_V1 -eq 1 ]; then
			display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO
		elif [ $ALLOW_SSH_PROT_V1 -eq 2 ]; then
			display --to SCREEN+LOG --type PLAIN --result UNSET --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SSH_PROTO
			display --to LOG --type WARNING SYSTEM_CONFIGS_SSH_PROTO_NOTFOUND
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "SSH"
	fi


	#
	# Next we find out if the syslog daemon is running.
	#

	SYSLOG_SEEN=0
	METALOG_SEEN=0; SOCKLOG_SEEN=0

	if [ -n "${PS_CMD}" ]; then
		PS_ARGS="ax"

		test $SUNOS -eq 1 -o $IRIXOS -eq 1 && PS_ARGS="-ef"

		RKHTMPVAR=`${PS_CMD} ${PS_ARGS} | egrep '(syslogd|syslog-ng)( |$)' | grep -v 'egrep'`

		if [ -n "${RKHTMPVAR}" ]; then
			SYSLOG_SEEN=1

			display --to SCREEN+LOG --type PLAIN --result FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG
		else
			RKHTMPVAR=`${PS_CMD} ${PS_ARGS} | egrep 'metalog( |$)' | grep -v 'egrep'`

			if [ -n "${RKHTMPVAR}" ]; then
				METALOG_SEEN=1

				display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG
				display --to LOG --type INFO --log-indent 2 SYSTEM_CONFIGS_SYSLOG_METALOG_RUNNING
			else
				RKHTMPVAR=`${PS_CMD} ${PS_ARGS} | egrep 'socklog( |$)' | grep -v 'egrep'`

				if [ -n "${RKHTMPVAR}" ]; then
					SOCKLOG_SEEN=1

					display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG
					display --to LOG --type INFO --log-indent 2 SYSTEM_CONFIGS_SYSLOG_SOCKLOG_RUNNING
				else
					display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG
					display --to LOG --type WARNING SYSTEM_CONFIGS_SYSLOG_NOT_RUNNING
				fi
			fi
		fi
	else
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG
		display --to LOG --type INFO NOT_FOUND_CMD "ps"
	fi


	#
	# Now find out where the syslog configuration file is located.
	#

	if [ "${SYSLOG_CONFIG_FILE}" = "NONE" ]; then
		RKHTMPVAR=""
	else
		if [ -n "${SYSLOG_CONFIG_FILE}" ]; then
			RKHTMPVAR="${SYSLOG_CONFIG_FILE}"
			SYSLOG_CONFIG_FILE=""
		else
			RKHTMPVAR="/etc/syslog.conf /etc/rsyslog.conf /etc/syslog-ng/syslog-ng.conf"
		fi

		for FILE in ${RKHTMPVAR}; do
			if [ -f "${RKHROOTDIR}${FILE}" ]; then
				SYSLOG_CONFIG_FILE="${RKHROOTDIR}${FILE}"
				break
			fi
		done
	fi

	if [ "${SYSLOG_CONFIG_FILE}" = "NONE" ]; then
		SYSLOG_CONFIG_FILE=""
		display --to SCREEN+LOG --type PLAIN --result WHITELISTED --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "syslog"
	elif [ -n "${SYSLOG_CONFIG_FILE}" ]; then
		display --to SCREEN+LOG --type PLAIN --result FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "syslog"
		display --to LOG --type INFO SYSTEM_CONFIGS_FILE_FOUND "syslog" "${SYSLOG_CONFIG_FILE}"
	elif [ $METALOG_SEEN -eq 1 -o $SOCKLOG_SEEN -eq 1 ]; then
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "syslog"
	elif [ $SYSLOG_SEEN -eq 1 ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "syslog"
		display --to LOG --type WARNING SYSTEM_CONFIGS_SYSLOG_NO_FILE
	else
		display --to SCREEN+LOG --type PLAIN --result NOT_FOUND --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_FILE "syslog"
	fi


	#
	# Next we find out if syslog allows remote logging.
	#

	if [ -n "${SYSLOG_CONFIG_FILE}" ]; then
		test $ALLOW_SYSLOG_REMOTE_LOGGING -eq 1 && display --to LOG --type INFO SYSTEM_CONFIGS_SYSLOG_REMOTE_ALLOWED

		if [ -n "`echo \"${SYSLOG_CONFIG_FILE}\" | egrep '/r?syslog\.conf$'`" ]; then
			RKHTMPVAR=`egrep '^[^#].*[ 	](@|:omrelp:).' ${SYSLOG_CONFIG_FILE}`
		else
			#
			# For syslog-ng we must look for a destination
			# block which uses TCP or UDP.
			#

			RKHTMPVAR=`awk '/^[ 	]*destination( |	|$)/, /}/ { print $0 }' ${SYSLOG_CONFIG_FILE} | egrep -i '( |	|\{|^)(tcp|udp)6?( |	|\(|$)'`
		fi

		if [ -z "${RKHTMPVAR}" ]; then
			display --to SCREEN+LOG --type PLAIN --result NOT_ALLOWED --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG_REMOTE
		elif [ $ALLOW_SYSLOG_REMOTE_LOGGING -eq 1 ]; then
			display --to SCREEN+LOG --type PLAIN --result ALLOWED --color GREEN --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG_REMOTE
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 SYSTEM_CONFIGS_SYSLOG_REMOTE
			display --to LOG --type WARNING SYSTEM_CONFIGS_SYSLOG_REMOTE_FOUND "${RKHTMPVAR}"
		fi
	fi

	return
}


do_dev_whitelist_check() {

	#
	# The check of /dev files has two methods. One uses a simple
	# top-level file check, the other is more thorough and does a
	# complete 'find' on the /dev directory. However, the check on
	# whether the given file is whitelisted is the same for both
	# methods. As such, it makes sense to use a function rather than
	# repeating the code for each method.
	#


	FNAME=`${FILE_CMD} "${RKHTMPVAR}" 2>/dev/null | cat -v | tr '	' ' ' | egrep -v '( character special| block special| socket| fifo \(named pipe\)| symbolic link to| empty| directory|/MAKEDEV:)'`

	test -z "${FNAME}" && return

	FILE=`echo "${FNAME}" | cut -d: -f1 | sed -e "s:^${RKHROOTDIR}::"`

	if [ -n "`echo \"${ALLOWDEVFILES}\" | grep \" ${FILE} \"`" ]; then
		display --to LOG --type INFO FILESYSTEM_DEV_FILE_WL "${FILE}"
	else
		FOUNDFILES="${FOUNDFILES}
${FNAME}"
	fi

	return
}


do_filesystem_check() {

	#
	# This function carries out checks on the filesystem
	# for suspicious files.
	#

	if `check_test filesystem`; then
		display --to SCREEN+LOG --type PLAIN --nl --screen-indent 2 FILESYSTEM_START
		display --to LOG --type INFO STARTING_TEST filesystem
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST filesystem
		return
	fi


	if [ ! -d "${RKHROOTDIR}/dev" ]; then
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 FILESYSTEM_DEV_CHECK
		display --to LOG --type WARNING FILESYSTEM_DEV_CHECK_NO_DEV
	elif [ -z "${FILE_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 FILESYSTEM_DEV_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "file"
	elif [ "${SCAN_MODE_DEV}" = "THOROUGH" -a -z "${FIND_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 FILESYSTEM_DEV_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "find"
	else
		#
		# Now we can run the check on /dev.
		#

		display --to LOG --type INFO CONFIG_SCAN_MODE_DEV "${SCAN_MODE_DEV}"


		#
		# Note: We do not look for hidden files here - that is,
		# those beginning with a dot. Any hidden files will be
		# picked up in the next check.
		# Note2: Filenames can contain a colon (:), so we need to
		# be careful in separating the filename from the file type.
		# Note3: We have to cater for *BSD systems which may have
		# fdesc/fdescfs mounted. If it is, then we must skip over
		# any detected file descriptors.
		#

		FDESCFS=0
		FOUNDFILES=""
		ALLOWDEVFILES=" "

		if [ $BSDOS -eq 1 ]; then
			RKHTMPVAR=`find_cmd mount`

			if [ -n "${RKHTMPVAR}" ]; then
				test -n "`${RKHTMPVAR} 2>/dev/null | egrep '^fdesc(fs)? .*type fdesc'`" && FDESCFS=1
			else
				display --to LOG --type INFO NOT_FOUND_CMD "mount"
			fi
		fi

		RKHTMPVAR=`get_option 1 multi ALLOWDEVFILE` || exit 1

		for FNAME in ${RKHTMPVAR}; do
			ALLOWDEVFILES="${ALLOWDEVFILES} ${FNAME}"
		done

		ALLOWDEVFILES="${ALLOWDEVFILES} "


		if [ "${SCAN_MODE_DEV}" = "LAZY" ]; then
			for RKHTMPVAR in ${RKHROOTDIR}/dev/*; do
				test -s "${RKHTMPVAR}" -a ! -d "${RKHTMPVAR}" -a ! -h "${RKHTMPVAR}" || continue

				if [ $FDESCFS -eq 1 ]; then
					test -n "`echo \"${RKHTMPVAR}/\" | grep \"^${RKHROOTDIR}/dev/fd/[0-9][0-9]*/\"`" && continue
				fi

				do_dev_whitelist_check
			done
		else
			for RKHTMPVAR in `${FIND_CMD} ${RKHROOTDIR}/dev ! -type d -a ! -type l 2>/dev/null`; do
				test -s "${RKHTMPVAR}" || continue

				if [ $FDESCFS -eq 1 ]; then
					test -n "`echo \"${RKHTMPVAR}/\" | grep \"^${RKHROOTDIR}/dev/fd/[0-9][0-9]*/\"`" && continue
				fi

				test -z "`echo \"${RKHTMPVAR}\" | grep '/\.'`" && do_dev_whitelist_check
			done
		fi


		#
		# Now display the results.
		#

		if [ -z "${FOUNDFILES}" ]; then
			display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 FILESYSTEM_DEV_CHECK
		else
			display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 FILESYSTEM_DEV_CHECK

			display --to LOG --type WARNING FILESYSTEM_DEV_FILE_FOUND "${RKHROOTDIR}/dev"

			IFS=$IFSNL

			for RKHTMPVAR in ${FOUNDFILES}; do
				test -z "${RKHTMPVAR}" && continue
				display --to LOG --type PLAIN --log-indent 9 NAME "${RKHTMPVAR}"
			done

			IFS=$RKHIFS
		fi
	fi


	#
	# Now we check various directories for hidden files and
	# directories. We must have the 'file' command for this
	# test to run.
	#
	# First we look in two sets of directories. One set we search
	# recursively, using 'find', the other set we only search to
	# one-level. If we have no 'find' command, then all the
	# directories are only searched to one-level.
	#

	if [ -z "${FILE_CMD}" ]; then
		display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 FILESYSTEM_HIDDEN_CHECK
		display --to LOG --type INFO NOT_FOUND_CMD "file"
		return
	fi


	FOUNDDIRS=""
	FOUNDFILES=""
	LOOKINDIRS=""

	SHORTSEARCHDIRS="${RKHROOTDIR}/usr ${RKHROOTDIR}/etc"

	LONGSEARCHDIRS="${RKHROOTDIR}/dev ${RKHROOTDIR}/bin ${RKHROOTDIR}/usr/man ${RKHROOTDIR}/usr/share/man ${RKHROOTDIR}/usr/bin ${RKHROOTDIR}/usr/sbin ${RKHROOTDIR}/sbin"

	if [ -z "${FIND_CMD}" ]; then
		SHORTSEARCHDIRS="${SHORTSEARCHDIRS} ${LONGSEARCHDIRS}"
		LONGSEARCHDIRS=""
	fi

	for DIR in ${SHORTSEARCHDIRS}; do
		if [ -d ${DIR} ]; then
			RKHTMPVAR=`ls -1d ${DIR}/.* 2>/dev/null | egrep -v '/\.\.?$'`
			test -n "${RKHTMPVAR}" && LOOKINDIRS="${LOOKINDIRS} ${RKHTMPVAR}"
		fi
	done

	for DIR in ${LONGSEARCHDIRS}; do
		if [ -d ${DIR} ]; then
			RKHTMPVAR=`${FIND_CMD} ${DIR} -name ".*" 2>/dev/null`
			test -n "${RKHTMPVAR}" && LOOKINDIRS="${LOOKINDIRS} ${RKHTMPVAR}"
		fi
	done


	#
	# Get the whitelisted files and directories.
	#

	ALLOWHIDDENDIRS=" "
	ALLOWHIDDENFILES=" "

	if [ -n "${LOOKINDIRS}" ]; then
		RKHTMPVAR=`get_option 1 multi ALLOWHIDDENDIR` || exit 1

		for DIR in ${RKHTMPVAR}; do
			ALLOWHIDDENDIRS="${ALLOWHIDDENDIRS} ${DIR}"
		done

		ALLOWHIDDENDIRS="${ALLOWHIDDENDIRS} "


		RKHTMPVAR=`get_option 1 multi ALLOWHIDDENFILE` || exit 1

		for FNAME in ${RKHTMPVAR}; do
			ALLOWHIDDENFILES="${ALLOWHIDDENFILES} ${FNAME}"
		done

		ALLOWHIDDENFILES="${ALLOWHIDDENFILES} "
	fi


	#
	# Next we look for any whitelisted files and directories. We also
	# exclude certain types of files, and Gentoo zero-sized files.
	#

	for FNAME in ${LOOKINDIRS}; do
		if [ $GENTOO -eq 1 ]; then
			test ! -s "${FNAME}" -a -n "`echo \"${FNAME}\" | grep '/\.keep$'`" && continue
		fi

		if [ $FDESCFS -eq 1 ]; then
			test -n "`echo \"${FNAME}/\" | grep \"^${RKHROOTDIR}/dev/fd/[0-9][0-9]*/\"`" && continue
		fi

		FTYPE=`${FILE_CMD} ${FNAME} 2>/dev/null | cat -v | tr '	' ' ' | tr -s ' ' | cut -d' ' -f2-`

		test -z "${FTYPE}" -o -n "`echo \"${FTYPE}\" | egrep 'character special|TDB database|empty'`" && continue


		FILE=`echo "${FNAME}" | sed -e "s:^${RKHROOTDIR}::"`

		if [ "${FTYPE}" = "directory" ]; then
			if [ -n "`echo \"${ALLOWHIDDENDIRS}\" | grep \" ${FILE} \"`" ]; then
				display --to LOG --type INFO FILESYSTEM_HIDDEN_DIR_WL "${FNAME}"
			else
				FOUNDDIRS="${FOUNDDIRS}
${FNAME}"
			fi
		else
			if [ -n "`echo \"${ALLOWHIDDENFILES}\" | grep \" ${FILE} \"`" ]; then
				display --to LOG --type INFO FILESYSTEM_HIDDEN_FILE_WL "${FNAME}"
			else
				FOUNDFILES="${FOUNDFILES}
${FNAME}: ${FTYPE}"
			fi
		fi
	done


	#
	# Now display the results.
	#

	if [ -z "${FOUNDDIRS}" -a -z "${FOUNDFILES}" ]; then
		display --to SCREEN+LOG --type PLAIN --result NONE_FOUND --color GREEN --log-indent 2 --screen-indent 4 FILESYSTEM_HIDDEN_CHECK
	else
		display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 FILESYSTEM_HIDDEN_CHECK

		IFS=$IFSNL

		for RKHTMPVAR in ${FOUNDDIRS}; do
			test -z "${RKHTMPVAR}" && continue
			display --to LOG --type WARNING FILESYSTEM_HIDDEN_DIR_FOUND "${RKHTMPVAR}"
		done

		for RKHTMPVAR in ${FOUNDFILES}; do
			test -z "${RKHTMPVAR}" && continue
			display --to LOG --type WARNING FILESYSTEM_HIDDEN_FILE_FOUND "${RKHTMPVAR}"
		done

		IFS=$RKHIFS
	fi

	return
}


do_local_host_checks() {

	#
	# This function carries out a sequence of tests on the local
	# host.
	#

	if `check_test local_host`; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --nl CHECK_LOCALHOST
		display --to LOG --type INFO STARTING_TEST local_host
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST local_host
		return
	fi


	#
	# We start by performing checks on the startup files.
	#

	do_system_startup_file_checks


	#
	# Now we check the /etc/passwd file, and run some checks
	# on the accounts and groups.
	#

	do_group_accounts_check


	#
	# Next check some of the system configuration files.
	#

	do_system_config_files_check


	#
	# Finally check the filesystem for suspicious files.
	#

	do_filesystem_check

	keypresspause

	return
}


do_app_checks() {

	#
	# This function carries out a sequence of application checks.
	#

	if `check_test apps`; then
		display --to SCREEN+LOG --type PLAIN --color YELLOW --nl --nl-after CHECK_APPS
		display --to LOG --type INFO STARTING_TEST apps
	else
		display --to LOG --type INFO --nl USER_DISABLED_TEST apps
		return
	fi


	#
	# First we check that our apps data file is present.
	#

	if [ ! -s "${DB_PATH}/programs_bad.dat" ]; then
		display --to SCREEN+LOG --type WARNING --screen-indent 2 APPS_DAT_MISSING
		return
	fi


	#
	# We loop through the applications and obtain the version number.
	# This is then checked against the file of known bad versions.
	# We build up a list of application names, the version number,
	# and whether it is known to be bad or not. When this has all
	# been done, we then display the results.
	#
	# The results line for each application is made up of percent (%)
	# delimited fields. They are:
	#
	#   application%description%version%if known bad%whole version number
	#
	# A 'version' number of '-1' means the application was not found.
	#
	# An 'if known bad' number of:
	#
	#	'-1' means a specific version of the application is whitelisted,
	#	'-2' means the application is whitelisted, regardless of version.
	#

	APPS_COUNT=0
	APP_RESULTS=""

	APP_NAMES="exim:Exim MTA
		   gpg:GnuPG
		   httpd:Apache
		   named:Bind DNS
		   openssl:OpenSSL
		   php:PHP
		   procmail:Procmail MTA
		   proftpd:ProFTPd
		   sshd:OpenSSH"

	APPS_TOTAL_COUNT=`echo "${APP_NAMES}" | wc -l | tr -d ' '`


	#
	# Get the list of whitelisted application versions.
	#

	APP_WHITELIST=""

	RKHTMVAR=`get_option 2 single APP_WHITELIST` || exit 1

	test -n "${RKHTMVAR}" && APP_WHITELIST=`echo " ${RKHTMVAR} " | tr '[:upper:]' '[:lower:]'`


	IFS=$IFSNL

	for APP in ${APP_NAMES}; do
		APP=`echo ${APP} | sed -e 's/^[ 	]*//'`

		APPLICATION=`echo ${APP} | cut -d: -f1`
		APPLICATION_DESC=`echo ${APP} | cut -d: -f2-`

		IFS=$RKHIFS
		APP_CMD_FOUND=`find_cmd ${APPLICATION}`
		IFS=$IFSNL

		if [ -z "${APP_CMD_FOUND}" ]; then
			APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%-1"
			continue
		fi


		#
		# Find out the version of the application.
		#

		APPS_COUNT=`expr ${APPS_COUNT} + 1`

		VERSION=""
		WHOLE_VERSION=""

		#
		# Applications which are whitelisted completely (no specific
		# version number), are handled first.
		#

		if [ -n "`echo \"${APP_WHITELIST}\" | grep \" ${APPLICATION} \"`" ]; then
			APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%0%-2"
		else
			case "${APPLICATION}" in
			exim)
				WHOLE_VERSION=`${APP_CMD_FOUND} -bV 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | grep '^Exim version [0-9]' | awk '{ print $3 }'`
				;;
			gpg)
				WHOLE_VERSION=`${APP_CMD_FOUND} --version --homedir / 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | grep 'GnuPG' | awk '{ print $3 }'`
				;;
			httpd)
				WHOLE_VERSION=`${APP_CMD_FOUND} -v 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | grep -i '^Server version:[ 	][ 	]*Apache/[0-9]' | cut -d' ' -f3 | cut -d'/' -f2`
				;;
			named)
				WHOLE_VERSION=`${APP_CMD_FOUND} -v 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | egrep '^(named|BIND)[ 	][ 	]*[0-9]' | grep -v '/' | awk '{ print $2 }'`

				if [ -n "`echo \"${VERSION}\" | grep '^[^-]*\.[0-9][0-9]*-P[^-]*-'`" ]; then
					VERSION=`echo "${VERSION}" | cut -d'-' -f1-2`
				elif [ -n "`echo \"${VERSION}\" | grep '^[^-]*\.[0-9][0-9]*-[^P]'`" ]; then
					VERSION=`echo "${VERSION}" | cut -d'-' -f1`
				fi

				if [ -z "${VERSION}" ]; then
					VERSION=`${APP_CMD_FOUND} -v | awk '{ print $2 }'`
				fi
				;;
			openssl)
				WHOLE_VERSION=`${APP_CMD_FOUND} version 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | grep '^OpenSSL[ 	][ 	]*[0-9]' | cut -d' ' -f2`

				if [ -n "`echo \"${VERSION}\" | grep '^[^-]*-fips'`" ]; then
					VERSION=`echo "${VERSION}" | cut -d'-' -f1`
				fi
				;;
			php)
				WHOLE_VERSION=`${APP_CMD_FOUND} -v 2>/dev/null`
				VERSION=`echo "${WHOLE_VERSION}" | grep '^PHP[ 	][ 	]*[0-9]' | awk '{ print $2 }' | cut -d'-' -f1`
				;;
			procmail)
				WHOLE_VERSION=`${APP_CMD_FOUND} -v 2>&1`
				VERSION=`echo "${WHOLE_VERSION}" | grep '^procmail[ 	][ 	]*v[0-9]' | awk '{ print $2 }' | sed -e 's/^v//'`
				;;
			proftpd)
				WHOLE_VERSION=`${APP_CMD_FOUND} -v 2>&1`
				VERSION=`echo "${WHOLE_VERSION}" | grep 'ProFTPD[ 	][ 	]*Version[ 	][ 	]*[0-9]' | awk '{ print $4 }'`
				;;
			sshd)
				WHOLE_VERSION=`${APP_CMD_FOUND} -t -d 2>&1`
				VERSION=`echo "${WHOLE_VERSION}" | grep 'sshd version OpenSSH' | sed -e 's/^.*sshd version OpenSSH_//' | cut -d' ' -f1`

				if [ -n "`echo \"${VERSION}\" | grep '+'`" ]; then
					VERSION=`echo "${VERSION}" | cut -d'+' -f1`
				fi
				;;
			esac


			VERSION=`echo "${VERSION}" | tr -d '\r'`
			WHOLE_VERSION=`echo "${WHOLE_VERSION}" | tr -d '\r'`

			if [ -z "${VERSION}" ]; then
				WHOLE_VERSION=`echo "${WHOLE_VERSION}" | tr '\n' '%'`

				APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%%0%${WHOLE_VERSION}"
				continue
			fi


			#
			# Now see if the application version is known to be bad.
			#

			RKHTMPVAR=`echo "${VERSION}" | sed -e 's/\./\\\./g'`

			if [ -n "`echo \"${APP_WHITELIST}\" | grep \" ${APPLICATION}:${RKHTMPVAR} \"`" ]; then
				APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%${VERSION}%-1"
			elif [ -n "`egrep \"^${APPLICATION}:.* ${RKHTMPVAR}( |$)\" ${DB_PATH}/programs_bad.dat 2>&1`" ]; then
				APPS_FAILED_COUNT=`expr ${APPS_FAILED_COUNT} + 1`

				APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%${VERSION}%1"
			else
				APP_RESULTS="${APP_RESULTS}
${APPLICATION}%${APPLICATION_DESC}%${VERSION}%0"
			fi
		fi
	done

	IFS=$RKHIFS


	#
	# Now display the results.
	#

	if [ $APPS_COUNT -eq 0 ]; then
		display --to SCREEN+LOG --type WARNING APPS_NONE_FOUND
	else
		IFS=$IFSNL

		for RKHTMPVAR in ${APP_RESULTS}; do
			APPLICATION=`echo "${RKHTMPVAR}" | cut -d% -f1`
			APPLICATION_DESC=`echo "${RKHTMPVAR}" | cut -d% -f2`
			VERSION=`echo "${RKHTMPVAR}" | cut -d% -f3`

			if [ -z "${VERSION}" ]; then
				WHOLE_VERSION=`echo "${RKHTMPVAR}" | cut -d% -f5- | tr '%' '\n'`

				display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"

				if [ -n "${WHOLE_VERSION}" ]; then
					display --to LOG --type INFO APPS_CHECK_WHOLE_VERSION_USED "${APPLICATION}" "${WHOLE_VERSION}"
				else
					display --to LOG --type INFO APPS_CHECK_VERSION_UNKNOWN "${APPLICATION}"
				fi
			elif [ "${VERSION}" = "-1" ]; then
				display --to LOG --type INFO APPS_NOT_FOUND "${APPLICATION}"
			else
				ISBAD=`echo "${RKHTMPVAR}" | cut -d% -f4`

				if [ -n "`echo $ECHOOPT \"${ISBAD}\" | grep '[^-0-9]'`" ]; then
					display --to SCREEN+LOG --type PLAIN --result SKIPPED --color YELLOW --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"
					display --to LOG --type INFO APPS_CHECK_VERSION_UNKNOWN "${APPLICATION}"
				elif [ $ISBAD -eq -2 ]; then
					display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"
					display --to LOG --type INFO APPS_CHECK_WL "${APPLICATION}"
				elif [ $ISBAD -eq -1 ]; then
					display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"
					display --to LOG --type INFO APPS_CHECK_VERSION_WL "${APPLICATION}" "${VERSION}"
				elif [ $ISBAD -eq 1 ]; then
					display --to SCREEN+LOG --type PLAIN --result WARNING --color RED --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"
					display --to LOG --type WARNING APPS_CHECK_FOUND "${APPLICATION}" "${VERSION}"
				else
					display --to SCREEN+LOG --type PLAIN --result OK --color GREEN --log-indent 2 --screen-indent 4 APPS_CHECK "${APPLICATION_DESC}"
					display --to LOG --type INFO APPS_CHECK_VERSION_FOUND "${APPLICATION}" "${VERSION}"
				fi
			fi
		done

		IFS=$RKHIFS
	fi


	display --to LOG --type INFO APPS_TOTAL_COUNT $APPS_COUNT $APPS_TOTAL_COUNT

	return
}


display_check_summary() {

	#
	# This function displays a short summary of some of the
	# groups of checks performed.
	#

	if [ $QUIET -eq 0 -o \( $SHOWWARNINGSONLY -eq 1 -a $WARNING_COUNT -gt 0 \) ]; then
		RKHTMPVAR=2
	else
		RKHTMPVAR=1
	fi

	display --to SCREEN+LOG --type PLAIN --nl ${RKHTMPVAR} SUMMARY_TITLE1
	display --to SCREEN+LOG --type PLAIN SUMMARY_TITLE2


	#
	# Do file properties summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_PROP_SCAN

	if `check_test properties`; then
		if [ $SUMMARY_PROP_REQCMDS -eq 1 ]; then
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_REQCMDS
		fi

		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_COUNT $PROP_FILE_LIST_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_PROP_FAILED $PROP_FAILED_COUNT
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Do rootkit check summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_RKT_SCAN

	if `check_test rootkits || check_test startup_malware`; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_COUNT $ROOTKIT_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_FAILED $ROOTKIT_FAILED_COUNT

		if [ -n "${ROOTKIT_FAILED_NAMES}" ]; then
			ROOTKIT_FAILED_NAMES=`echo "${ROOTKIT_FAILED_NAMES}" | sed -e 's/, $//'`
			display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_RKT_NAMES "${ROOTKIT_FAILED_NAMES}"
		fi
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Do application check summary.
	#

	display --to SCREEN+LOG --type PLAIN --nl SUMMARY_APPS_SCAN

	if `check_test apps`; then
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_APPS_COUNT $APPS_COUNT
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_APPS_FAILED $APPS_FAILED_COUNT
	else
		display --to SCREEN+LOG --type PLAIN --screen-indent 4 SUMMARY_CHKS_SKIPPED
	fi


	#
	# Display the amount of time the system checking took.
	#

	if [ $BEGINTIME -eq 0 ]; then
		display --to SCREEN+LOG --type PLAIN --nl SUMMARY_NO_SCAN_TIME
	else
		display --to SCREEN+LOG --type PLAIN --nl SUMMARY_SCAN_TIME "${TOTAL_SCANTIME}"
	fi


	#
	# Display where the log file is located, if there is one.
	#

	if [ $NOLOG -eq 0 ]; then
		display --to SCREEN --type PLAIN --nl --nl-after SUMMARY_LOGFILE "${RKHLOGFILE}"
	else
		display --to SCREEN --type PLAIN --nl --nl-after SUMMARY_NO_LOGFILE
	fi

	return
}


do_system_check() {

	#
	# This function performs the various rootkit and security checks
	# for the program. We start by initialising variables used for
	# the rootkit checks.
	#

	display --to LOG --type PLAIN --nl CHECK_START

	do_system_check_initialisation


	#
	# Next, for Solaris we see if we are running Solaris 10 or not.
	# This can be useful to know in some of the tests since we will
	# use different mechanisms on Solaris 10 from those on Solaris
	# 9 and before.
	#

	SOL_PROC=0
	SOLARISX=""

	if [ $SUNOS -eq 1 ]; then
		#
		# If we are running Solaris 10, then see if we have the
		# command pathname available.
		#
		# Solaris 10 and above should have the 'a.out' file
		# present. We use the PID of 1 here since it should exist
		# on all systems.
		#
		# If we are running Solaris 10 (or above), then we add
		# the '-X' option to the 'lsof' command in order to get
		# the deleted files.
		#

		if [ -h "/proc/1/path/a.out" ]; then
			SOLARISX='-X'
			test $HAVE_READLINK -eq 1 && SOL_PROC=1
		fi
	fi


	#
	# Record the start time if we can. The total time taken for
	# scanning will only be calculated and displayed if the
	# start time can be set.
	#

	BEGINTIME=0
	ENDTIME=0

	if [ -n "$SECONDS" ]; then
		BEGINTIME=$SECONDS
	elif [ $BSDOS -eq 1 ]; then
		BEGINTIME=`date +%s`
	elif [ -n "${PERL_CMD}" ]; then
		BEGINTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
	fi


	#
	# Send a start message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Rootkit hunter check started (version ${PROGRAM_version})"
	fi


	#
	# We start with checks of some of the commands (binaries) and 
	# libraries on the system, to make sure that they have not
	# been tampered with.
	#

	do_system_commands_checks


	#
	# Next are the rootkit checks.
	#

	do_rootkit_checks


	#
	# Next are some network port, and interface checks.
	#

	do_network_checks


	#
	# Next are checks of the files for the local host.
	#

	do_local_host_checks


	#
	# Next are checks on specific applications.
	#

	do_app_checks


	#
	# Now record the end time.
	#

	if [ $BEGINTIME -ne 0 ]; then
		if [ -n "$SECONDS" ]; then
			ENDTIME=$SECONDS
		elif [ $BSDOS -eq 1 ]; then
			ENDTIME=`date +%s`
		else
			ENDTIME=`${PERL_CMD} -e 'printf "%d\n", time;'`
		fi

		TOTAL_SCANTIME=`expr ${ENDTIME} - ${BEGINTIME}`
		TOTALMINS=`expr ${TOTAL_SCANTIME} / 60`
		TOTALSECS=`expr ${TOTAL_SCANTIME} % 60`

		if [ $TOTALMINS -gt 0 ]; then
			if [ $TOTALMINS -eq 1 ]; then
				TOTAL_SCANTIME="${TOTALMINS} minute and "
			else
				TOTAL_SCANTIME="${TOTALMINS} minutes and "
			fi
		else
			TOTAL_SCANTIME=""
		fi

		if [ $TOTALSECS -eq 1 ]; then
			TOTAL_SCANTIME="${TOTAL_SCANTIME}${TOTALSECS} second"
		else
			TOTAL_SCANTIME="${TOTAL_SCANTIME}${TOTALSECS} seconds"
		fi
	fi


	#
	# Display the summary of the results.
	#

	if [ $SHOW_SUMMARY -eq 1 ]; then
		#
		# Unfortunately we need to do a kludge here!
		# The user may have used the '--quiet' option,
		# so we need to force the summary to be displayed.
		# By resetting the NOTTY variable we can get
		# the output shown.
		#

		OLD_NOTTY=$NOTTY
		test $SHOW_SUMMARY_OPT -eq 1 && NOTTY=0

		display_check_summary

		if [ $WARNING_COUNT -eq 0 ]; then
			display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_NOT_FOUND
		else
			display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND

			if [ $NOLOG -eq 1 ]; then
				display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_FOUND_RERUN
			else
				display --to SCREEN --type PLAIN --nl-after CHECK_WARNINGS_FOUND_CHK_LOG "${RKHLOGFILE}"
			fi
		fi

		NOTTY=$OLD_NOTTY
	fi


	#
	# Send a finish message to syslog if the user requested that.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Scanning took ${TOTAL_SCANTIME}"
	fi


	#
	# If some warning or error has been seen, then make sure the
	# user is told about it. We also set the return code, to allow
	# the user to detect it being non-zero.
	#

	if [ $WARNING_COUNT -gt 0 ]; then
		if [ $SHOWWARNINGSONLY -eq 1 ]; then
			#
			# Unfortunately we need to do a kludge again!
			# By requesting that only warnings are shown,
			# the following output would not normally be
			# displayed (because they are not warnings).
			#

			OLD_NOTTY=$NOTTY
			NOTTY=0

			display --to SCREEN --type PLAIN --nl CHECK_WARNINGS_FOUND

			if [ $NOLOG -eq 1 ]; then
				display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND_RERUN
			else
				display --to SCREEN --type PLAIN CHECK_WARNINGS_FOUND_CHK_LOG "${RKHLOGFILE}"
			fi

			NOTTY=$OLD_NOTTY
		fi


		if [ -n "${USE_SYSLOG}" ]; then
			${LOGGER_CMD} -t "${PROGRAM_NAME}" -p ${USE_SYSLOG} "Please inspect this machine, because it may be infected."
		fi


		if [ -n "${MAILONWARNING}" ]; then
			eval "echo 'Please inspect this machine, because it may be infected.' | ${MAIL_CMD} ${MAILONWARNING}"
		fi

		RET_CODE=1
	fi

	return
}


check_os_info() {

	#
	# This function checks the current O/S information against
	# that stored in the rkhunter.dat file. Any change could
	# mean that the file properties checks could give several
	# false-positive answers. As such we warn users that
	# a change has occurred.
	#

	#
	# First check if the host name has changed.
	#

	OS_CHANGED=0

	display --to LOG --type PLAIN --nl OSINFO_START


	if [ $WARN_ON_OS_CHANGE -eq 1 ]; then
		IND_COUNT=9
		OSINFO_WARNING="WARNING"
	else
		IND_COUNT=6
		OSINFO_WARNING="INFO"
		display --to LOG --type INFO FILE_PROP_NO_OS_WARNING
	fi


	OLD_HOST=`grep '^Host:' ${RKHDAT_FILE} | cut -d: -f2-`

	if [ "${HOST_NAME}" != "${OLD_HOST}" ]; then
		OS_CHANGED=1
		display --to LOG --type "${OSINFO_WARNING}" OSINFO_HOST_CHANGE1
		display --to LOG --type PLAIN --log-indent $IND_COUNT OSINFO_HOST_CHANGE2 "${OLD_HOST}" "${HOST_NAME}"
	fi


	#
	# Next check if the O/S name has changed.
	#

	OLD_OSNAME=`grep '^OS:' ${RKHDAT_FILE} | cut -d: -f2-`

	if [ "${OSNAME}" != "${OLD_OSNAME}" ]; then
		OS_CHANGED=1
		display --to LOG --type "${OSINFO_WARNING}" OSINFO_OSVER_CHANGE1
		display --to LOG --type PLAIN --log-indent $IND_COUNT OSINFO_OSVER_CHANGE2 "${OLD_OSNAME}" "${OSNAME}"
	fi


	#
	# Check if the prelinking status has changed.
	#

	if [ -z "`grep '^Prelinked:Yes' ${RKHDAT_FILE}`" ]; then
		OLD_PRELINK=0
	else
		OLD_PRELINK=1
	fi

	if [ $PRELINKED -ne $OLD_PRELINK ]; then
		OS_CHANGED=1
		if [ $PRELINKED -eq 1 ]; then
			display --to LOG --type "${OSINFO_WARNING}" OSINFO_PRELINK_CHANGE ''
		else
			display --to LOG --type "${OSINFO_WARNING}" OSINFO_PRELINK_CHANGE 'not '
		fi
	fi


	#
	# Check if the system architecture has changed. We treat
	# the i386-type architectures as the same. We also treat
	# the sun-type archictures the same as 'sparc'.
	#

	OLD_ARCH=`grep '^Arch:' ${RKHDAT_FILE} | cut -d: -f2-`

	if [ -n "`echo ${OLD_ARCH} | grep 'i[0-9]86'`" ]; then
		OLD_ARCH_TYPE="i386"
	elif [ -n "`echo ${OLD_ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${OLD_ARCH} | grep 'sparc'`" ]; then
		OLD_ARCH_TYPE="sparc"
	else
		OLD_ARCH_TYPE=$OLD_ARCH
	fi

	if [ -n "`echo ${ARCH} | grep 'i[0-9]86'`" ]; then
		ARCH_TYPE="i386"
	elif [ -n "`echo ${ARCH} | grep 'sun[0-9][a-z]'`" -o -n "`echo ${ARCH} | grep 'sparc'`" ]; then
		ARCH_TYPE="sparc"
	else
		ARCH_TYPE=$ARCH
	fi

	if [ "${OLD_ARCH_TYPE}" != "${ARCH_TYPE}" ]; then
		OS_CHANGED=1
		display --to LOG --type "${OSINFO_WARNING}" OSINFO_ARCH_CHANGE1
		display --to LOG --type PLAIN --log-indent $IND_COUNT OSINFO_ARCH_CHANGE2 "${OLD_ARCH}" "${ARCH}"
	fi

	if [ $OS_CHANGED -eq 1 ]; then
		display --to LOG --type PLAIN --log-indent $IND_COUNT OSINFO_MSG1
		display --to LOG --type PLAIN --log-indent $IND_COUNT OSINFO_MSG2

		if [ $WARN_ON_OS_CHANGE -eq 1 -a $UPDT_ON_OS_CHANGE -eq 0 ]; then
			display --to LOG --type WARNING --nl PROPUPD_WARN
		fi

		test $UPDT_ON_OS_CHANGE -eq 1 && PROP_UPDATE=1
	else
		display --to LOG --type INFO OSINFO_END
	fi

	return
}


set_file_prop_dirs_files() {

	#
	# This function sets up the list of directories we look in,
	# and the list of files we look for, in order to perform
	# the file properties checks.
	#
	# Any non-existent files are simply left in for the checks
	# to skip over. However, any symbolic links are expanded and
	# the result of the link is added to the list. This avoids
	# any attempt to simply replace a link, and avoid it being
	# detected by the file hash value check.
	#
	# We also check to see if any of the directories are links.
	# If it is then we add the link target directory.
	#

	PROP_DIR_LIST=""

	for DIR in ${BINPATHS} ${USER_DIR_LIST}; do
		LINKDIR="${RKHROOTDIR}${DIR}"

		test ! -d "${LINKDIR}" && continue

		if [ -h "${LINKDIR}" -a $HAVE_READLINK -eq 1 ]; then
			LINKDIR=`${READLINK_CMD} -f ${LINKDIR}`

			#
			# If the link target directory does not start
			# with the RKHROOTDIR, then prepend it.
			#

			if [ -z "`echo \"${LINKDIR}\" | grep \"^${RKHROOTDIR}/\"`" ]; then
				LINKDIR="${RKHROOTDIR}${LINKDIR}"
			fi
		fi

		if [ -z "`echo \" ${PROP_DIR_LIST} \" | grep \" ${LINKDIR} \"`" ]; then
			PROP_DIR_LIST="${PROP_DIR_LIST} ${LINKDIR}"
		fi
	done


	PROP_FILE_LIST="adduser amd awk basename bash bget cat chattr checkproc
	    chkconfig chmod chown chroot cp cron csh curl cut date depmod df
	    diff dirname dmesg dpkg dpkg-query du echo ed egrep elinks env fgrep
	    file find fuser GET grep groupadd groupdel groupmod groups grpck head id
	    ifconfig ifdown ifstatus ifup inetd init insmod ip kallsyms kill
	    killall ksyms kudzu last lastlog ldd less links locate logger login
	    ls lsattr lsmod lsof lynx mail md5 md5sum mktemp mlocate modinfo
	    modload modprobe modstat modunload more mount mv netstat newgrp
	    newsyslog nologin passwd perl pgrep pkgdb pkg_info prelink ps pstree pwck
	    pwd readlink rkhunter rmmod rpm rsyslogd runcon runlevel sed sestatus sh
	    sha1 sha1sum sha224 sha224sum sha256 sha256sum sha384 sha384sum sha512
	    sha512sum size skdet slocate sockstat sort stat strace strings su sudo
	    sulogin sysctl syslogd systat tail tcpd test top touch tr uname
	    uniq useradd userdel usermod users vipw vmstat w watch wc wget whatis
	    whereis which who whoami xinetd"

	#
	# We add in some extra commands to check depending on the O/S.
	#

	if [ $SUNOS -eq 1 ]; then
		PROP_FILE_LIST="${PROP_FILE_LIST} gawk gbasename gcat gchmod gchown
				gcksum gcp gcut gdate gdiff gdiff3 gdirname gdu gecho
				gegrep genv gfile gfind ggrep ggroups ghead gid glocate
				gls gmd5sum gmv gpwd gsed gsize gsort gstrings gsum
				gtail gtest gtouch guname guniq gusers gwc gwho gwhoami
				inetadm nawk truss"
	elif [ "${OPERATING_SYSTEM}" = "FreeBSD" ]; then
		PROP_FILE_LIST="${PROP_FILE_LIST} kldload kldstat kldunload"
	fi

	if [ "${OPERATING_SYSTEM}" = "Linux" ]; then
		if [ -n "`uname -r | grep '^2\.6'`" ]; then
			PROP_FILE_LIST="${PROP_FILE_LIST} unhide-linux26"
		else
			PROP_FILE_LIST="${PROP_FILE_LIST} unhide"
		fi
        elif [ $SUNOS -eq 1 -o $BSDOS -eq 1 ]; then
		PROP_FILE_LIST="${PROP_FILE_LIST} unhide"
        fi


	#
	# Next we quickly loop through the user supplied list of files,
	# and ignore any that are already in the builtin list.
	#

	PROP_FILE_LIST=`echo ${PROP_FILE_LIST}`

	if [ -n "${USER_SIMPLE_FILE_LIST}" ]; then
		RKHTMPVAR=""

		for FNAME in ${USER_SIMPLE_FILE_LIST}; do
			FNAMEGREP=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

			test -z "`echo \" ${PROP_FILE_LIST} \" | grep \" ${FNAMEGREP} \"`" && RKHTMPVAR="${RKHTMPVAR} ${FNAME}"
		done

		USER_SIMPLE_FILE_LIST=`echo ${RKHTMPVAR}`

		PROP_FILE_LIST="${PROP_FILE_LIST} ${USER_SIMPLE_FILE_LIST}"
	fi


	#
	# Now loop through the file list and look for any
	# symbolic links. If a link is found, then add on
	# the file and directory that the link points to.
	#

	if [ $HAVE_READLINK -eq 1 ]; then
		EXTRA_DIRS=""
		EXTRA_FILES=""

		for DIR in ${PROP_DIR_LIST}; do
			for FNAME in ${PROP_FILE_LIST}; do
				if [ -h "${DIR}/${FNAME}" ]; then
					RKHTMPVAR=`${READLINK_CMD} -f ${DIR}/${FNAME}`

					test ! -f "${RKHTMPVAR}" && continue

					#
					# Get the link target directory name.
					#

					test -n "${DIRNAME_CMD}" && LINKDIR=`${DIRNAME_CMD} ${RKHTMPVAR}` || LINKDIR=`echo "${RKHTMPVAR}" | sed -e 's:/[^/]*$::'`

					#
					# We need to see if the target directory starts with
					# the RKHROOTDIR. If it does not, then we prepend it.
					#

					if [ -z "`echo \"${LINKDIR}\" | grep \"^${RKHROOTDIR}/\"`" ]; then
						LINKDIR="${RKHROOTDIR}${LINKDIR}"
					fi

					#
					# Now see if we already have the directory listed.
					# If not, then we add it on.
					#

					if [ -z "`echo \" ${PROP_DIR_LIST} ${EXTRA_DIRS} \" | grep \" ${LINKDIR} \"`" ]; then
						EXTRA_DIRS="${EXTRA_DIRS} ${LINKDIR}"
					fi


					#
					# Now get the link target file name.
					#

					LINKFNAME=`echo "${RKHTMPVAR}" | sed -e 's:^.*/::'`

					FNAMEGREP=`echo "${LINKFNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

					#
					# And finally check if we already have it listed.
					#

					if [ -z "`echo \" ${PROP_FILE_LIST} ${EXTRA_FILES} \" | grep \" ${FNAMEGREP} \"`" ]; then
						EXTRA_FILES="${EXTRA_FILES} ${LINKFNAME}"
					fi
				fi
			done
		done

		test -n "${EXTRA_DIRS}" && PROP_DIR_LIST="${PROP_DIR_LIST} ${EXTRA_DIRS}"
		test -n "${EXTRA_FILES}" && PROP_FILE_LIST="${PROP_FILE_LIST} ${EXTRA_FILES}"
	fi

	PROP_FILE_LIST_TOTAL=`echo ${PROP_FILE_LIST} | wc -w | tr -d ' '`

	return
}


check_test() {

	#
	# This function will check whether a given test name should
	# be run or not. It returns 0 if the test is to be run,
	# and 1 if it is not.
	#

	if [ "${ENABLE_TESTS}" = "all" -o -n "`echo \" ${ENABLE_TESTS} \" | grep \" $1 \"`" ]; then
		if [ "${DISABLE_TESTS}" = "none" -o -z "`echo \" ${DISABLE_TESTS} \" | grep \" $1 \"`" ]; then
			return 0
		fi
	fi

	return 1
}


display_tests() {

	#
	# This function is used to simply output all the available
	# tests and test group names. If a group name itself contains
	# a group name, then that second group name is omitted. It
	# could be confusing if it was included.
	#

	RKHTMPVAR2="all none ${KNOWN_TESTS}"

	if [ -n "${SORT_CMD}" ]; then
		RKHTMPVAR2=`echo "${RKHTMPVAR2}" | tr ' ' '\n' | ${SORT_CMD} | tr '\n' ' '`
		GROUPED_TESTS=`echo "${GROUPED_TESTS}" | tr ' ' '\n' | ${SORT_CMD} | tr '\n' ' '`
	fi


	display --to SCREEN --type PLAIN --nl LIST_TESTS

	while test -n "${RKHTMPVAR2}"; do
		STR=`echo ${RKHTMPVAR2} | cut -d' ' -f1-6`
		RKHTMPVAR2=`echo ${RKHTMPVAR2} | cut -d' ' -f7-`

		echo "    ${STR}"

		test "${STR}" = "${RKHTMPVAR2}" && RKHTMPVAR2=""
	done


	display --to SCREEN --type PLAIN --nl LIST_GROUPED_TESTS

	#
	# Sort out the maximum group name length, so we can do some
	# simple formatting of the output.
	#

	MAX=0

	for STR in ${GROUPED_TESTS}; do
		LEN=`echo "${STR}" | cut -d: -f1 | wc -c | tr -d ' '`
		test $LEN -gt $MAX && MAX=$LEN
	done


	#
	# Now loop through the group names.
	#

	RKHTMPVAR2=" `echo ${GROUPED_TESTS}`"

	for STR in ${GROUPED_TESTS}; do
		TEST_NAMES=""
		GROUP_NAME=`echo "${STR}" | cut -d: -f1`

		#
		# Add on spaces to expand the group name to the maximum.
		#

		LEN=`echo "${GROUP_NAME}" | wc -c | tr -d ' '`
		LEN=`expr $MAX - $LEN`

		test $LEN -gt 0 && GROUP_NAME="${GROUP_NAME} `echo \"${BLANK_LINE}\" | cut -d' ' -f1-$LEN`"


		#
		# Check through the list of tests for this group name.
		# If the test name is a group name itself, then go to
		# the next test name, otherwise add it to our list of
		# test names.
		#

		for TEST in `echo "${STR}" | cut -d: -f2- | tr ':' ' '`; do
			RKHTMPVAR=`echo "${RKHTMPVAR2}" | grep " ${TEST}:"`

			if [ -z "${RKHTMPVAR}" ]; then
				TEST_NAMES="${TEST_NAMES}:${TEST}"
			else
				continue
			fi
		done


		#
		# Finally, sort our list of test names and display them.
		#

		TEST_NAMES=`echo "${TEST_NAMES}" | sed -e 's/^://'`

		if [ -n "${SORT_CMD}" ]; then
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' '\n' | ${SORT_CMD} | tr '\n' ' '`
		else
			TEST_NAMES=`echo "${TEST_NAMES}" | tr ':' ' '`
		fi

		echo "    ${GROUP_NAME} => ${TEST_NAMES}"
	done

	return
}


display_languages() {

	#
	# This function is used to simply output all the available
	# languages in a basic format of 10 per line.
	#

	KNOWN_LANGS=`ls -1 ${DB_PATH}/i18n 2>/dev/null`

	if [ -n "${SORT_CMD}" ]; then
		KNOWN_LANGS=`echo "${KNOWN_LANGS}" | ${SORT_CMD}`
	fi


	display --to SCREEN --type PLAIN --nl LIST_LANGS

	while test -n "${KNOWN_LANGS}"; do
		STR=`echo ${KNOWN_LANGS} | cut -d' ' -f1-10`
		KNOWN_LANGS=`echo ${KNOWN_LANGS} | cut -d' ' -f11-`

		echo "    ${STR}"

		test "${STR}" = "${KNOWN_LANGS}" && KNOWN_LANGS=""
	done

	return
}


display_rootkits() {

	#
	# This function is used to simply output all the rootkit
	# names which rkhunter will check for.
	#

	RKHTMPVAR2=`echo ${KNOWN_ROOTKITS} | sed -e 's/^,*//; s/,$//'`


	display --to SCREEN --type PLAIN --nl LIST_RTKTS

	while test -n "${RKHTMPVAR2}"; do
		STR=`echo ${RKHTMPVAR2} | cut -d',' -f1-6`
		RKHTMPVAR2=`echo ${RKHTMPVAR2} | cut -d',' -f7-`

		if [ "${STR}" = "${RKHTMPVAR2}" -o -z "${RKHTMPVAR2}" ]; then
			RKHTMPVAR2=""
		else
			STR="${STR},"
		fi

		echo "    ${STR}"
	done

	return
}

get_lock() {

	#
	# This function attempts to get the lock file. If it cannot
	# get the lock then it waits for 10 seconds, and then tries
	# again. It repeats this until the timeout has passed.
	#
	# We cannot log anything at this time, but we can use
	# 'display' to display messages on the users screen.
	#

	RKHTMPVAR=0

	while test $RKHTMPVAR -lt $LOCK_TIMEOUT; do
		if [ -f "${RKHTMPDIR}/rkhunter.LCK" ]; then
			test $SHOW_LOCK_MSGS -eq 1 -a $RKHTMPVAR -eq 0 && display --to SCREEN --type PLAIN --nonl LOCK_WAIT

			sleep 10;

			RKHTMPVAR=`expr ${RKHTMPVAR} + 10`

			test $SHOW_LOCK_MSGS -eq 1 && display --to SCREEN --type PLAIN --nonl NAME "..${RKHTMPVAR}"
		else
			break
		fi
	done

	if [ $RKHTMPVAR -lt $LOCK_TIMEOUT -o ! -f "${RKHTMPDIR}/rkhunter.LCK" ]; then
		touch ${RKHTMPDIR}/rkhunter.LCK

		test $SHOW_LOCK_MSGS -eq 1 -a $RKHTMPVAR -gt 0 -a $NOTTY -eq 0 && echo ""

		#
		# We handle any subsequent exit conditions by setting a trap.
		#

		trap "rm -f ${RKHTMPDIR}/rkhunter.LCK >/dev/null 2>&1" 0 >/dev/null 2>&1
	else
		#
		# We need to be careful here. We do not want to display the message if the user
		# has explicitly requested not to, but we must display it if the user has set
		# the '--report-warnings-only' option (we treat it as a warning), or the
		# '--cronjob' option. If we did not, then the user may think that rkhunter has
		# run and that there were no warnings. If the user used the '--quiet' option,
		# then this message won't be displayed. However, that is okay because they
		# should be checking the return-code.
		#

		if [ $SHOWWARNINGSONLY -eq 1 -o $CRONJOB -eq 1 ]; then
			NOTTY=0
			RKHTMPVAR=""
		else
			RKHTMPVAR="--nl"
		fi

		test $SHOW_LOCK_MSGS -eq 1 -o $NOTTY -eq 0 && display --to SCREEN --type PLAIN ${RKHTMPVAR} LOCK_FAIL

		exit 1
	fi

	return
}


help() {

	#
	# This function outputs the help menu.
	#

	echo $ECHOOPT ""
	echo $ECHOOPT "Usage: rkhunter {--check | --unlock | --update | --versioncheck |"
	echo $ECHOOPT "                 --propupd [{filename | directory | package name},...] |"
	echo $ECHOOPT "                 --list [{tests | {lang | languages} | rootkits}] |"
	echo $ECHOOPT "                 --version | --help} [options]"
	echo $ECHOOPT ""

	echo $ECHOOPT "Current options are:"
	echo $ECHOOPT "         --append-log                  Append to the logfile, do not overwrite"
	echo $ECHOOPT "         --bindir <directory>...       Use the specified command directories"
	echo $ECHOOPT "     -c, --check                       Check the local system"
	echo $ECHOOPT "  --cs2, --color-set2                  Use the second color set for output"
	echo $ECHOOPT "         --configfile <file>           Use the specified configuration file"
	echo $ECHOOPT "         --cronjob                     Run as a cron job"
	echo $ECHOOPT "                                       (implies -c, --sk and --nocolors options)"
	echo $ECHOOPT "         --dbdir <directory>           Use the specified database directory"
	echo $ECHOOPT "         --debug                       Debug mode"
	echo $ECHOOPT "                                       (Do not use unless asked to do so)"
	echo $ECHOOPT "         --disable <test>[,<test>...]  Disable specific tests"
	echo $ECHOOPT "                                       (Default is to disable no tests)"
	echo $ECHOOPT "         --display-logfile             Display the logfile at the end"
	echo $ECHOOPT "         --enable  <test>[,<test>...]  Enable specific tests"
	echo $ECHOOPT "                                       (Default is to enable all tests)"
	echo $ECHOOPT "         --hash {MD5 | SHA1 | SHA224 | SHA256 | SHA384 | SHA512 |"
	echo $ECHOOPT "                 NONE | <command>}     Use the specified file hash function"
	echo $ECHOOPT "                                       (Default is SHA1, then MD5)"
	echo $ECHOOPT "     -h, --help                        Display this help menu, then exit"
	echo $ECHOOPT " --lang, --language <language>         Specify the language to use"
	echo $ECHOOPT "                                       (Default is English)"
	echo $ECHOOPT "         --list [tests | languages |   List the available test names, languages,"
	echo $ECHOOPT "                 rootkits]             or checked for rootkits, then exit"
	echo $ECHOOPT "     -l, --logfile [file]              Write to a logfile"
	echo $ECHOOPT "                                       (Default is $DFLT_LOGFILE)"
	echo $ECHOOPT "         --noappend-log                Do not append to the logfile, overwrite it"
	echo $ECHOOPT "         --nocolors                    Use black and white output"
	echo $ECHOOPT "         --nolog                       Do not write to a logfile"
	echo $ECHOOPT "--nomow, --no-mail-on-warning          Do not send a message if warnings occur"
	echo $ECHOOPT "   --ns, --nosummary                   Do not show the summary of check results"
	echo $ECHOOPT " --novl, --no-verbose-logging          No verbose logging"
	echo $ECHOOPT "         --pkgmgr {RPM | DPKG | BSD |  Use the specified package manager to obtain or"
	echo $ECHOOPT "                   NONE}               verify file hash values. (Default is NONE)"
	echo $ECHOOPT "         --propupd [file | directory | Update the entire file properties database,"
	echo $ECHOOPT "                    package]...        or just for the specified entries"
	echo $ECHOOPT "     -q, --quiet                       Quiet mode (no output at all)"
	echo $ECHOOPT "  --rwo, --report-warnings-only        Show only warning messages"
	echo $ECHOOPT "     -r, --rootdir <directory>         Use the specified root directory"
	echo $ECHOOPT "   --sk, --skip-keypress               Don't wait for a keypress after each test"
	echo $ECHOOPT "         --summary                     Show the summary of system check results"
	echo $ECHOOPT "                                       (This is the default)"
	echo $ECHOOPT "         --syslog [facility.priority]  Log the check start and finish times to syslog"
	echo $ECHOOPT "                                       (Default level is $SYSLOG_DFLT_PRIO)"
	echo $ECHOOPT "         --tmpdir <directory>          Use the specified temporary directory"
	echo $ECHOOPT "         --unlock                      Unlock (remove) the lock file"
	echo $ECHOOPT "         --update                      Check for updates to database files"
	echo $ECHOOPT "   --vl, --verbose-logging             Use verbose logging (on by default)"
	echo $ECHOOPT "     -V, --version                     Display the version number, then exit"
	echo $ECHOOPT "         --versioncheck                Check for latest version of program"
	echo $ECHOOPT "     -x, --autox                       Automatically detect if X is in use"
	echo $ECHOOPT "     -X, --no-autox                    Do not automatically detect if X is in use"
	echo $ECHOOPT ""

	return
}


######################################################################
#
# Initialisation
#
######################################################################


#
# Unfortunately, for the Korn shell if we are debugging then
# we need to enable tracing in each of the functions.
#

if [ $DEBUG_OPT -eq 1 -a "${MYSHELL}" = "ksh" ]; then
	RKHTMPVAR=`typeset +f`

	for RKHTMPVAR2 in $RKHTMPVAR; do
		typeset -ft ${RKHTMPVAR2}
	done
fi

#
# We reset the SIGPIPE signal to its default
# to try and avoid any output write errors.
#

trap - 13 >/dev/null 2>&1


#
# Initialise the variables used throughout the program.
#

PROGRAM_NAME="Rootkit Hunter"
PROGRAM_version="1.3.6"
PROGRAM_copyright_owner="Michael Boelen"
PROGRAM_copyright="Copyright (c) 2003-2009, ${PROGRAM_copyright_owner}"
PROGRAM_blurb="
Currently under active development by the ${PROGRAM_NAME} project team.
Please review your rkhunter.conf before using.
Please review the documentation before posting bug reports or questions.
To report bugs, obtain updates, or provide patches or comments, please go to:
http://rkhunter.sourceforge.net

To ask questions about rkhunter, please use the rkhunter-users mailing list.
Note this is a moderated list: please subscribe before posting.

${PROGRAM_NAME} comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under the
terms of the GNU General Public License. See the LICENSE file for details.
"
PROGRAM_license="
${PROGRAM_NAME} ${PROGRAM_version}, ${PROGRAM_copyright}
${PROGRAM_blurb}
"

# Set to run as a cron job.
CRONJOB=0
CHECK=0

# Set to display the logfile at the end.
CATLOGFILE=0

NOLOG=0
RKHLOGFILE=""
DFLT_LOGFILE="/var/log/rkhunter.log"

# Set to have the logfile appended to rather than overwritten.
APPEND_LOG=0
APPEND_OPT=0

# Set to have the logfile copied if there was an error.
COPY_LOG_ON_ERROR=0

# Set to have rkhunter start/finish messages, and warnings,
# logged to syslog. The priority/severity can be set on the
# command-line or in the configuration file.
USE_SYSLOG=""
SYSLOG_DFLT_PRIO="authpriv.notice"

DFLT_BINPATHS="/bin /usr/bin /sbin /usr/sbin /usr/local/bin /usr/local/sbin /usr/libexec /usr/local/libexec"

# By default do not send a mail-on-warning message.
NOMOW=0
MAILONWARNING=""

HASH_FUNC=""
OLD_HASH_FUNC=""
PKGMGR=""
OLD_PKGMGR=""
OLD_ATTRUPD=""
HASH_OPT=0
SHA_SIZE=0
HASH_FLD_IDX=1
PROP_DIR_LIST=""
PROP_FILE_LIST=""
PROP_FILE_LIST_COUNT=0
PROP_FILE_LIST_TOTAL=0

PRELINKED=0
PRELINK_CMD=""
PRELINK_HASH=""
PKGMGR_MD5_HASH=""
MD5_CMD=""
EPOCH_DATE_CMD=""
PKGMGRNOVRFY=""

UPDATE=0
PROP_UPDATE=0
PROPUPD_OPT=""
VERSIONCHECK=0

# By default use coloured output.
COLORS=1
CLRSET2=0

# Are whitelisted results to be shown as white?
WLIST_IS_WHITE=0

# Set to automatically detect if X is in use, and
# hence use the second colour set.
AUTO_X_DTCT=0
AUTO_X_OPT=0

# Set to be quiet. No output, but the return code will be set.
QUIET=0

# Set to only show warnings.
SHOWWARNINGSONLY=0

# This will be set if the file properties hash value check
# or the file attributes check is to be performed.
HASH_CHECK_ENABLED=0
SKIP_HASH_MSG=0

# Users can reset this to a new root directory.
RKHROOTDIR=""

# Users can reset this to a new temporary directory.
RKHTMPDIR=""

# Users can reset this to a new database directory.
DB_PATH=""

# Users can reset this to a new configuration file.
CONFIGFILE=""

# Users cannnot reset this. The local config file must
# be in the same directory as the main config file.
LOCALCONFIGFILE=""

# Users can reset this to new command directories.
BINPATHS=""

# Default 'id' command. Solaris will reset this.
ID_CMD="id"

# Set if we don't want to wait for a keypress after each test.
SKIP_KEY_PRESS=0

# Is this the Gentoo operating system?
GENTOO=0

# Set the O/S type if necessary.
BSDOS=0
SUNOS=0
IRIXOS=0

case "${OPERATING_SYSTEM}" in
*BSD)
	BSDOS=1
	HASH_FLD_IDX=4
	;;
SunOS)
	SUNOS=1
	;;
IRIX*)
	IRIXOS=1
	;;
esac

# This will be set if the local host or O/S has changed in some way.
OS_CHANGED=0

# By default we want a warning if the O/S has changed.
WARN_ON_OS_CHANGE=1

# If set, then automatically perform a properties update if the O/S changes.
UPDT_ON_OS_CHANGE=0

# These SSH options can only be set in the configuration file.
ALLOW_SSH_PROT_V1=0
ALLOW_SSH_ROOT_USER=""
SSH_CONFIG_DIR=""

# These syslog options can only be set in the configuration file.
ALLOW_SYSLOG_REMOTE_LOGGING=0
SYSLOG_CONFIG_FILE=""

# Set check counters to be used by the summary.
ROOTKIT_COUNT=0
ROOTKIT_FAILED_COUNT=0
ROOTKIT_FAILED_NAMES=""

PROP_FAILED_COUNT=0
SUMMARY_PROP_REQCMDS=0

APPS_COUNT=0
APPS_TOTAL_COUNT=0
APPS_FAILED_COUNT=0

# Timers for the system check.
BEGINTIME=0
TOTAL_SCANTIME=""

# This will be set if a warning message is logged.
WARNING_COUNT=0

# Set if grsecurity is installed.
GRSECINSTALLED=0

# Ksyms or kallsyms file used in some checks.
KSYMS_FILE=""

# Record for logging the command-line being used.
CMD_LINE="$0 $*"

# Create a spaced-separated PATH variable.
SPACEDPATH=`echo ${PATH} | tr ':' ' '`

# List of commands used during RKH. If a command does not exist, then
# the code may use an alternative method.
CMDLIST="basename diff dirname file find ifconfig ip ldd lsattr lsmod lsof mktemp netstat perl pgrep ps pwd readlink sort stat strings uniq"

# Commands that are required to exist for RKH to run.
REQCMDS="awk cat chmod chown cp cut date egrep grep head ls mv sed tail touch tr uname wc"

# List of commands used to download files from the web. This list is 
# used by the '--update' and '--versioncheck' options. Preferred commands
# are listed first. This can be overridden by the config file.
WEBCMDLIST="wget curl elinks links lynx bget GET"

RKHWEBCMD=""
RKHWEBCMD_OPTS=""
RKHWEBCMD_BASE=""

HOST_NAME=""

# This is the return code for the program actions - update, check, etc.
# Its value may either be 0 (no error) or 1 (an error occurred).
# The '--versioncheck' option may set the return code to 2 to
# indicate that an update is available.
# The '--update' option may set the return code to 2 to
# indicate that an update occurred.
RET_CODE=0

# Initially there is no language, this will be set later.
LANGUAGE=""
UPDATE_LANG=""

# A space-separated list of test names we recognise.
KNOWN_TESTS="strings properties hashes scripts immutable attributes
	     deleted_files packet_cap_apps apps rootkits known_rkts
	     additional_rkts malware local_host network passwd_changes
	     group_changes possible_rkts possible_rkt_files possible_rkt_strings
	     system_commands shared_libs shared_libs_path running_procs
	     hidden_procs trojans other_malware os_specific startup_malware
	     startup_files group_accounts system_configs filesystem suspscan
	     ports promisc loaded_modules avail_modules"

# A space-separated list of test 'group names'. This list allows test
# names to be grouped together. For example, 'system_commands' can include
# the specific tests of 'strings' and 'hashes'. Both test
# group names, and specific test names, can be used with the test
# enable/disable options. In this list group names are colon-separated
# from the specific test names.
#
GROUPED_TESTS="system_commands:properties:strings:hashes:scripts:shared_libs:shared_libs_path:immutable:attributes
	       properties:hashes:scripts:immutable:attributes
	       shared_libs:shared_libs_path
	       rootkits:known_rkts:additional_rkts:possible_rkts:possible_rkt_files:possible_rkt_strings:malware:running_procs:hidden_procs:deleted_files:trojans:other_malware:os_specific:suspscan:loaded_modules:avail_modules
	       additional_rkts:possible_rkts:possible_rkt_files:possible_rkt_strings
	       possible_rkts:possible_rkt_files:possible_rkt_strings
	       network:packet_cap_apps:ports:promisc
	       malware:running_procs:hidden_procs:deleted_files:suspscan:other_malware
	       local_host:startup_files:passwd_changes:group_changes:startup_malware:group_accounts:system_configs:filesystem
	       startup_files:startup_malware
	       os_specific:loaded_modules:avail_modules
	       group_accounts:passwd_changes:group_changes"

# A comma-separated list of rootkits we check for.
# NOTE: This is a COMMA separated list. Any single quotes need to be handled specially - i.e.
# put between double-quotes.
KNOWN_ROOTKITS='55808 Trojan - Variant A, AjaKit, aPa Kit, Adore, Apache Worm, Ambient (ark),
  Balaur, BeastKit, beX2, BOBKit, cb, CiNIK Worm (Slapper.B variant), CX,
  Danny-Boy'"'"'s Abuse Kit, Devil, Dica, Dreams, Duarawkz, Enye LKM, Flea Linux, FreeBSD, Fu,
  Fuck`it, GasKit, Heroin LKM, HjC Kit, ignoKit, iLLogiC, IntoXonia-NG, Irix, Kitko, Knark,
  ld-linuxv.so, Li0n Worm, Lockit / LJK2, Mood-NT, MRK, Ni0, Ohhara, Optic Kit (Tux), OSX, Oz,
  Phalanx, Phalanx2, Portacelo, R3dstorm Toolkit, RH-Sharpe'"'"'s, RSHA'"'"'s, Scalper Worm,
  Shutdown, SHV4, SHV5, Sin, SInAR, Slapper, Sneakin, Spanish, Suckit, SunOS / NSDAP, 
  SunOS Rootkit, Superkit, TBD (Telnet BackDoor), TeLeKiT, T0rn, trNkit, Trojanit Kit, Tuxtendo, URK, 
  Vampire, VcKit, Volc, w00tkit, weaponX, Xzibit, X-Org SunOS, zaRwT.KiT, ZK'

# The program defaults of which tests to perform will be set later.
ENABLE_TESTS=""
DISABLE_TESTS=""

# Set if the command-line options --enable or --disable have been used.
ENDIS_OPT=0

# Set if the --list option has been used.
LIST_OPT=""

# Space-filled line used for the display function.
BLANK_LINE="                                                              "

# Initially say that we are connected to a terminal.
NOTTY=0

# By default show the system check summary.
SHOW_SUMMARY=1
SHOW_SUMMARY_OPT=0

# By default log most things that are checked.
VERBOSE_LOGGING=1

# We copy the original IFS value, and set RKHIFS to space, tab, newline.
# IFSNL is set to just a newline.
ORIGIFS=$IFS
RKHIFS=" 	
"
IFSNL="
"
IFS=$RKHIFS

# No default set for the system startup files and directories.
STARTUP_PATHS=""
STARTUP_PATHS_LOGGED=0

# Set a default for the inetd configuration file.
INETD_CONF_PATH="/etc/inetd.conf"
INETDALLOWEDSVCS=""

# Set a default for the xinetd configuration file.
XINETD_CONF_PATH="/etc/xinetd.conf"
XINETDALLOWEDSVCS=""

# Set if only the '--update' option is used.
UPDATE_ONLY=0

# Set if UPDATE_ONLY is set, and some language files are missing.
RKHLANGUPDT=0

# By default we rotate the mirrors in the mirrors.dat file,
# and we update the file when the '--update' option is used.
# The default MIRRORS_MODE is set such that we use both local
# and remote mirrors.
ROTATE_MIRRORS=1
UPDATE_MIRRORS=1
MIRRORS_MODE=0

# By default suspscan verbose logging should be initialised and off.
SUSPSCAN_DEBUG=0

# SELinux runcon usage as determined by get_if_prelinked.
USE_RUNCON=0
SELINUX_ENABLED=0

# These get set if any network ports are to be whitelisted.
PORT_WHITELIST=""
PORT_WHITELIST_PATH=""
PORT_WHITELIST_ALL_TRUSTED=0

# This will be set to the shadow file location if required.
SHADOW_FILE=""
HAVE_TCB_SHADOW=0

# The O/S 'release' file location.
OS_VERSION_FILE=""

# By default no rootkit files or directories are whitelisted.
RTKT_DIR_WHITELIST=""
RTKT_FILE_WHITELIST=""

# The full pathname of the 'rkhunter.dat' file.
RKHDAT_FILE=""

# The full pathname of the 'rkhunter_prop_list.dat' file.
RKH_FILEPROP_LIST=""

# This gets set if we have a working readlink command.
HAVE_READLINK=0

# By default no commands are to be exempt from dependency errors.
PRELINK_DEP_ERR_CMDS=""

# User provided files/dirs for the file properties check.
USER_FILE_LIST=""
USER_SIMPLE_FILE_LIST=""
USER_DIR_LIST=""
USER_EXCLUDE_PROP=""

# This gets set if any shared libraries are to be whitelisted.
SHARED_LIB_WHITELIST=""

# If used, these lock values must be set in the config file.
USE_LOCKING=0
LOCK_TIMEOUT=0
SHOW_LOCK_MSGS=1

# This gets set if the unlock command-line option is used.
UNLOCK=0


######################################################################
#
# Command-line option processing
#
######################################################################


#
# Display the help menu if no options were given.
#

if [ $# -eq 0 ]; then
	help
	exit 0
fi


#
# Check the command-line options. If set, these will override the
# configuration file options.
#

while [ $# -ge 1 ]; do
	case "$1" in
	--append-log | --appendlog)
		APPEND_LOG=1
		APPEND_OPT=1
		;;
	--bindir)
		BINPATHS=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			BINPATHS="$1"
			;;
		esac

		if [ -z "${BINPATHS}" ]; then
			echo "No command directories specified."
			exit 1
		fi
		;;
	-c | --check | --checkall)
		CHECK=1
		;;
	--configfile)
		CONFIGFILE=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			CONFIGFILE="$1"
			;;
		esac

		if [ -z "${CONFIGFILE}" ]; then
			echo "No configuration file specified."
			exit 1
		fi
		;;
	--cronjob)
		CHECK=1
		CRONJOB=1
		COLORS=0
		SKIP_KEY_PRESS=1
		;;
	--cs2 | --colorset2 | --color-set2)
		CLRSET2=1
		;;
	--dbdir)
		DB_PATH=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			DB_PATH="$1"
			;;
		esac

		if [ -z "${DB_PATH}" ]; then
			echo "No database directory specified."
			exit 1
		fi
		;;
	--debug)
		SKIP_KEY_PRESS=1
		;;
	--display-logfile | --displaylogfile | --display-log | --displaylog)
		CATLOGFILE=1
		;;
	--disable)
		DISABLE_TESTS=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			ENDIS_OPT=1
			DISABLE_TESTS="$1"
			;;
		esac

		if [ -z "${DISABLE_TESTS}" ]; then
			echo "No tests specified to disable."
			exit 1
		fi
		;;
	--enable)
		ENABLE_TESTS=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			ENDIS_OPT=1
			ENABLE_TESTS="$1"
			;;
		esac

		if [ -z "${ENABLE_TESTS}" ]; then
			echo "No tests specified to enable."
			exit 1
		fi
		;;
	--hash)
		HASH_FUNC=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			HASH_FUNC="$1"
			HASH_OPT=1
			;;
		esac

		if [ -z "${HASH_FUNC}" ]; then
			echo "No hash function specified."
			exit 1
		fi
		;;
	-h | --help)
		help
		exit 0
		;;
	-l | --log | --logfile | --createlogfile | --createlog | --create-log | --create-logfile)
		RKHLOGFILE="${DFLT_LOGFILE}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			RKHLOGFILE="$1"
			;;
		esac
		;;
	--lang | --language)
		LANGUAGE=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			LANGUAGE="$1"
			;;
		esac

		if [ -z "${LANGUAGE}" ]; then
			echo "No language specified."
			exit 1
		fi
		;;
	--list)
		case "$2" in
		test | tests | check | checks)
			shift
			LIST_OPT="${LIST_OPT} tests "
			;;
		lang | langs | language | languages)
			shift
			LIST_OPT="${LIST_OPT} languages "
			;;
		rootkit | rootkits)
			shift
			LIST_OPT="${LIST_OPT} rootkits "
			;;
		"")
			LIST_OPT="${LIST_OPT} tests languages rootkits "
			;;
		-*)
			LIST_OPT="${LIST_OPT} tests languages rootkits "
			;;
		*)
			echo "Invalid '--list' option specified: $2"
			exit 1
			;;
		esac
		;;
	--noappend-log | --no-append-log | --noappendlog)
		APPEND_LOG=0
		APPEND_OPT=1
		;;
	--nocolors | --no-colors | --nocolor | --no-color)
		COLORS=0
		;;
	--nolog | --no-log)
		RKHLOGFILE="/dev/null"
		;;
	--nomow | --no-mow | --no-mailonwarning | --no-mail-on-warning)
		NOMOW=1
		;;
	--novl | --noverboselogging | --no-verbose-logging)
		VERBOSE_LOGGING=0
		;;
	--ns | --nosummary | --no-summary)
		SHOW_SUMMARY=0
		SHOW_SUMMARY_OPT=1
		;;
	--pkgmgr)
		PKGMGR=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			PKGMGR="$1"
			;;
		esac

		if [ -z "${PKGMGR}" ]; then
			echo "No package manager specified."
			exit 1
		fi
		;;
	--propupd | --prop-update | --propupdate | --properties-update | --hashupd)
		PROP_UPDATE=1
		PROPUPD_OPT=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			PROPUPD_OPT="$1"
			;;
		esac
		;;
	-q | --quiet)
		QUIET=1
		;;
	--rwo | --swo | --report-warnings-only | --show-warnings-only)
		QUIET=1
		SHOWWARNINGSONLY=1
		;;
	-r | --rootdir)
		RKHROOTDIR=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			RKHROOTDIR="$1"
			;;
		esac

		if [ -z "${RKHROOTDIR}" ]; then
			echo "No root directory specified."
			exit 1
		fi
		;;
	-sk | --sk | --skip-keypress | --skipkeypress)
		SKIP_KEY_PRESS=1
		;;
	--summary)
		SHOW_SUMMARY=1
		SHOW_SUMMARY_OPT=1
		;;
	--syslog)
		USE_SYSLOG="${SYSLOG_DFLT_PRIO}"

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			USE_SYSLOG="$1"
			;;
		esac
		;;
	--tmpdir)
		RKHTMPDIR=""

		case "$2" in
		"")
			;;
		-*)
			;;
		*)
			shift
			RKHTMPDIR="$1"
			;;
		esac

		if [ -z "${RKHTMPDIR}" ]; then
			echo "No temporary directory specified."
			exit 1
		fi
		;;
	--unlock)
		UNLOCK=1
		;;
	--update)
		UPDATE=1
		;;
	--vl | --verboselogging | --verbose-logging)
		VERBOSE_LOGGING=1
		;;
	-V | --version)
		echo "${PROGRAM_NAME} ${PROGRAM_version}"
		echo "${PROGRAM_blurb}"
		exit 0
		;;
	--versioncheck)
		VERSIONCHECK=1
		;;
	-x | --autox)
		AUTO_X_OPT=1
		AUTO_X_DTCT=1
		;;
	-X | --no-autox)
		AUTO_X_OPT=1
		AUTO_X_DTCT=0
		;;
	*)
		echo "Invalid option specified: $1"
		exit 1
		;;
	esac

	shift
done


#
# We check that we are root. If we are not, then only the
# help and version command-line options are valid.
#

if [ $SUNOS -eq 1 ]; then
	test -x "/usr/xpg4/bin/id" && ID_CMD="/usr/xpg4/bin/id"
fi

RKHTMPVAR=`${ID_CMD} -u 2>/dev/null`

if [ "${RKHTMPVAR}" != "0" -a "${RKHTMPVAR}" != "root" ]; then
	echo "You must be the root user to run this program."
	exit 1
fi


#
# We need to see if we are to run a check before we get to the
# configuration file processing. Basically if either of the
# --enable or --disable options are used, and this is not a
# property update run, then we will do a check. For update runs
# only the 'hashes' or 'attributes' tests are likely to be named.
#

test $ENDIS_OPT -eq 1 -a $PROP_UPDATE -eq 0 && CHECK=1


#
# See if only the '--update' option has been used.
#

test $UPDATE -eq 1 -a $CHECK -eq 0 -a $PROP_UPDATE -eq 0 -a $VERSIONCHECK -eq 0 && UPDATE_ONLY=1


#
# Before going too much further we need to ensure that some basic
# commands are present on the system. We cannot do this using
# the BINDIR option because that requires processing the configuration
# file, which in turn requires the commands we want to check on. As
# such we use the default command directory list. We do not assign
# these commands to variables, but will do for other commands which we
# look for later on.
#

check_required_commands "${SPACEDPATH} ${DFLT_BINPATHS}"


######################################################################
#
# Configuration file processing
#
######################################################################


#
# Now we check for the configuration file. We then see if there is a
# local configuration file present in the same directory, and finally
# check the various options within them.
#
# NOTE: Do not change the format of the following 'if' statement.
# The installer script will modify it directly during installation.
#

if [ -z "${CONFIGFILE}" ]; then
	if [ -f /etc/rkhunter.conf ]; then
		CONFIGFILE="/etc/rkhunter.conf"
	else
		CONFIGFILE="/usr/local/etc/rkhunter.conf"
	fi
fi

if [ ! -f "${CONFIGFILE}" ]; then
	echo "Unable to find configuration file: ${CONFIGFILE}"
	exit 1
elif [ ! -r "${CONFIGFILE}" ]; then
	echo "Configuration file is not readable: ${CONFIGFILE}"
	exit 1
elif [ ! -s "${CONFIGFILE}" ]; then
	echo "Configuration file is empty: ${CONFIGFILE}"
	exit 1
fi

RKHTMPVAR=`echo "${CONFIGFILE}" | sed -e 's:/[^/]*$::'`

test -f "${RKHTMPVAR}/rkhunter.conf.local" && LOCALCONFIGFILE="${RKHTMPVAR}/rkhunter.conf.local"

get_configfile_options


######################################################################
#
# Option processing
#
######################################################################


#
# Next we check some of the options to make sure we can proceed. We
# also set up some final variables based on the combination of options
# we have been given.
#

#
# First we process the '--list' option if it has been given.
#

if [ -n "${LIST_OPT}" ]; then
	for RKHTMPVAR in ${LIST_OPT}; do
		case "${RKHTMPVAR}" in
		tests)
			display_tests
			;;
		languages)
			display_languages
			;;
		*)
			display_rootkits
			;;
		esac
	done

	exit 0
fi


#
# Next we must see if we are doing an update only, and if there were
# some language file problems. If so, then we must not log or display
# anything.
#

if [ $RKHLANGUPDT -eq 1 ]; then
	QUIET=1
	COLORS=0
	RKHLOGFILE="/dev/null"
fi


#
# If the logfile has been disabled, then we cannot let the
# program run when certain options are used. If we did, the user
# would see no output and might assume that all was well.
#

if [ "${RKHLOGFILE}" = "/dev/null" ]; then
	NOLOG=1
	VERBOSE_LOGGING=0
	COPY_LOG_ON_ERROR=0

	if [ $SHOWWARNINGSONLY -eq 1 ]; then
		echo "The logfile has been disabled - unable to report warnings."
		exit 1
	elif [ $CATLOGFILE -eq 1 ]; then
		echo "The logfile has been disabled - unable to display the log file."
		exit 1
	fi
fi


#
# Set up the colors to be used.
#

if [ $COLORS -eq 1 ]; then
	NORMAL="[0;39m"		# Foreground colour to default

	if [ $CLRSET2 -eq 0 ]; then
		RED="[1;31m"		# Bright red
		GREEN="[1;32m"	# Bright green
		YELLOW="[1;33m"	# Bright yellow
		WHITE="[1;37m"	# White
	else
		RED="[1;31m"		# Bright red
		GREEN="[0;32m"	# Green
		YELLOW="[0;35m"	# Purple
		WHITE="[0;30m"	# Black
	fi
fi


if [ $CHECK -eq 1 ]; then
	#
	# Check if we have a ksyms or kallsyms file.
	#

	if [ -f "${RKHROOTDIR}/proc/ksyms" ]; then
		KSYMS_FILE="${RKHROOTDIR}/proc/ksyms"
	elif [ -f "${RKHROOTDIR}/proc/kallsyms" ]; then
		KSYMS_FILE="${RKHROOTDIR}/proc/kallsyms"
	fi

	#
	# Check to make sure that the symbols are readable
	# as certain security frameworks hide this.
	#

	if [ -z "`head -1 /proc/kallsyms 2>/dev/null`" ]; then
		KSYMS_FILE=""
	fi
fi


if [ $CHECK -eq 1 -o $PROP_UPDATE -eq 1 ]; then
	if [ -e ${RKHDAT_FILE} ]; then
		if [ -h ${RKHDAT_FILE} ]; then
			echo "The rkhunter.dat file is a symbolic link: ${RKHDAT_FILE}"
			echo "This is a security problem. The link points to another file, and that file may be modified by rkhunter."
			exit 1
		elif [ ! -f ${RKHDAT_FILE} ]; then
			echo "The rkhunter.dat file is not a file: ${RKHDAT_FILE}"
			exit 1
		fi
	fi

	if [ -e ${RKH_FILEPROP_LIST} ]; then
		if [ -h ${RKH_FILEPROP_LIST} ]; then
			echo "The rkhunter_prop_list.dat file is a symbolic link: ${RKH_FILEPROP_LIST}"
			echo "This is a security problem. The link points to another file, and that file may be modified by rkhunter."
			exit 1
		elif [ ! -f ${RKH_FILEPROP_LIST} ]; then
			echo "The rkhunter_prop_list.dat file is not a file: ${RKH_FILEPROP_LIST}"
			exit 1
		fi
	fi


	#
	# Check if the file properties option has been set. If so, then
	# check that the files and directories are valid. Once that has
	# been done, we can then set up the file properties check directories
	# and file names.
	#

	if [ -n "${PROPUPD_OPT}" ]; then
		if [ ! -f ${RKHDAT_FILE} ]; then
			echo "The file properties file does not exist: ${RKHDAT_FILE}"
			exit 1
		fi

		LEAVE=0
		RKHTMPVAR=""

		PROPUPD_OPT=`echo "${PROPUPD_OPT}" | tr ',' ' ' | tr '	' ' ' | tr -s ' '`
		test "${PROPUPD_OPT}" = " " -o "${PROPUPD_OPT}" = "/" && PROPUPD_OPT=""

		for FNAME in ${PROPUPD_OPT}; do
			if [ -n "`echo \"${FNAME}\" | grep ':'`" ]; then
				# Filename contains ':'
				LEAVE=1
				echo "Invalid file or package name specified: ${FNAME}"
			elif [ -n "`echo \"${FNAME}\" | grep '^[^/].*/'`" ]; then
				# Filename is relative
				LEAVE=1
				echo "Relative file or directory name specified: ${FNAME}"
			elif [ -n "`echo \"${FNAME}\" | grep '^/'`" ]; then
				# Filename is absolute
				FNAMEGREP=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

				RKHTMPVAR2=`grep "^File:${FNAMEGREP}:" ${RKHDAT_FILE} 2>/dev/null | cut -d: -f2 | tr '\n' ' '`

				if [ -z "${RKHTMPVAR2}" ]; then
					if [ -d "${FNAME}" ]; then
						# Filename is a directory
						RKHTMPVAR2=`grep "^File:${FNAMEGREP}/[^:]*:" ${RKHDAT_FILE} 2>/dev/null | cut -d: -f2 | tr '\n' ' '`

						if [ -n "${RKHTMPVAR2}" ]; then
							RKHTMPVAR="${RKHTMPVAR} ${RKHTMPVAR2}"
						else
							LEAVE=1
							echo "Directory is not in the \"rkhunter.dat\" file: ${FNAME}"
						fi
					else
						LEAVE=1
						echo "Filename is not in the \"rkhunter.dat\" file: ${FNAME}"
					fi
				else
					RKHTMPVAR="${RKHTMPVAR} ${RKHTMPVAR2}"
				fi
			else
				# Filename could be a package name
				# The package names are in field 10 in the rkhunter.dat file
				FNAMEGREP=`echo "${FNAME}" | sed -e 's/\([.[]\)/\\\\\1/g'`

				RKHTMPVAR2=`grep "^File:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:${FNAMEGREP}:" ${RKHDAT_FILE} 2>/dev/null | cut -d: -f2 | tr '\n' ' '`

				if [ -z "${RKHTMPVAR2}" ]; then
					# Filename is just a plain filename
					RKHTMPVAR2=`grep "^File:[^:]*/${FNAMEGREP}:" ${RKHDAT_FILE} 2>/dev/null | cut -d: -f2 | tr '\n' ' '`

					if [ -n "${RKHTMPVAR2}" ]; then
						RKHTMPVAR="${RKHTMPVAR} ${RKHTMPVAR2}"
					else
						LEAVE=1
						echo "File or package name is not in the \"rkhunter.dat\" file: ${FNAME}"
					fi
				else
					RKHTMPVAR="${RKHTMPVAR} ${RKHTMPVAR2}"
				fi
			fi
		done

		if [ $LEAVE -eq 0 ]; then
			PROPUPD_OPT=""
			test -n "${RKHTMPVAR}" && PROPUPD_OPT=" ${RKHTMPVAR} "
		else
			exit 1
		fi
	fi

	if `check_test properties` || test $PROP_UPDATE -eq 1; then
		set_file_prop_dirs_files
	fi


	#
	# We need to record the previously used
	# hash function and package manager.
	#

	if [ -s ${RKHDAT_FILE} ]; then
		OLD_HASH_FUNC=`grep '^Hash:' ${RKHDAT_FILE} | cut -d: -f2-`

		OLD_PKGMGR=`grep '^Pkgmgr:' ${RKHDAT_FILE} | cut -d: -f2`

		OLD_ATTRUPD=`grep '^Attributes:' ${RKHDAT_FILE} | cut -d: -f2`
	fi
fi


if [ $PROP_UPDATE -eq 1 -a $PRELINKED -eq 1 -a -z "${PKGMGR}" -a "${HASH_FUNC}" != "NONE" ]; then
	#
	# For a hash update on a prelinked system, we must have
	# a valid hash function to use. The package managers use
	# an MD5 hash function by default.
	#

	if [ -z "${PRELINK_HASH}" ]; then
		RKHTMPVAR=`echo "${HASH_FUNC}" | cut -d' ' -f1`

		if [ -z "`echo ${RKHTMPVAR} | egrep -i 'sha1|md5'`" ]; then
			if [ $HASH_OPT -eq 1 ]; then
				echo "This system uses prelinking, but the '--hash' option (${HASH_FUNC}) does not look like SHA1 or MD5."
			else
				echo "This system uses prelinking, but the hash function (${HASH_FUNC}) does not look like SHA1 or MD5."
			fi

			exit 1
		fi
	fi
fi


#
# For the update and versioncheck options, we need to make sure
# we have a command capable of downloading files from the web.
# The first command found is used, unless it has been set in
# the configuration file.
#

if [ $UPDATE -eq 1 -o $VERSIONCHECK -eq 1 ]; then
	if [ -z "${RKHWEBCMD}" ]; then
		FOUND=0

		for CMD in ${WEBCMDLIST}; do
			#
			# Ignore perl commands if perl is not present, or if
			# certain modules are not present.
			#

			if [ "${CMD}" = "GET" ]; then
				test -z "${PERL_CMD}" && continue

				RKHTMPVAR=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl LWP URI HTTP::Status HTTP::Date Getopt::Long 2>&1 | grep 'NOT'`

				test -n "${RKHTMPVAR}" && continue
			elif [ "${CMD}" = "bget" ]; then
				test -z "${PERL_CMD}" && continue

				RKHTMPVAR=`${PERL_CMD} ${SCRIPT_PATH}/check_modules.pl Socket Carp 2>&1 | grep 'NOT'`

				test -n "${RKHTMPVAR}" && continue
			fi


			RKHTMPVAR=`find_cmd ${CMD}`

			if [ -n "${RKHTMPVAR}" ]; then
				FOUND=1
				RKHWEBCMD="${RKHTMPVAR}"
				RKHWEBCMD_BASE="${CMD}"
				break
			fi
		done

		if [ $FOUND -eq 0 ]; then
			echo "The '--update' and '--versioncheck' options require a command able to"
			echo "download files from the web. No such command can be found on the system."
			echo "Examples of commands that could be used are: ${WEBCMDLIST}"
			exit 1
		fi
	fi
fi


#
# If no option is given for the program to action, then say so and exit.
#

if [ $CHECK -eq 0 -a $VERSIONCHECK -eq 0 -a $UPDATE -eq 0 -a $PROP_UPDATE -eq 0 -a $UNLOCK -eq 0 ]; then
	echo "You must enter an option for the program to perform."
	echo "Type in 'rkhunter --help' to see the available options,"
	echo "or read the rkhunter man page."
	exit 1
fi


#
# Handle any locking straight away.
#

if [ $UNLOCK -eq 1 ]; then
	rm -f ${RKHTMPDIR}/rkhunter.LCK >/dev/null 2>&1

	# If we are just unlocking the lock file, then exit.
	test $CHECK -eq 0 -a $VERSIONCHECK -eq 0 -a $UPDATE -eq 0 -a $PROP_UPDATE -eq 0 && exit 0
fi


#
# See if we have grsecurity installed.
#

if [ "${OPERATING_SYSTEM}" = "Linux" -a -n "`uname -a | grep 'grsec'`" ]; then
	GRSECINSTALLED=1
fi


#
# Before writing anything to the screen or log file, we need to
# set some variables.
#
# First we set whether we should be displaying anything on the
# screen or not.
#
test $CRONJOB -eq 1 -o $QUIET -eq 1 && NOTTY=1

#
# Next we get the message types and results from the language file,
# and set them to variables. We have to look in the English file since
# that is the definitive one. We then look for the corresponding keyword
# in the actual language file. This allows the language files to work
# even if we add or remove any of the TYPE or RESULT keywords.
#
IFS=$IFSNL

for LINE in `egrep '^MSG_(TYPE|RESULT)_' ${DB_PATH}/i18n/en 2>/dev/null`; do
	TYPE=`echo "${LINE}" | cut -d: -f1`

	if [ "${LANGUAGE}" != "en" ]; then
		RKHTMPVAR=`grep "^${TYPE}:" ${DB_PATH}/i18n/${LANGUAGE} 2>/dev/null`
		test -n "${RKHTMPVAR}" && LINE=`echo "${RKHTMPVAR}" | sed -e 's/\`/\\\\\`/g'`
	fi

	RKHTMPVAR=`echo "${LINE}" | cut -d: -f2-`

	eval $TYPE=\"${RKHTMPVAR}\"
done

IFS=$RKHIFS


#
# Before we touch the log file we must see if locking is being used.
#

if [ $USE_LOCKING -eq 1 ]; then
	get_lock
fi

#
# Sort out the logfile before we write to it.
#

if [ $NOLOG -eq 0 ]; then
	if [ $APPEND_LOG -eq 0 ]; then
		mv -f ${RKHLOGFILE} ${RKHLOGFILE}.old >/dev/null 2>&1
		touch ${RKHLOGFILE} >/dev/null 2>&1
		chmod 600 ${RKHLOGFILE} >/dev/null 2>&1
	else
		echo "" >>${RKHLOGFILE}
		echo "" >>${RKHLOGFILE}
	fi
fi


#
# Record the hostname. This will be used at several points
# throughout the program. A specific test will specify if
# a hostname has been found or not, so we don't need to
# do anything special here.
#

HOST_NAME=`hostname 2>/dev/null`
test -z "${HOST_NAME}" && HOST_NAME=`uname -n 2>/dev/null`
test -z "${HOST_NAME}" && HOST_NAME="${HOSTNAME}"
HOST_NAME=`echo ${HOST_NAME} | cut -d. -f1`


######################################################################
#
# Initial logging
#
######################################################################


#
# Write out various information messages to the logfile. The first
# set of messages can be skipped if no logfile is to be created.
#

display --to SCREEN --type PLAIN VERSIONLINE "${PROGRAM_NAME}" "${PROGRAM_version}"

if [ $NOLOG -eq 0 ]; then
	if [ -n "${HOST_NAME}" ]; then
		display --to LOG --type PLAIN VERSIONLINE2 "${PROGRAM_NAME}" "${PROGRAM_version}" ${HOST_NAME}
	else
		display --to LOG --type PLAIN VERSIONLINE3 "${PROGRAM_NAME}" "${PROGRAM_version}"
	fi

	display --to LOG --type INFO --nl RKH_STARTDATE "`date`"

	display --to LOG --type PLAIN --nl CONFIG_CHECK_START

	display --to LOG --type INFO OPSYS "${OPERATING_SYSTEM}"

	if [ -s ${RKHDAT_FILE} ]; then
		RKHTMPVAR=`grep '^OS:' ${RKHDAT_FILE} 2>/dev/null | sed -e 's/^OS://'`

		if [ -n "${RKHTMPVAR}" ]; then
			display --to LOG --type INFO PROPUPD_OSNAME_FOUND "${RKHTMPVAR}"
		else
			display --to LOG --type INFO UNAME "`uname -a`"
		fi
	else
		display --to LOG --type INFO UNAME "`uname -a`"
	fi

	display --to LOG --type INFO CONFIG_CMDLINE "${CMD_LINE}"

	test $DEBUG_OPT -eq 1 && display --to LOG --type INFO CONFIG_DEBUGFILE "${RKHDEBUGFILE}"

	display --to LOG --type INFO CONFIG_ENVSHELL ${SHELL} ${MYSHELL}

	display --to LOG --type INFO CONFIG_CONFIGFILE "${CONFIGFILE}"

	test -n "${LOCALCONFIGFILE}" && display --to LOG --type INFO CONFIG_LOCALCONFIGFILE "${LOCALCONFIGFILE}"

	display --to LOG --type INFO CONFIG_INSTALLDIR "${RKHINSTALLDIR}"

	display --to LOG --type INFO CONFIG_LANGUAGE "${LANGUAGE}"

	display --to LOG --type INFO CONFIG_DBDIR "${DB_PATH}"

	display --to LOG --type INFO CONFIG_SCRIPTDIR "${SCRIPT_PATH}"

	display --to LOG --type INFO CONFIG_BINDIR "${SPACEDPATH} ${BINPATHS}"

	if [ -z "${RKHROOTDIR}" ]; then
		display --to LOG --type INFO CONFIG_ROOTDIR_DFLT
	else
		display --to LOG --type INFO CONFIG_ROOTDIR "${RKHROOTDIR}"
	fi

	display --to LOG --type INFO CONFIG_TMPDIR "${RKHTMPDIR}"

	if [ $CHECK -eq 1 ]; then
		if [ $NOMOW -eq 1 ]; then
			display --to LOG --type INFO CONFIG_MOW_DISABLED
		elif [ -z "${MAILONWARNING}" ]; then
			display --to LOG --type INFO CONFIG_NO_MAIL_ON_WARN
		else
			display --to LOG --type INFO CONFIG_MAIL_ON_WARN "${MAILONWARNING}" "${MAIL_CMD}"
		fi
	fi

	test $AUTO_X_DTCT -eq 1 && display --to LOG --type INFO CONFIG_X_AUTO
	test $CLRSET2 -eq 1 && display --to LOG --type INFO CONFIG_CLRSET2

	for CMD in ${CMDLIST}; do
		RKHTMPVAR=`echo ${CMD} | tr '[:lower:]' '[:upper:]'`
		RKHTMPVAR=`eval echo "\\$${RKHTMPVAR}_CMD"`

		if [ -n "${RKHTMPVAR}" ]; then
			display --to LOG --type INFO FOUND_CMD "${CMD}" "${RKHTMPVAR}"
		else
			display --to LOG --type INFO NOT_FOUND_CMD "${CMD}"
		fi
	done

	test -n "${RKHWEBCMD}" && display --to LOG --type INFO FOUND_CMD "${RKHWEBCMD_BASE}" "${RKHWEBCMD}"

	test $GRSECINSTALLED -eq 1 && display --to LOG --type INFO GRSECINSTALLED
fi

if [ $PROP_UPDATE -eq 1 -o $HASH_CHECK_ENABLED -eq 1 ]; then
	if [ -z "${PKGMGR}" -a "${HASH_FUNC}" = "NONE" ]; then
		HASH_CHECK_ENABLED=0
		DISABLE_TESTS="${DISABLE_TESTS} hashes"
		display --to LOG --type INFO HASH_FUNC_DISABLED
	fi

	if [ $PRELINKED -eq 1 ]; then
		display --to LOG --type INFO SYS_PRELINK

		display --to LOG --type INFO FOUND_CMD 'prelink' "${PRELINK_CMD}"

		if [ -n "${SESTATUS_CMD}" ]; then
			display --to LOG --type INFO FOUND_CMD 'sestatus' "${SESTATUS_CMD}"

			if [ $SELINUX_ENABLED -eq 1 ]; then
				display --to LOG --type INFO SYS_SELINUX

				if [ $USE_RUNCON -eq 1 ]; then
					display --to LOG --type INFO FOUND_CMD 'runcon' "${RUNCON_CMD}"
				else
					display --to LOG --type INFO NOT_FOUND_CMD 'runcon'
				fi
			else
				display --to LOG --type INFO SYS_NO_SELINUX
			fi
		else
			display --to LOG --type INFO NOT_FOUND_CMD 'sestatus'
		fi

		if [ "${HASH_FUNC}" = "NONE" ]; then
			if [ -n "${PKGMGR}" ]; then
				display --to LOG --type INFO HASH_FUNC_NONE_PKGMGR
			else
				display --to LOG --type INFO HASH_FUNC_NONE
			fi
		elif [ -n "${PRELINK_HASH}" ]; then
			display --to LOG --type INFO HASH_FUNC_PRELINK "${PRELINK_HASH}"
		elif [ -z "`echo \"${HASH_FUNC}\" | egrep -i 'sha1|md5'`" ]; then
			SKIP_HASH_MSG=2
		else
			display --to LOG --type INFO HASH_FUNC "${HASH_FUNC}"
		fi
	else
		display --to LOG --type INFO SYS_NO_PRELINK

		if [ "${HASH_FUNC}" = "NONE" ]; then
			if [ -n "${PKGMGR}" ]; then
				display --to LOG --type INFO HASH_FUNC_NONE_PKGMGR
			else
				display --to LOG --type INFO HASH_FUNC_NONE
			fi
		elif [ -n "`echo \"${HASH_FUNC}\" | grep '/filehashsha\.pl$'`" ]; then
			display --to LOG --type INFO HASH_FUNC_PERL "SHA${SHA_SIZE}"
		elif [ -n "`echo \"${HASH_FUNC}\" | grep '/filehashmd5\.pl$'`" ]; then
			display --to LOG --type INFO HASH_FUNC_PERL 'MD5'
		else
			display --to LOG --type INFO HASH_FUNC "${HASH_FUNC}"
		fi
	fi

	if [ -s ${RKHDAT_FILE} ]; then
		if [ "${OLD_HASH_FUNC}" = "Disabled" ]; then
			display --to LOG --type INFO HASH_FUNC_OLD_DISABLED
		else
			display --to LOG --type INFO HASH_FUNC_OLD "${OLD_HASH_FUNC}"
		fi

		if [ -z "${OLD_PKGMGR}" ]; then
			display --to LOG --type INFO HASH_PKGMGR_OLD_UNSET
		else
			display --to LOG --type INFO HASH_PKGMGR_OLD "${OLD_PKGMGR}"
		fi
	fi

	display --to LOG --type INFO HASH_FIELD_INDEX "$HASH_FLD_IDX"

	if [ $PROP_UPDATE -eq 1 ]; then
		if ! `check_test hashes` && test $ENDIS_OPT -eq 0; then
			display --to LOG --type INFO HASHUPD_DISABLED
		elif [ -z "${PKGMGR}" ]; then
			if [ $PRELINKED -eq 1 ]; then
				if [ -n "${PRELINK_HASH}" ]; then
					display --to LOG --type INFO HASHUPD_PKGMGR_NOT_SPEC_PRELINKED "${PRELINK_HASH}"
				else
					display --to LOG --type INFO HASHUPD_PKGMGR_NOT_SPEC "${HASH_FUNC}"
				fi
			else
				display --to LOG --type INFO HASHUPD_PKGMGR_NOT_SPEC "${HASH_FUNC}"
			fi
		elif [ -n "${PKGMGR}" ]; then
			display --to LOG --type INFO HASHUPD_PKGMGR "${PKGMGR}"

			case "${PKGMGR}" in
			RPM)
				display --to LOG --type INFO FOUND_CMD "rpm" "${RPM_CMD}"
				;;
			DPKG)
				if [ -z "`echo \"${DPKG_CMD}\" | grep '/dpkg$'`" ]; then
					display --to LOG --type INFO FOUND_CMD "dpkg-query" "${DPKG_CMD}"
				else
					display --to LOG --type INFO FOUND_CMD "dpkg" "${DPKG_CMD}"
				fi
				;;
			BSD)
				display --to LOG --type INFO FOUND_CMD "pkg-info" "${PKG_CMD}"
				;;
			esac
		fi
	fi

	if [ $HASH_CHECK_ENABLED -eq 1 ]; then
		if [ -z "${PKGMGR}" ]; then
			if [ $PRELINKED -eq 1 ]; then
				if [ -n "${PRELINK_HASH}" ]; then
					display --to LOG --type INFO HASH_PKGMGR_NOT_SPEC_PRELINKED "${PRELINK_HASH}"
				else
					display --to LOG --type INFO HASH_PKGMGR_NOT_SPEC "${HASH_FUNC}"
				fi
			else
				display --to LOG --type INFO HASH_PKGMGR_NOT_SPEC "${HASH_FUNC}"
			fi
		elif [ -n "${PKGMGR}" ]; then
			display --to LOG --type INFO HASH_PKGMGR "${PKGMGR}"

			case "${PKGMGR}" in
			RPM)
				display --to LOG --type INFO FOUND_CMD "rpm" "${RPM_CMD}"
				;;
			DPKG)
				if [ -z "`echo \"${DPKG_CMD}\" | grep '/dpkg$'`" ]; then
					display --to LOG --type INFO FOUND_CMD "dpkg-query" "${DPKG_CMD}"
				else
					display --to LOG --type INFO FOUND_CMD "dpkg" "${DPKG_CMD}"
				fi

				display --to LOG --type INFO HASH_PKGMGR_MD5 "${PKGMGR_MD5_HASH}"
				;;
			BSD)
				display --to LOG --type INFO FOUND_CMD "pkg-info" "${PKG_CMD}"
				display --to LOG --type INFO HASH_PKGMGR_MD5 "${PKGMGR_MD5_HASH}"
				;;
			esac
		fi
	fi
fi

RKHTMPVAR=0
test $CHECK -eq 1 && `check_test attributes` && RKHTMPVAR=1

if [ $RKHTMPVAR -eq 1 ]; then
	if [ "${OLD_ATTRUPD}" = "Disabled" ]; then
		display --to LOG --type INFO ATTRUPD_OLD_DISABLED
	elif [ "${OLD_ATTRUPD}" = "Nostatcmd" ]; then
		display --to LOG --type INFO ATTRUPD_OLD_NOSTATCMD
	else
		display --to LOG --type INFO ATTRUPD_OLD_OK
	fi
fi

if [ $PROP_UPDATE -eq 1 ]; then
	if ! `check_test attributes` && test $ENDIS_OPT -eq 0; then
		display --to LOG --type INFO ATTRUPD_DISABLED
	elif [ -z "${STAT_CMD}" ]; then
		display --to LOG --type INFO ATTRUPD_NOSTATCMD
	else
		display --to LOG --type INFO ATTRUPD_OK
	fi
fi

if [ $CHECK -eq 1 -o $PROP_UPDATE -eq 1 ]; then
	display --to LOG --type INFO ENABLED_TESTS "${ENABLE_TESTS}"
	display --to LOG --type INFO DISABLED_TESTS "${DISABLE_TESTS}"
fi

if `check_test properties` || test $PROP_UPDATE -eq 1; then
	if [ -n "${USER_FILE_LIST}" ]; then
		display --to LOG --type INFO USER_FILE_LIST

		for FNAME in ${USER_FILE_LIST}; do
			display --to LOG --type PLAIN --log-indent 6 NAME "${FNAME}"
		done
	fi

	if [ -n "${USER_SIMPLE_FILE_LIST}" ]; then
		display --to LOG --type INFO USER_CMD_LIST

		for FNAME in ${USER_SIMPLE_FILE_LIST}; do
			display --to LOG --type PLAIN --log-indent 6 NAME "${FNAME}"
		done
	fi

	if [ -n "${USER_DIR_LIST}" ]; then
		display --to LOG --type INFO USER_DIR_LIST

		for FNAME in ${USER_DIR_LIST}; do
			display --to LOG --type PLAIN --log-indent 6 NAME "${FNAME}"
		done
	fi

	if [ -n "${USER_EXCLUDE_PROP}" ]; then
		display --to LOG --type INFO USER_EXCLUDE_PROP

		for FNAME in ${USER_EXCLUDE_PROP}; do
			display --to LOG --type PLAIN --log-indent 6 NAME "${FNAME}"
		done
	fi
fi

if [ $UPDATE -eq 1 -o $VERSIONCHECK -eq 1 ]; then
	if [ $ROTATE_MIRRORS -eq 0 ]; then
		display --to LOG --type INFO CONFIG_NO_ROTATE_MIRRORS
	else
		display --to LOG --type INFO CONFIG_ROTATE_MIRRORS
	fi

	if [ $MIRRORS_MODE -eq 0 ]; then
		display --to LOG --type INFO CONFIG_MIRRORS_MODE0
	elif [ $MIRRORS_MODE -eq 1 ]; then
		display --to LOG --type INFO CONFIG_MIRRORS_MODE1
	else
		display --to LOG --type INFO CONFIG_MIRRORS_MODE2
	fi

	if [ $UPDATE -eq 1 ]; then
		if [ $UPDATE_MIRRORS -eq 0 ]; then
			display --to LOG --type INFO CONFIG_NO_UPDATE_MIRRORS
		else
			display --to LOG --type INFO CONFIG_UPDATE_MIRRORS
		fi
	fi
fi

if [ $CHECK -eq 1 ]; then
	test $VERBOSE_LOGGING -eq 0 && display --to LOG --type INFO CONFIG_NO_VL

	if [ -n "${KSYMS_FILE}" ]; then
		display --to LOG --type INFO KSYMS_FOUND "${KSYMS_FILE}"
	elif [ -f "${RKHROOTDIR}/proc/ksyms" ]; then
		display --to LOG --type INFO KSYMS_FOUND "${RKHROOTDIR}/proc/ksyms"
		display --to LOG --type INFO KSYMS_UNAVAIL
	elif [ -f "${RKHROOTDIR}/proc/kallsyms" ]; then
		display --to LOG --type INFO KSYMS_FOUND "${RKHROOTDIR}/proc/kallsyms"
		display --to LOG --type INFO KSYMS_UNAVAIL
	else
		display --to LOG --type INFO KSYMS_MISSING
	fi

	test $SHOW_SUMMARY -eq 0 && display --to LOG --type INFO CONFIG_NO_SHOW_SUMMARY


	#
	# To use syslog we must have the logger command present.
	#

	if [ -n "${USE_SYSLOG}" ]; then
		if [ "${USE_SYSLOG}" = "none" ]; then
			USE_SYSLOG=""
			display --to LOG --type INFO SYSLOG_DISABLED
		else
			LOGGER_CMD=`find_cmd logger`

			if [ -n "${LOGGER_CMD}" ]; then
				display --to LOG --type INFO SYSLOG_ENABLED "${USE_SYSLOG}"
			else
				USE_SYSLOG=""
				display --to LOG --type INFO SYSLOG_NO_LOGGER
			fi
		fi
	fi


	if [ "${EPOCH_DATE_CMD}" = "NONE" ]; then
		:
	elif [ -n "${EPOCH_DATE_CMD}" ]; then
		display --to LOG --type INFO FILE_PROP_EPOCH_DATE_CMD "${EPOCH_DATE_CMD}"
	elif [ -n "${PERL_CMD}" ]; then
		display --to LOG --type INFO FILE_PROP_EPOCH_DATE_CMD "${PERL_CMD}"
	fi


	#
	# If the user wants to run the file properties checks, and the
	# rkhunter.dat file exists, then check the O/S info. If the
	# rkhunter.dat file does not exist, then this will be logged
	# later on.
	#

	if `check_test properties`; then
		if [ -s ${RKHDAT_FILE} ]; then
			#
			# We perform a simple check on some of the stored
			# O/S information, and compare it to the current
			# info. Basically we are just seeing if the system
			# has changed at all because it could affect the
			# file properties checks.
			#

			rkh_dat_get_os_info

			check_os_info
		fi
	fi
fi

if [ $USE_LOCKING -eq 1 ]; then
	display --to LOG --type INFO LOCK_USED "$LOCK_TIMEOUT"
else
	display --to LOG --type INFO LOCK_UNUSED
fi


######################################################################
#
# Start of program actions and checks
#
######################################################################


#
# We can now start to run the actions the user has requested on
# the command-line. We run the update type commands first before
# doing any full system check.
#


#
# The user wants to update the O/S and the file properties data.
#

test $PROP_UPDATE -eq 1 && do_prop_update


#
# The user wants to update the supplied RKH *.dat files.
#

test $UPDATE -eq 1 && do_update


#
# The user wants to check for the latest program version.
#

test $VERSIONCHECK -eq 1 && do_versioncheck


#
# The user wants to check the local system for anomalies.
#

test $CHECK -eq 1 -o $ENDIS_OPT -eq 1 && do_system_check


#
# If there were errors or warnings, and the
# log file is to be copied, then log it.
#

COPIEDLOG=""

if [ $RET_CODE -gt 0 -o $WARNING_COUNT -gt 0 ]; then
	if [ $COPY_LOG_ON_ERROR -eq 1 -a $NOLOG -eq 0 ]; then
		COPIEDLOG="${RKHLOGFILE}.`date +%Y-%m-%d_%H:%M:%S`"

		display --to LOG --type INFO --nl SUMMARY_LOGFILE_COPIED "${COPIEDLOG}"
	fi
fi

display --to LOG --type INFO --nl RKH_ENDDATE "`date`"


#
# Now actually copy the log file.
#

test -n "${COPIEDLOG}" && cp -p ${RKHLOGFILE} ${COPIEDLOG}


#
# If the user asked to see the logfile, then show it.
#

test $CATLOGFILE -eq 1 && cat ${RKHLOGFILE}


IFS=$ORIGIFS

exit $RET_CODE
